

\section{Investigating Command Pairs}\label{section_axioms}

% TODO Ref back to intro; further abstraction - no need to go the FS. break-all, equiv, extend
So that we could describe the effects of commands on a filesystem, let us introduce some notation
and note some observations.

The commands we aim to investigate do not occur in isolation:
for example, when comparing filesystems to determine the commands needed to transform one into the other,
we receive a set of commands with uncertain ordering.
Applying commands to a filesystem, however, happens in time,
so for this we need a sequence of commands.
We use $\cc$ to concatenate commands to form a sequence, or concatenate sequences to form a longer sequence:
$S=\cbdaa{n}{\vald}\cc\cbfaa{m}{\valf}$, or $S'=S\cc\cbba{o}$.
We write $\emptyseq$ for the empty sequence.

TODO: Sequences of commands, in the usual way,  form a free
semigroup

The following concepts 
(which echo the ones defined in \cite{NREC})
allow us to investigate sequences independently of filesystems.
In the definitions, $A,B,S,T$ stand for arbitrary sequences of commands.

\begin{mydef}
% Relation in the algebra
$A\equiv B$ means that $A$ and $B$ are equivalent,
% intended interpretation:
that is, they behave in the same way on
all filesystems: $\forall \FS: A\FS=B\FS$.
It is a reflexive, commutative and transitive relation,
and clearly
% inference rule:
$ A\equiv B \Rightarrow S\cc A\cc T\equiv S\cc B\cc T $.
\end{mydef}

\begin{mydef}
% Relation in the algebra
$A\eqext B$ means that $B$ extends $A$,
% intended interpretation:
that is, they behave in the same way
on any filesystem $A$ does not break:
$\forall \FS: A\FS\neq\fsbroken\Rightarrow A\FS=B\FS$.
It is a reflexive and transitive relation,
and we can see that
% inference rules:
$ A\eqext B \Rightarrow S\cc A\cc T\eqext S\cc B\cc T$
and
$ A\equiv B \Rightarrow A\eqext B$.
\end{mydef}

Let us also define the following relations between nodes:

\begin{mydef}{$n\descendant m$.}
We write $n\descendant m$ if $n$ is the ancestor of $m$ ($n=\parent^n(m)$). % TODO (the transitive closure of the $\parent$ relation)
We write $n\descendantEq m$ if $n\descendant m$ or $n=m$.
\end{mydef}

\begin{mydef}{$n\unrel m$.}
We write $n\unrel m$, or ``$n$ and $m$ are unrelated'' if $n\not\descendantEq m$ and $n\not\ancestorEq m$.
\end{mydef}


Our aim is to derive information about the effects of sequences
of commands independently of the actual filesystems.
In order to make this possible, we investigate the smallest building
blocks of sequences: pairs of commands that act on a filesystem directly one after the other.
This approach is useful as there are a limited number of command pairs,
because, as we argued above, we can disregard the exact output values of commands apart from their type,
and we can also abstract the relationship between the nodes in the two commands
to a finite number of cases.

We methodically investigated of all possibilities using a computer program
to determine
which pairs of commands cause errors all the time,
which can be simplified to one or no commands, and which can be reversed
without any change in their overall effect.
% TODO: Footnote: https://github.com/csirmaz/AlgebraicSyncPaper/blob/master/2015/prove.py
Our basis for this investigation was the model of filesystems introduced in this paper.
These properties of command pairs are crucial as they determine
how a set of commands can be re-ordered to be applied to a filesystem
during synchronization, and what commands will never be compatible.

Below we list a number of statements derived using this method.
Although they can be proven by investigating all relevant possibilities
in a filesystem, we refer to these as axioms because in a secondary algebraic model
that describes commands without reference to an underlying filesystem,
these would function as meta-rules generating statements we would accept as true.
See \cref{sec_algebra} for more about such a model.

\medskip

Pairs of commands in general have the form
\[ \cxynv\cc  \czwmv \]
where $X,Y,Z,W\in\typeset$, $n,m\in\setn$, 
and values are of the appropriate type: 
$\valvy\in\setvx{Y}$ and $\valvw\in\setvx{W}$.

\begin{myax}\label{ax_separate_commute}
Commands on unrelated nodes commute:
$\cxynv\cc\czwmv \equiv \czwmv\cc\cxynv$ where $n\unrel m$.
\end{myax}

\begin{myax}\label{ax_separate_nobreaks}
Commands on unrelated nodes do not break every filesystem:
$\cxynv\cc\czwmv \nequiv \cbrk$ where $n\unrel m$.
\end{myax}

\begin{myax}\label{ax_same_breaks}
Commands on the same node break every filesystem if their types are incompatible:
$\cxynv\cc\czwnv \equiv \cbrk$ where $Y\ne Z$.
\end{myax}

\begin{myax}\label{ax_same_emptyseq}
Commands on the same node simplify:
$\cxynv\cc\czwnv \eqext \emptyseq$ where $Y=Z$ and $X=W=\ccharb$ 
or $X=W=\cchard$.
\end{myax}

\begin{myax}\label{ax_same_singlec}
Commands on the same node simplify:
$\cxynv\cc \czwnv \equiv \cxwnv$ where $Y=Z$ and $\cxw\neq\cbb$ and $\cxw\neq\cdd$.
\end{myax}

\begin{myax}\label{ax_distantrel_breaks}
Commands on distant relatives break all filesystems:
$\cxynnv\cc\czwnv \equiv \cbrk$
and $\czwnv\cc\cxynnv \equiv\cbrk$
where $\nn\descendant n$ and $\nn\neq\parent(n)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$.
\end{myax}

\begin{mydef}{Construction pair.}
A pair of commands on nodes $\nn$ and $n$ is a construction pair if $\nn=\parent(n)$ 
and the commands are one
of the following:
   \begin{gather*}
   % bd>bf
            \cbdaa{\nn}{\vald}\cc  \cbfaa{n}{\valf} \\
   % bd>bd
            \cbdaa{\nn}{\valdi}\cc  \cbdaa{n}{\valdii} \\ % TODO all directories are the same?
   % fd>bf
            \cfdaa{\nn}{\vald}\cc  \cbfaa{n}{\valf} \\
   % fd>bd
            \cfdaa{\nn}{\valdi}\cc  \cbdaa{n}{\valdii} % TODO all directories are the same?
   \end{gather*}
\end{mydef}

\begin{myax}\label{ax_directchild_breaks}
All other commands on a child break every filesystem:
$\cxynnv\cc\czwnv \equiv \cbrk$ where $\nn=\parent(n)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$
and the pair is not a construction pair.
\end{myax}

\begin{mydef}{Destruction pair.}
A pair of commands on nodes $n$ and $\nn$ is a destruction pair if $\parent(n)=\nn$ and the commands are one
of the following:
   \begin{gather*}
   % fb<db ??
            \cfba{n}\cc  \cdba{\nn} \\
   % fb<df ??
            \cfba{n}\cc  \cdfaa{\nn}{\valf} \\
   % db<db ??
            \cdba{n}\cc  \cdba{\nn} \\
   % db<df ??
            \cdba{n}\cc  \cdfaa{\nn}{\valf}
   \end{gather*}
\end{mydef}

\begin{myax}\label{ax_directparent_breaks}
All other commands on a parent break every filsystem:
$\cxynv\cc\czwnnv \equiv \cbrk$ where $\parent(n)=\nn$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$
and the pair is not a destruction pair.
\end{myax}

\begin{mydef}{Assertion command.}
A command is an assertion command if
for every filesystem it either breaks it or leaves it in the same state.
In other words, assertion commands have the same input and output type,
and there must also be only one possible value for their output.
Accordingly, in our current algebra, $\cbba{n}$ and $\cdda{n}$ are the only two assertion commands,
and we do not note their output value as it is determined.
\end{mydef}

\begin{myax}\label{ax_child_assert}
An assertion command can be added on a descendant node:
$\cbba{n}\cc\cxynnv \equiv \cxynnv \equiv \cxynnv\cc\cbba{n}$ 
where $\nn\descendant n$ and $\cxy\neq\cdd$.
\end{myax}

\begin{myax}\label{ax_parent_assert}
An assertion command can be added on an ancestor node:
$\cdda{\nn}\cc\cxynv \equiv \cxynv \equiv \cxynv\cc\cdda{\nn}$ 
where $\nn\descendant n$ and $\cxy\neq\cbb$.
\end{myax}

\begin{myax}\label{ax_assert}
Assertion commands can be removed:
$\cxynv \eqext \emptyseq$ where $\cxy=\cbb$ or $\cxy=\cdd$.
\end{myax}
