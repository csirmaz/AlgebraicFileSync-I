\documentclass[12pt]{article}

\usepackage{alltt}
\usepackage{comment}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{afterpage}
\usepackage{centernot}

\usepackage{tikz}

\newcommand{\setv}{\mathcal{V}}
\newcommand{\setvx}[1]{\mathcal{V}_{#1}}
\newcommand{\setf}{\setvx{F}}
\newcommand{\setd}{\setvx{D}}
\newcommand{\setb}{\setvx{\empt}}
\newcommand{\setp}{\mathcal{P}}
\newcommand{\empt}{\bot}
\newcommand{\parent}{\mathtt{parent}}
\newcommand{\FS}{\Phi} % {\mathrm{FS}}
\newcommand{\GS}{\Xi} % another filesystem
\newcommand{\pp}{p^\uparrow} % parent path
\newcommand{\np}{p_{\centernot\leftrightarrow}} % path not related to p

\newcommand{\cbrk}{\mathtt{break}}
\newcommand{\fscommand}[2]{{#1#2}}
\newcommand{\fsregcommandchar}[1]{\mathtt{#1}}
\newcommand{\fsregcommand}[2]{\fscommand{\fsregcommandchar{#1}}{\fsregcommandchar{#2}}}
\newcommand{\cbb}{\fsregcommand{\empt}{\empt}}
\newcommand{\cbf}{\fsregcommand{\empt}{F}}
\newcommand{\cbd}{\fsregcommand{\empt}{D}}
\newcommand{\cfb}{\fsregcommand{F}{\empt}}
\newcommand{\cff}{\fsregcommand{F}{F}}
\newcommand{\cfd}{\fsregcommand{F}{D}}
\newcommand{\cdb}{\fsregcommand{D}{\empt}}
\newcommand{\cdf}{\fsregcommand{D}{F}}
\newcommand{\cdd}{\fsregcommand{D}{D}}
\newcommand{\cxy}{\fscommand{X}{Y}}
\newcommand{\cyz}{\fscommand{Y}{Z}}
\newcommand{\cxz}{\fscommand{X}{Z}}
\newcommand{\czw}{\fscommand{Z}{W}}
\newcommand{\cqr}{\fscommand{Q}{R}}

\newcommand{\eqext}{\sqsubseteq}
\newcommand{\eqnrw}{\sqsupseteq}
\newcommand{\nequiv}{\not\equiv}

\newcommand{\emptyseq}{[\,]}

\newcommand{\extset}[1]{\wp{#1}}
\newcommand{\orderset}[1]{\vec{\wp}{#1}}

\title{A More Complete Algebra for File Synchronization}

\author{Elod Pal Csirmaz}

\begin{document}
\maketitle
\begin{abstract}
Abstract goes here
\end{abstract}

\section{Introduction}

% Synchronization:
% Main aim: apply updates (where possible) from other replicas
% update detection -> conflict detection -> merging updates -> ordering updates -> apply updates from other replicas
% Problems: conflict detection, ordering

\section{Definition of a Filesystem}

We model a filesystem using a function $\FS$ with a set of paths $\setp$ as its domain,
and a set of possible contents $\setv$ as its codomain:
\[ \FS : \setp \rightarrow \setv \] 
In our model, $\setp$ contains all possible paths, and $\setv$ contains a special
element, $\empt$, which is the value of $\FS$ at paths where there are no files
or directories.
We consider the contents of files, as well as any meta-information of files
and directories (e.g. permissions or flags) part of the values in $\setv$.

Every filesystem has a so-called \textbf{tree property}, which means that
if the filesystem is not empty at a path, and it is not a root path,
then it must have a directory at the path's parent.
This requires that a parent--child relationship is defined over $\setp$,
which we model using the function $\parent$, which returns the parent path
or $\empt$ if the path is a root path:
\[ \parent : \setp \rightarrow \setp \cup \{\empt\} \]

Moreover, in $\setv$ we distinguish between files ($\setf$) and directories ($\setd$), that is,
if $\setb = \{\empt\}$ then:
\[ \setv = \setb \cup \setf \cup \setd \]
The tree propety can then be defined as
\[ \forall \FS, p\in\setp : \FS(p) \neq \empt \wedge \parent(p) \neq \empt \Rightarrow \FS(\parent(p)) \in \setd \]

This means that as we move from a path to its child, its grandchild, and so on,
the types of values we encounter in the filesystem can only change according to the following
transition diagram:

\input{type-transition}

In other words, the types will form a sequence like $D,D,\cdots,D,F,\empt,\empt,\cdots$.

In this paper, we write $F$ for an arbitrary element of $\setf$, and $D$ for an arbitrary element
of $\setd$. $V$ is usually a value from $\setv$ and $p$ and $q$ are paths in $\setp$.

\section{Commands}

Next we need to define instructions or commands on the filesystem about which we will reason
using our algebra.
We will aim to draw conclusions or judgements about commands and sequences of commands
based on the algebra we are aiming to construct.
For example, if we believe that two sequences of commands are equivalent as their effect
is the same, then we aim to be able to derive this from the axioms and inference rules of the
algebra.
As the algebra operates on commands only,
these judgements, by definition, need to hold regardless of the filesystem the commands are applied to.
Accordingly, we expect that the more information one encodes into the commands and the sequences,
the better predicitons we will be able to make using our algebra,
as then the commands and sequences will be more specific, and will select a smaller subset
of potential filesystems on which they can meaningfully operate.

Let us consider what kind of information may be encoded in the commands.
A usual set of commands, based on the most frequent tools implemented by filesystems,
might be $create(p,V)$, $edit(p,V)$ and $remove(p)$ where $p\in\setp$ and $V\in\setv$ (but $V\neq\empt$).
Clearly the commands need to contain information about the state they leave the filesystem
in at the path on which they operate, that is, they need to contain the ``end'' value, $V$.
Notice, however, that the commands above also encode some information about the filesystem
{\it before} the command is applied; namely, $create$ requires that there are no files
or directories at $p$, while $edit$ and $remove$ require the opposite.

We also know that after $create$ or $edit$, $\FS(p)\neq\empt$, whereas after $remove$,
$\FS(p)$ will be $\empt$. However, from \cite{NREC:alg} we know that a useful set of axioms
will in some cases need to distinguish between edits that result in directories ($edit(p,D)$) and
ones that result in files ($edit(p,F)$);
and Bill Zissimopoulos suggested in \cite{BZ} that extending this distinction simplifies
definitions based on our algebra, as it is then able to predict the behaviour of commands
more precisely. 
In other words, encoding this information in the commands is definitely useful,
but it creates a seemingly arbitrary asymmetry where
there is more information encoded into commands about their results than about the
original state of the filesystem.

In line with the aim to encode in commands as much information as possible,
and in order to resolve this asymmetry, we propose a set of commands that encode
the type of the original state of $\FS(p)$ as well.
(Some real-life filesystem commands like $mkdir$ or $rmdir$ do this already.)
Please note that there is never any need to encode information about the
{\it exact} value of path $p$ in a command, merely its type ($D$, $F$ or $\empt$),
as the success or failure of subsequent commands only depend on the type of the value.

We therefore propose to have a command for each pair of types.
For want of a better system, we will simply name our commands by concatenating
two of $\fsregcommandchar{D}$, $\fsregcommandchar{F}$ and $\fsregcommandchar{\empt}$, 
where the left sign notes the type of value
in the filesystem before the command is applied, and the right sign notes the type
afterwards. For example $mkdir(p,D)$ is $\cbd(p,D)$ and $rmdir(p)$ is $\cdb(p)$.

% TODO No "move"

\section{Applying Commands}

The commands can only succeed if the original value at $p$ has a type that matches
the type required by a command. If this is not the case, or if the resulting
filesystem no longer has the tree property, then we say that the command
\textbf{breaks} the filesystem. Broken filesystems are considered equal
(but not equal to any working filesystem), and we note them by $\FS=\empt$.

So that we could reason about sequences of commands that break every filesystem
in the algebra, we introduce the command $\cbrk$ that simply breaks every filesystem.
We note that a sequence of commands $S$ is applied to a filesystem
by prefixing the sequence to it:
\begin{itemize}
\item $S\FS$
\item $[\cbrk]\FS=\empt$
\item $[\cff(p,F)]\FS = \GS$, for which $\GS(p)=F$ holds
and $\GS(q)=\FS(q)$ for any path $q\neq p$.
\end{itemize}

\section{Sequences of Commands}

We aim to use our algebra to define and implement algorithms for conflict detection
and ordering updates (commands) before we can apply them to all replicas.
Conflicts and ordering all happen between commands, therefore in our algebra
we will reason about sequences of commands, 
and do so based on a set of axioms about pairs of neighbouring commands.
We are interested to see which pairs of commands cause errors all the time,
and which can be simplified or reversed
in order to see under what circumstances commands conflict or can be reordered.

Pairs of commands in general will have the form
\[ [\cxy(p,V_Y); \czw(q,V_W)] \]
where $X,Y,Z,W\in\{\fsregcommandchar{D},\fsregcommandchar{F},\empt\}$, $p,q\in\setp$, and values are of the appropriate type: 
$V_Y\in\setvx{Y}$ and $V_W\in\setvx{W}$.
(Strictly speaking, commands where $Y=\empt$ or $W=\empt$ do not require a value,
but they can also be written in a $\fscommand{X}{\empt}(p, \empt)$ form.)

Similarly to the case of commands, in \cite{NREC:alg} we found that in order to build
a set of axioms in a sound and complete algebra and use the algebra effectively we at times needed to take into account
the relationship between the paths of the commands in the pair, $p$ and $q$.
As the relationship between the paths determine how the commands affect the filesystem
and its tree property, 
and again in line with the aim of providing as much information as possible for the algebra,
we encode this relationship in the pair of commands. The possible relationships we
consider are as follows.

\begin{description}
\item[Same.] Paths that are the same ($p=q$). If the two commands affect the same path, the pair of commands
will clearly behave differently than if the paths are different.
%
\item[Unrelated.] Paths that are not \emph{directly} related,
that is, where $\parent(p)\neq q$ and $\parent(q)\neq p$. 
In this case modifying the filesystem at one path is not going
to affect the outcome of the command on the other path.
The two commands will therefore commute and the pair will be reversible.
We will denote a path separate from $p$ with $\np$.
%
\item[Directly related.] Directly related paths, that is, $\parent(p)=q$ or $\parent(q)=p$.
For simplicity, we will write $\pp$ for $\parent(p)$.
Some of these command pairs will not be reversible.
For example, $[\cbd(\pp,D);\cbf(p,F)]$ will work on some filesystems,
while $[\cbf(p,F);\cbd(\pp,D)]$ will break all filesystems.
\end{description}

One may think that we may be able to specify more about the reversibility
or possible simplification of a pair of commands in the last group if we also
knew whether the child path $p$ was the only (non-empty) child of its parent.
However, it is easy to see that encoding this information in a pair
is not going to enrich our algebra as, for example,
the behaviour of a hypothetical $[\cfb(p_{\mathrm{only\ child}}); \cdb(\pp)]$
is exactly the same as that of the more generic
$[\cfb(p); \cdb(\pp)]$. The former will break any filesystem in which
$p$ is not the only child as it violates its preconditions, but so will
the generic pair.

% TODO Would it be worth encoding non-direct parent/child relationships?

In summary, we have pairs of commands
of the following forms:
\begin{description}
\item[Unrelated.] \( [\cxy(p,V_Y); \czw(\np,V_W)] \)
\item[Same.] \( [\cxy(p,V_Y); \czw(p,V_W)] \)
\item[Down.] \( [\cxy(\pp,V_Y); \czw(p,V_W)] \)
\item[Up.] \( [\cxy(p,V_Y); \czw(\pp,V_W)] \)
\end{description}

%% What does it mean to restrict the inspected filesystems to a given relationship?

\section{Defining the Algebra}

In order to reason about sequences of commands, we define \emph{algebraic laws} on
commands. We use formal logic to build a proof system which is sound and
complete for its intended interpretation.

Similarly to \cite{NREC:alg}, we have two kinds of judgements
for sequences \(S_1\) and \(S_2\):
\begin{itemize}
\item \(S_1\equiv S_2\), or \emph{\(S_1\) is algebraically equivalent to
\(S_2\)}. Its intended interpretation is that they act in the same way on all
filesystems.
\item \(S_1\eqext S_2\), or \emph{\(S_2\) extends \(S_1\)}; its intended
interpretation is that they act in the same way on all
filesystems that \(S_1\) does not break.
\end{itemize}

We have two inference rules for the two judgements,
which make it possible to derive new statements from the axioms or other statements.
These are:

\emph{For any sequences \(S_1, S_2, S, S'\):}
\begin{itemize}
\item if \(S_1\equiv S_2\) then \(S;S_1;S'\equiv S;S_2;S'\)
\item if \(S_1\eqext S_2\) then \(S;S_1;S'\eqext S;S_2;S'\)
\item if \(S_1\equiv S_2\) then \(S_1\eqext S_2\).
\end{itemize}

Finally, we have a set of axioms or laws that describe the behaviour
of each command pair. We exclude commands that either break the
filesystem or leave it in the same state ($\cbb$) and for
simplicity's sake we merged axioms where the outcome is predictable
from the relationship between the paths in the commands.

\begin{description}
\item[Unrelated.] If the two paths in the pair are not directly related, then
the commands commute with an equivalence and they will not break every filesystem:
\begin{align*}
[\cxy(p,V_Y); \czw(\np,V_W)] &\equiv [\czw(\np,V_W); \cxy(p,V_Y)] \\
&\nequiv \cbrk
\end{align*}
%
\item[Same.] If the two paths are the same ($[\cxy(p,V_Y); \czw(p,V_W)]$), the
the commands cannot be reversed. Instead:
   \begin{description}
   \item[Break.]
   The pair will break every filesystem if $Z\ne Y$, that is, if the second
   command expects a type of value different from the one left by the first command.
   \item[Simplified by extension.]
   Otherwise, the pair will simplify to a single or no commands
   if both $X$ and $W$ are $\fsregcommandchar{\empt}$ or $\fsregcommandchar{D}$:
   \begin{gather*}
   % bf=fb Sp
            [\cbf(p, F); \cfb(p)] \eqext \emptyseq \\
   % bd=db Sp
            [\cbd(p, D); \cdb(p)] \eqext \emptyseq \\
   % db=bd Sp
            [\cdb(p); \cbd(p, D)] \eqext [\cdd(p, D)] \\
   % df=fd Sp
            [\cdf(p, F); \cfd(p, D)] \eqext [\cdd(p, D)]
   \end{gather*}
   \item[Simplified by equivalence.]
   In all other cases, the commands are equivalent to a single command
   replacing the input of the first command with the output of the second:
   \[ [\cxy(p, V_Y); \cyz(p, V_Z)] \equiv [\cxz(p, V_Z)] \]
   \end{description}
%
\item[Down.]
These are the pairs in which the first command is applied to the parent of the path
of the second command.
   \begin{description}
   \item[Construction.] There are pairs in this group to which no law applies.
   We call these ``construction'' pairs:
   \begin{gather*}
   % bd>bf
            [\cbd(\pp, D); \cbf(p, F)] \\
   % bd>bd
            [\cbd(\pp, D_1); \cbd(p, D_2)] \\
   % fd>bf
            [\cfd(\pp, D); \cbf(p, F)] \\
   % fd>bd
            [\cfd(\pp, D_1); \cbd(p, D_2)]
   \end{gather*}
   \item[Commute.] Otherwise, the commands in these pairs commute iff the first command is $\cdd$. For example:
   \begin{gather*}
   [\cdd(\pp, D); \cbf(p, F)] \equiv [\cbf(p, F); \cdd(\pp, D)]
   \end{gather*}
   \item[Break.] All other pairs break every filesystem, e.g.:
   \begin{gather*}
   [\cdf(\pp, F); \cbd(p, D)] \equiv \cbrk
   \end{gather*}
   \end{description}
%
\item[Up.]
The final group of pairs are the ones in which the path in the second
command is the parent of the one in the first.
These behave similarly to the previous group. 
   \begin{description}
   \item[Desctruction.] There are
   so-called ``destruction'' pairs to which no law applies:
   \begin{gather*}
   % fb<db ??
            [\cfb(p); \cdb(\pp)] \\
   % fb<df ??
            [\cfb(p); \cdf(\pp, F)] \\
   % db<db ??
            [\cdb(p); \cdb(\pp)] \\
   % db<df ??
            [\cdb(p); \cdf(\pp, F)]
   \end{gather*}
   \item[Commute.] Otherwise the commands commute iff the \emph{second} command is $\cdd$.
   \item[Break.] All other pairs break every filesystem.
   \end{description}
\end{description}

\section{Real-Life Variant}

In real-life applications, we often do not want to consider metadata stored in
directories (\cite{BZ}). In other words, the contents of directories are all equal,
which can be modelled by assuming that $|\setd|=1$.
Note that this creates a convenient symmetry where there are only a single value
for each type that can be repeated as we move from a path to its child ($D$ and $\empt$).

This also means that $\cdd$, like $\cbb$, becomes a command that either breaks a filesystem
or leaves it in the same state, and we will disregard it in our algebra.
The axioms will simplify as follows:

\begin{description}
\item[Unrelated.] Pairs with unrelated paths are still reversible and not equivalent to
$\cbrk$, but these are the only pairs that are reversible.
%
\item[Same.] If the two paths are the same ($[\cxy(p,V_Y); \czw(p,V_W)]$), then,
as above, the commands do not commute.
   \begin{description}
   \item[Break.] Also, as above, the pair will break every filesystem if $Z\ne Y$.
   \item[Simplified by extension.] Otherwise, the pair is extended by an empty sequence
   if both $X$ and $W$ are $\fsregcommandchar{\empt}$ or $\fsregcommandchar{D}$:
   \begin{gather*}
   % bf=fb Sp
            [\cbf(p, F); \cfb(p)] \eqext \emptyseq \\
   % bd=db Sp
            [\cbd(p, D); \cdb(p)] \eqext \emptyseq \\
   % db=bd Sp
            [\cdb(p); \cbd(p, D)] \eqext \emptyseq \\
   % df=fd Sp
            [\cdf(p, F); \cfd(p, D)] \eqext \emptyseq
   \end{gather*}
   \item[Simplified by equivalence.]
   And in all other cases, as above, the commands are equivalent to a single command
   replacing the input of the first command with the output of the second:
   \[ [\cxy(p, V_Y); \cyz(p, V_Z)] \equiv [\cxz(p, V_Z)] \]
   \end{description}
%
\item[Down.]
Of the pairs in which the first command is applied to the parent path:
   \begin{description}
   \item[Construction.] the same ``construction'' pairs still have no laws, 
   \item[Break.] but all other pairs break all filesystems.
   \end{description}
%
\item[Up.]
And of the pairs where the second command
is applied to the parent path,
   \begin{description}
   \item[Destruction.] we still have the ``destruction'' pairs,
   \item[Break.] and all other pairs break all filesystems.
   \end{description}
\end{description}

{\bf Going forward we use the algebra derived from the $|\setd|=1$ case.}

\section{Ordering commands}

We often encounter the case where we only have a set of commands without a sepcified order.
Indeed, it is actually the task of the reconciler to determine whether there is an order
in which updates from multiple replicas can all be applied to a filesystem.

By a {\bf minimal sequence or set} of commands we mean a sequence / set in which
there is at most one command on each path.

If $U$ is a minimal set of commands
that we know can be applied to at least one filesystem in some order without breaking it,
then we can split $U$ into a maximum number of disjunct subsets
(components) so that the paths of two commands from different subsets would never be directly related.
If we aim to order the commands in $U$, then we can focus on order the commands
inside the components, as all permutations of the components are allowed:
the commands in them will commute.

Components containing a single command do not pose a problem when determining
possible orders.
(Note that $\cff$ can only appear in a component of one.)

In each component that is larger than one, the patch are directly related
and the commands form construction or destruction chains.
To order the commands,
select the command with the topmost path, so that there would be no command
on its parent path. If the command removes content at this path, the command
needs to follow all other commands in the component, and
the component is a destruction component.
Otherwise the command with the topmost component needs to precede other commands
in the component, and it is a construction component.
Repeat the above process of splitting commands into subsets on the remaining commands
in the component. Recursively, this way we can determine all allowed orders of the commands.

We use $\orderset{U}$ to denote the set of sequences that contain all commands in $U$
and represent all allowed orders. As a specific case, we can regard a sequence of commands $S$
as a set and determine its $\orderset{S}$.
At times by $\orderset{U}$ we mean an arbitrary sequence in the set.

% (O-D)
{\bf Lemma.} If $U$ contains commands on both $p$ and $\pp$, then
there is a $U^*\in\orderset{U}$ where they are next to each other.

{\bf Lemma.} For any minimal sequence $S$ not equivalent to $\cbrk$,
$\orderset{S} = \extset{S}$.

\section{Soundness}

\section{Completeness}

{\bf Lemma.} \((\forall\FS: S\FS = \empt) \Rightarrow S \equiv \cbrk\)

\section{Update detection}

\section{Reconciliation}

If $A$ and $B$ are minimal sequences and there is at least one filesystem neither of them breaks,
we write $A\circ B$. In this case based on the soundness of the algebra
we also know that $A\nequiv\cbrk$ and $B\nequiv\cbrk$.
Also, if there are commands on path $p$ in both $A$ ($\cxy(p, V_Y)$) and $B$ ($\czw(p, V_W)$)
then their input types must match ($X=Z$).

{\bf Lemma.} Let $A$ and $B$ be two minimal sequences so that $A\circ B$.
Then their intersection can also be applied to any filesystem
either can be applied to without breaking it.

Proof.
First we prove the following.
Mark all commands in $A$ that also appear in $B$.
Then $\exists A^* \in \orderset{A}$ in which the marked commands are at the beginning.

We show $A$ can be transformed via equivalences so that this would be true
by induction on the number of non-marked commands preceding the last marked command.
If it is 0, no transformation is needed.
For the induction step, select the last marked command preceded by a non-marked command.
If the two commute, reverse them, thereby reducing the number on relevant non-marked commands.
If they do not commute, they must be a construction or destruction pair as we know
that $A$ is minimal and $A\nequiv\cbrk$.

Let the marked command be $\cxy(p, V_Y)$ and the preceding unmarked command in $A$ be $\czw(q, V_W)$.
We have two cases and we will proceed by indirection.

If $B$ has a command on $q$, let it be $\cqr(q, V_R)$. As $A\circ B$, we know
that $Q=Z$. From 
O-D (TODO ref)
we also know that there is a $B^*\equiv B$ where $\cxy$ and $\cqr$ are next to each other,
and from the construction and destruction laws we know that $\cxy$ determines that like
$\czw(q, V_W)$ in $A$, any command on $q$ must precede it in $B$. As $B$ is minimal, $B^*$
contains the same commands, and so it is the $\cqr$ command that precedes $\cxy$ in $B^*$.
Going back to the construction and destruction laws we see that the output type of the first command
is always the same, and it is either $D$ or $\empt$. Therefore $R=W$ and $\cqr(q, V_R)=\czw(q, V_W)$
as $|\setd|=|\setb|=1$. This is a contradiction as $\czw$ was not marked, but we see it must also be in $B$.

If $B$ has no command on $q$, 



\begin{thebibliography}{99}

\bibitem{NREC:alg} Ramsey, Norman and Elod Csirmaz: {\it An algebraic approach to
file synchronization...}

\bibitem{BZ} Bill Zissimopoulos, personal communication, ...

\end{thebibliography}

\end{document}
