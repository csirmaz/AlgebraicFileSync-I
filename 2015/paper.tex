\documentclass[12pt]{article}

% \usepackage{alltt}
% \usepackage{comment}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
% \usepackage{graphicx}
\usepackage{centernot}
\usepackage{tikz}
\usepackage{cleveref}

\newcommand{\setv}{\mathcal{V}}
\newcommand{\setvx}[1]{\mathcal{V}_{#1}}
\newcommand{\setf}{\setvx{F}}
\newcommand{\setd}{\setvx{D}}
\newcommand{\setb}{\setvx{\empt}}
\newcommand{\setp}{\mathcal{P}}
\newcommand{\empt}{\bot}
\newcommand{\parent}{\mathtt{parent}}
\newcommand{\toppath}{\mathtt{None}} % return value of parent()
\newcommand{\fsbroken}{\mathtt{Broken}} % broken FS value
\newcommand{\FS}{\Phi} % a filesystem
\newcommand{\GS}{\Xi} % another filesystem
\newcommand{\pp}{p\!\!\uparrow} % parent path

\newcommand{\cbrk}{\mathtt{break}}
\newcommand{\fscommand}[2]{{#1#2}}
\newcommand{\fsregcommandchar}[1]{\mathtt{#1}}
\newcommand{\fsregcommand}[2]{\fscommand{\fsregcommandchar{#1}}{\fsregcommandchar{#2}}}
\newcommand{\cbb}{\fsregcommand{\empt}{\empt}}
\newcommand{\cbf}{\fsregcommand{\empt}{F}}
\newcommand{\cbd}{\fsregcommand{\empt}{D}}
\newcommand{\cfb}{\fsregcommand{F}{\empt}}
\newcommand{\cff}{\fsregcommand{F}{F}}
\newcommand{\cfd}{\fsregcommand{F}{D}}
\newcommand{\cdb}{\fsregcommand{D}{\empt}}
\newcommand{\cdf}{\fsregcommand{D}{F}}
\newcommand{\cdd}{\fsregcommand{D}{D}}
\newcommand{\cxy}{\fscommand{X}{Y}}
\newcommand{\cyz}{\fscommand{Y}{Z}}
\newcommand{\cxz}{\fscommand{X}{Z}}
\newcommand{\czw}{\fscommand{Z}{W}}
\newcommand{\cqr}{\fscommand{Q}{R}}
\newcommand{\cqq}{\fscommand{Q}{Q}}

\newcommand{\typeset}{\{\fsregcommandchar{D},\fsregcommandchar{F},\empt\}}

\newcommand{\descendant}{\prec}
\newcommand{\ancestor}{\succ}

\newcommand{\eqext}{\sqsubseteq}
\newcommand{\eqnrw}{\sqsupseteq}
\newcommand{\nequiv}{\not\equiv}

\newcommand{\works}[1]{\dot{\mathbf{w}}({#1})}
\newcommand{\worksc}[2]{\dot{\mathbf{w}}({#1}|{#2})}

% TODO: delete:
\newcommand{\np}{p_{\centernot\leftrightarrow}} % path not related to p TODO change this
\newcommand{\wrext}{\stackrel{\mathtt{br}}{\sqsubseteq}}
\newcommand{\wrnrw}{\stackrel{\mathtt{br}}{\sqsupseteq}}
\newcommand{\coworks}{\circ}
\newcommand{\ncoworks}{\centernot\circ}

\newcommand{\emptyseq}{[\,]}

\newcommand{\extset}[1]{\wp({#1})}
\newcommand{\orderset}[1]{\vec{\wp}({#1})}
\newcommand{\ordered}[1]{\vec{\mathbf{o}}({#1})}

\newcommand{\recchar}[3]{{#1}^{#3}_{\mathcal{R}|{#2}}}
\newcommand{\reca}{\recchar{A}{B}{}} % Reconciliation
\newcommand{\recb}{\recchar{B}{A}{}}
\newcommand{\recaset}{\recchar{A}{B}{*}}
\newcommand{\recbset}{\recchar{B}{A}{*}}

\newcommand{\infer}[2]{\begin{array}{c}{#1}\\\hline{#2}\end{array}}
\newcommand{\inferr}[3]{\begin{array}{c}{#1}\\{#2}\\\hline{#3}\end{array}}

\theoremstyle{definition}

\newtheorem{mydef}{Definition}
\crefname{mydef}{definition}{definitions}

\newtheorem{myax}{Axiom}
\crefname{myax}{axiom}{axioms}

\newtheorem{mylem}{Lemma}
\crefname{mylem}{lemma}{lemmas}

\newtheorem{myth}{Theorem}
\crefname{myth}{theorem}{theorems}

\newtheorem{myrul}{Rule}
\crefname{myrul}{rule}{rules}

\title{A More Complete Algebra for File Synchronization}

\author{Elod Pal Csirmaz}

\begin{document}
\maketitle
\begin{abstract}
Abstract goes here
\end{abstract}

\section{Introduction}

% Synchronization:
% Main aim: apply updates (where possible) from other replicas
% update detection -> conflict detection -> merging updates -> ordering updates -> apply updates from other replicas
% Problems: conflict detection, ordering

\section{Definition of a Filesystem}

We model a filesystem using a function $\FS$ with a set of paths $\setp$ as its domain,
and a set of possible contents $\setv$ as its codomain:
\[ \FS : \setp \rightarrow \setv \] 
In our model, $\setp$ contains all possible paths, and $\setv$ contains a special
element, $\empt$, which is the value of $\FS$ at paths where there are no files
or directories.
We consider the contents of files, as well as any meta-information of files
and directories (e.g. permissions or flags) part of the values in $\setv$.

The paths of a filesystem form a disjoint union of rooted directed trees.
\begin{mydef}
The function $\parent(p)$ returns the parent path of $p$, or
returns $\toppath$ if $p$ is the root of a tree.
\end{mydef}

Every filesystem has a so-called \textbf{tree property}, which means that
if the filesystem is not empty at a path, and the path has a parent,
then there must be a directory at the parent path.

To model this, in $\setv$ we distinguish between files ($\setf$) and directories ($\setd$), that is,
if $\setb = \{\empt\}$ then:
\[ \setv = \setb \cup \setf \cup \setd \]
The tree propety can then be defined as
\[ \forall p\in\setp : \FS(p) \neq \empt \wedge \parent(p) \neq \toppath \Rightarrow \FS(\parent(p)) \in \setd \]

This means that as we move from a path to its child, its grandchild, and so on,
the types of values we encounter in the filesystem can only change according to the following
transition diagram:

\input{type-transition}

In this paper, we write $F$ for an arbitrary element of $\setf$, and $D$ for an arbitrary element
of $\setd$. $V$ is usually a value from $\setv$ and $p$ and $q$ are paths in $\setp$.

\section{Introducing commands}

Next we need to define instructions or commands on the filesystem about which we will reason
using our algebra.
We will aim to draw conclusions or judgements about commands and sequences of commands
based on the algebra we are aiming to construct.
For example, if we believe that two sequences of commands are equivalent as their effect
is the same, then we aim to be able to derive this from the axioms and inference rules of the
algebra.
As the algebra operates on commands only,
these judgements, by definition, need to hold regardless of the filesystem the commands are applied to.
Accordingly, we expect that the more information one encodes into the commands and the sequences,
the better predicitons we will be able to make using our algebra,
as then the commands and sequences will be more specific, and will select a smaller subset
of potential filesystems on which they can meaningfully operate.

Let us consider what kind of information may be encoded in the commands.
A usual set of commands, based on the most frequent tools implemented by filesystems,
might be $create(p,V)$, $edit(p,V)$ and $remove(p)$ where $p\in\setp$ and $V\in\setv$ (but $V\neq\empt$).
Clearly the commands need to contain information about the state they leave the filesystem
in at the path on which they operate, that is, they need to contain their output value, $V$.
Notice, however, that the commands above also encode some information about the filesystem
\emph{before} the command is applied; namely, $create$ requires that there are no files
or directories at $p$, while $edit$ and $remove$ require the opposite.

We also know that after $create$ or $edit$, $\FS(p)\neq\empt$, whereas after $remove$,
$\FS(p)$ will be $\empt$. However, from \cite{NREC:alg} we know that a useful set of axioms
will in some cases need to distinguish between edits that result in directories ($edit(p,D)$) and
ones that result in files ($edit(p,F)$);
and Bill Zissimopoulos suggested in \cite{BZ} that extending this distinction simplifies
definitions based on our algebra, as it is then able to predict the behaviour of commands
more precisely. 
In other words, encoding this information in the commands is definitely useful,
but it creates a seemingly arbitrary asymmetry where
there is more information encoded into commands about their results than about the
original state of the filesystem.

In line with the aim to encode as much information as possible in the commands,
and in order to resolve this asymmetry, we propose a set of commands that encode
the type of the original state of $\FS(p)$ as well.
(Some real-life filesystem commands like $rmdir$ do this already.)
Please note that there is never any need to encode information about the
\emph{exact} value of path $p$ in a command, merely its type ($D$, $F$ or $\empt$),
as the success or failure of filesystem commands only depend on the type of the value.

We therefore propose to have a command for each pair of types.
For want of a better system, we will name our commands by concatenating
two of $\fsregcommandchar{D}$, $\fsregcommandchar{F}$ and $\fsregcommandchar{\empt}$, 
where the left sign notes the type of value
in the filesystem before the command is applied, and the right sign notes the type
afterwards. For example $mkdir(p,D)$ is $\cbd(p,D)$ and $rmdir(p)$ is $\cdb(p)$.

When we describe multiple or unknown commands, we may substitute one or both
types with a variable, e.g. $\cxy(p,V)$. In this context,
if we write that $\cxy=\czw$, we mean that their input and output types
are the same ($X=Z$ and $Y=W$).

% TODO No "move"

% TODO Only one directory value
In real-life applications, we often do not want to consider metadata stored in
directories (\cite{BZ}). In other words, the contents of directories are all equal,
which can be modelled by assuming that $|\setd|=1$.
Note that this creates a convenient symmetry where there is only a single value
for each type that can be repeated as we move from a path to its child ($D$ and $\empt$).

\section{Applying Commands}

The commands can only succeed if the original value at $p$ has a type that matches
the type required by a command. If this is not the case, or if the resulting
filesystem no longer has the tree property, then we say that the command
\textbf{breaks} the filesystem. Broken filesystems are considered equal
(but not equal to any working filesystem), and we note them by $\FS=\fsbroken$.

So that we could reason about sequences of commands that break every filesystem
in the algebra, we introduce the command $\cbrk$ that simply breaks every filesystem.

We note that a command or a sequence of commands is applied to a filsystem
by prefixing the command or sequence to it, for example: $\cbrk\FS$, $\cbd(p,D)\FS$, 
or $S\FS$ if $S$ is a sequence of commands.

\begin{mydef}
Using $\FS\{p\mapsto V\}$ we denote a filesystem derived from $\FS$:
\[ \FS\{p\mapsto V\}(q) :=
   \begin{cases}
   V &\mbox{if~} q=p\\
   \FS(q) &\mbox{otherwise.}
   \end{cases}
\]
\end{mydef}

The exact behaviour of our commands is as follows:
\begin{itemize}
\item $\cbrk\FS = \fsbroken$
\item
All other commands have the generic form $\cxy(p,V_Y)$ where
$X$ and $Y$ are types ($\fsregcommandchar{D}$, $\fsregcommandchar{F}$ or $\fsregcommandchar{\empt}$),
$p\in\setp$ and $V_Y$ is a value of the appropriate type from $\setvx{Y}$.
At times we omit $V_Y$ if there is only one suitable value.
\[ \cxy(p,V_Y)\FS = 
   \begin{cases}
   \fsbroken &\mbox{if~} \FS=\fsbroken\\
   \fsbroken &\mbox{if~} \FS(p)\not\in\setvx{X}\\
   \fsbroken &\mbox{if~} \FS\{p\mapsto V_Y\} \mbox{~violates the tree property}\\
   \FS\{p\mapsto V_Y\} &\mbox{otherwise.}
   \end{cases}
\]
\end{itemize}

\section{Notation and definitions}

\begin{mydef}{$p\descendant q$.}
$p\descendant q$ if $p$ is the ancestor of $q$ ($p=\parent^n(q)$).
\end{mydef}

\begin{mydef}{Assertion command.}
A command is an assertion command if
for every filesystem it either breaks it or leaves it in the same state.
In other words, assertion commands have the same input and output type,
and there must also be only one possible value for their output.
Accordingly in our current algebra $\cbb$ and $\cdd$ are the only two assertion commands.
As $|\setb|=|\setd|=1$, we do not note their exact output value.
\end{mydef}

\begin{mydef}{Minimal set / sequence.}
A sequence or set of commands is minimal if it contains at most one command on every path.
\end{mydef}

\begin{mydef}{Simple set / sequence.}
A sequence or set of commands is simple if it is minimal and it does not contain assertion commands.
\end{mydef}


\section{Defining the Algebra}

In the following sections $A$ and $B$ stand for arbitrary sequences of commands.
The first two relations echo the ones defined in \cite{NREC:alg}.

\begin{mydef}
$A\equiv B$ means that $A$ and $B$ are equivalent.
Its intended interpretation is that they behave in the same way on
all filesystems: $\forall \FS: A\FS=B\FS$.
It is a commutative and transitive relation.
\end{mydef}

\begin{mydef}
$A\eqext B$ means that $B$ extends $A$.
Its intended interpretation is that they behave in the same way
on any filesystem $A$ does not break:
$\forall \FS: A\FS\neq\fsbroken\Rightarrow A\FS=B\FS$
It is a transitive relation.
\end{mydef}

\begin{mydef}
$\works{A_1,A_2,\ldots,A_n}$ means that 
$A_1,A_2,\ldots,A_n$ work at the same time.
Its intended interpretation is
\[\exists \FS: A_1\FS\neq\fsbroken \wedge \cdots \wedge A_n\FS\neq\fsbroken\]
\end{mydef}

\begin{mydef}
$\worksc{A_1,A_2,\ldots,A_n}{B_1,B_2,\ldots,B_n}$ means that 
$A_1,A_2,\ldots,A_n$ work where $B_1,B_2,\ldots,B_n$ work.
Its intended interpretation is
\begin{align*}
\forall \FS:&\\ 
&B_1\FS\neq\fsbroken \wedge \cdots \wedge B_n\FS\neq\fsbroken\\
&\Rightarrow\\
&A_1\FS\neq\fsbroken \wedge \cdots \wedge A_n\FS\neq\fsbroken
\end{align*}
\end{mydef}


We have the following inference rules, in which $A,B,A_i,B_i,S$ and $T$ stand for all possible sequences of commands:

% TODO A=B -> B=A; A=B B=C -> A=C; etc.

\begin{myrul}
\[\infer{A\equiv B}{A\eqext B}\]
\end{myrul}

\begin{myrul}
\[\infer{A\equiv B}{S;A;T\equiv S;B;T}\]
\end{myrul}

\begin{myrul}
\[\infer{A\eqext B}{S;A;T\eqext S;B;T}\]
\end{myrul}

\begin{myrul}
\[\infer{A\eqnrw B}{\worksc{A}{B}}\]
\end{myrul}

\begin{myrul}
\[\infer{\works{A_1,\ldots,A_{n-1},A_n}}{\works{A_1,\ldots,A_{n-1}}}\]
\end{myrul}

\begin{myrul}
\[\infer{\worksc{A_1,\ldots,A_{n-1},A_n}{B_1,\ldots,B_n}}{\worksc{A_1,\ldots,A_{n-1}}{B_1,\ldots,B_n}}\]
\end{myrul}

\begin{myrul}{??? - and vice versa}
\[\infer{\works{A}}{A\nequiv\cbrk}\]
\end{myrul}

\begin{mylem}\label{worksinputmatch}
If $A$ and $B$ are minimal sequences, $\works{A,B}$,
and there are commands on path $p$ in both $A$ ($\cxy(p, V_Y)\in A$) and $B$ ($\czw(p, V_W)\in B$)
then their input types must match ($X=Z$).
TODO: Is this an axiom?
\end{mylem}


We aim to use our algebra to define and implement algorithms for conflict detection
and ordering commands before we can apply them to all replicas.
Conflicts and ordering all happen between commands, therefore in our algebra
we will reason about sequences of commands, 
and do so based on a set of axioms about pairs of neighbouring commands.
We are interested to see which pairs of commands cause errors all the time,
and which can be simplified or reversed
in order to see under what circumstances commands conflict or can be reordered.

Pairs of commands in general will have the form
\[ [\cxy(p,V_Y); \czw(q,V_W)] \]
where $X,Y,Z,W\in\typeset$, $p,q\in\setp$, 
and values are of the appropriate type: 
$V_Y\in\setvx{Y}$ and $V_W\in\setvx{W}$.

The following axioms describe multiple statements
that we accept as true in the algebra.
These statements are generated by substituting 
all possible values for
$X,Y,Z,W\in\typeset$; $p,q\in\setp$; $V_Y\in\setvx{Y}$ and $V_W\in\setvx{W}$
under the conditions noted in the axiom.


\begin{myax}\label{ax_separate_commute}
$\cxy(p,V_Y); \czw(q,V_W) \equiv \czw(q,V_W); \cxy(p,V_Y)$ where $p\not\descendant q$ and $q\not\descendant p$.
\end{myax}

\begin{myax}\label{ax_separate_nobreaks}
$\cxy(p,V_Y); \czw(q,V_W) \nequiv \cbrk$ where $p\not\descendant q$ and $q\not\descendant p$.
\end{myax}

\begin{myax}\label{ax_same_breaks}
$\cxy(p,V_Y); \czw(p,V_W) \equiv \cbrk$ if $Y\ne Z$.
\end{myax}

\begin{myax}\label{ax_distantchild_breaks}
$\cxy(p,V_Y); \czw(q,V_W) \equiv \cbrk$ if $p\descendant q$ and $p\neq\parent(q)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$.
\end{myax}

\begin{myax}\label{ax_distantparent_breaks}
$\cxy(p,V_Y); \czw(q,V_W) \equiv \cbrk$ if $p\ancestor q$ and $\parent(p)\neq q$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$.
\end{myax}

\begin{mydef}{Construction pair.}
A pair of commands on paths $p$ and $q$ is a construction pair if $p=\parent(q)$ and the commands are one
of the following:
   \begin{gather*}
   % bd>bf
            [\cbd(p, D); \cbf(q, F)] \\
   % bd>bd
            [\cbd(p, D_1); \cbd(q, D_2)] \\
   % fd>bf
            [\cfd(p, D); \cbf(q, F)] \\
   % fd>bd
            [\cfd(p, D_1); \cbd(q, D_2)]
   \end{gather*}
\end{mydef}

\begin{mydef}{Destruction pair.}
A pair of commands on paths $p$ and $q$ is a destruction pair if $\parent(p)=q$ and the commands are one
of the following:
   \begin{gather*}
   % fb<db ??
            [\cfb(p); \cdb(\pp)] \\
   % fb<df ??
            [\cfb(p); \cdf(\pp, F)] \\
   % db<db ??
            [\cdb(p); \cdb(\pp)] \\
   % db<df ??
            [\cdb(p); \cdf(\pp, F)]
   \end{gather*}
\end{mydef}

\begin{myax}\label{ax_directchild_breaks}
$\cxy(p,V_Y); \czw(q,V_W) \equiv \cbrk$ if $p=\parent(q)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$
and the pair is not a construction pair.
\end{myax}

\begin{myax}\label{ax_directparent_breaks}
$\cxy(p,V_Y); \czw(q,V_W) \equiv \cbrk$ if $\parent(p)=q$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$
and the pair is not a destruction pair.
\end{myax}

\begin{myax}\label{worksextpostfix}
$\worksc{A}{A;S}$ where $A$ and $S$ are arbitrary sequences of commands
\end{myax}


% Separate:
% * commute
% - if both are BB or DD, extended by empty seq
% - if either is BB or DD, extended by the other command
% - not equiv to break
% Same:
% * equiv break unless 1-out == 2-in
% - extended by empty seq if 1-out==2-in & 1-in==2-out==B,D
% - extended by single command (if 1-out==2-in) (otherwise breaks so true)


\section{Ordering commands}

We often encounter the case where we only have a set of commands without a specified order.
Indeed, it is actually the task of the reconciler to determine whether there is an order
in which updates from multiple replicas can be applied to a filesystem.

If $U$ is a minimal set of commands
that we know can be applied to at least one filesystem in some order without breaking it,
then we can split $U$ into a maximum number of disjunct subsets
(components) so that the paths of two commands from two different subsets are never directly related.
If we aim to order the commands in $U$, then we can allow any permutation of 
the components as the commands in them will commute freely.

Components containing a single command do not pose a problem when determining
possible orders.
(Note that $\cff$ can only appear in a component of one.)

In each component that is larger than one, the paths 
form a rooted ordered tree via the parent--child relationships,
and the pairs connected by edges will be like pairs in the
construction or destruction laws.
To order the commands in a component,
select the command with the topmost path, so that there would be no command
on its parent path (if there is one). 
If the command removes content at this path (it is of the form $\fsregcommand{X}{\empt}$), then it
needs to follow all other commands in the component, and
the component is made of destruction pairs.
Otherwise the command with the topmost component needs to precede other commands
in the component, and it is made of construction pairs.
Move the command with the topmost path in place, and
repeat the process of splitting commands into subsets on the remaining commands
in the component. Recursively, this way we can determine all allowed orders of the commands.

\begin{mydef}{$\orderset{U}$}
We use $\orderset{U}$ to denote the set of sequences that contain all commands in $U$
and represent all orders generated by this algorithm.
By $\ordered{U}$ we mean an arbitrary sequence in the set.
\end{mydef}

As a specific case, we can regard a sequence of commands $S$
as a set and determine its $\orderset{S}$.

\begin{mylem}\label{lemma:neighbour}
If $U$ contains commands on both $p$ and $\pp$, then
there is a $U'\in\orderset{U}$ where they are next to each other.
\end{mylem}

\begin{mydef}
$\extset{S} := \{S'|S\eqext S'\}$
\end{mydef}

\begin{mylem}\label{lemma:minextset}
For any minimal sequence $S$ not equivalent to $\cbrk$, $\extset{S} = \{S'|S\equiv S'\}$.
\end{mylem}
\begin{proof}
This is because as $S$ has at most one command on each path, only equivalence axioms
can be applied to it.
\end{proof}

\begin{mylem}\label{lemma:minextorder}
For any minimal sequence $S$ not equivalent to $\cbrk$,
$\orderset{S} = \extset{S}$.
\end{mylem}

% TODO Can these be derived from the algebra?

\section{Soundness}

\section{Completeness}

\begin{mylem}
\((\forall\FS: S\FS = \empt) \Rightarrow S \equiv \cbrk\)
\end{mylem}

\section{Update detection}

\section{Extending the algebra}

We note the following axioms:

\begin{itemize}
\item Laws for construction assertion:
   \begin{gather*}
            [\cbf(p, F)] \equiv [\cdd(\pp); \cbf(p, F)]\\
            [\cbd(p, D)] \equiv [\cdd(\pp); \cbd(p, D)]
   \end{gather*}
\item Laws for destruction assertion:
   \begin{gather*}
            [\cdb(\pp)] \equiv [\cbb(p); \cdb(\pp)]\\
            [\cdf(\pp, F)] \equiv [\cbb(p); \cdf(\pp, F)]
   \end{gather*}
\end{itemize}

Separately, we extend the algebra with the following judgements and axioms:

\begin{mydef}{$A\coworks B$}
or the domains of $A$ and $B$ overlap.
Its intended interpretation is that
there is at least one filesystem neither $A$ nor $B$ breaks.
It is a commutative (but not transitive) relation.
For $A\ncoworks B$ we say that $A$ and $B$ are disjoint.
\end{mydef}

\begin{mydef}{$A\wrext B$}
or the domain of $B$ extends that of $A$.
Its intended interpretation is that
$B$ does not break any filesystem $A$ does not break.
It is a transitive relation.
\end{mydef}

% TODO See above
\begin{myax}$A\coworks B \Rightarrow A\nequiv\cbrk$\end{myax}
\begin{myax}$A\eqext B \Rightarrow A\wrext B$\end{myax}
\begin{myax}\label{axiom:wrextpostfix}$[A;S] \wrext A$\end{myax}
\begin{myax}$A\coworks B\wrext C \Rightarrow A\coworks C$\end{myax}
\begin{myax}\label{axiom:ncowwrnrw}$A\ncoworks B\wrnrw C \Rightarrow A\ncoworks C$\end{myax}

\begin{mylem}\label{lemma:cowdelfix}$[A;S]\coworks B \Rightarrow A\coworks B$\end{mylem}
\begin{mylem}\label{lemma:ncowpostfix}$A\ncoworks B \Rightarrow [A;S]\ncoworks B$\end{mylem}
\begin{proof}From \cref{axiom:wrextpostfix,axiom:ncowwrnrw}\end{proof}

\begin{mylem}\label{lemma:cowinputmatch}
If $A$ and $B$ are minimal sequences, $A\coworks B$,
and there are commands on path $p$ in both $A$ ($\cxy(p, V_Y)\in A$) and $B$ ($\czw(p, V_W)\in B$)
then their input types must match ($X=Z$).
TODO: Can this be derived from the algebra?
TODO: maybe this is the only thing needed
\end{mylem}

\section{Reconciliation}

If we start with two copies of the filesystem $\FS$,
and two different sequences are applied to the copies to yield $\FS_A:=A\FS$
and $\FS_B:=B\FS$, then our aim is to define sequences of commands $\reca$ and $\recb$
so that $\recb\FS_A$ and $\reca\FS_B$ would be as close to each other as possible.

We work based on the assumption that to achieve this, we need
to apply to $\FS_B$ the commands that have been applied to $\FS_A$, and \emph{vice versa}.
As some commands may have been applied to both filesystems, our first approximation
is $\reca = \ordered{A\setminus B}$ and $\recb = \ordered{B\setminus A}$.
This, however, will break both filesystems if there have been incompatible updates
in $A$ and $B$. 
Our aim is therefore to provide an algorithm that selects the commands 
$\reca = \ordered{\recaset}$  where $\recaset \subset A\setminus B$
and $\recb = \ordered{\recbset}$ where $\recbset \subset B\setminus A$ 
so that $\reca\FS_B\neq\fsbroken$ and $\recb\FS_A\neq\fsbroken$,
and show that these are the longest sequences with this property, that is,
adding any command left out from $\reca$ or $\recb$ will break the filesystems.

We assume that $A$ and $B$ are returned by an update detector,
and so they are simple sequences.
We also assume that $\FS_A$ and $\FS_B$ are not broken and therefore $\works{A,B}$.

Our reconciliation algorithm is as follows.

\begin{mydef}{Reconciliation}\label{def:reconciliation}
\begin{align*}
\recaset = \{c| & \\
& c\in A\setminus B \\
& \wedge \\
& \forall c'\in B\setminus A: [c;c']\equiv[c';c]\\
\} & \\
\reca = \ordered{\recaset}&
\end{align*}

In other words, the sequence $\reca$ we apply to $\FS_B$ consists of all commands from $A\setminus B$
that commute with every command in $B\setminus A$.
\end{mydef}

Now we prove that $\reca\FS_B\neq\fsbroken$, and, in general:

\begin{myth}
If $A, B$ are simple, then $\worksc{[B;\reca]}{A,B}$
\end{myth}

This is trivial unless $\works{A,B}$.

\begin{mylem}
Let $A$ and $B$ be two simple sequences so that $\works{A, B}$.
Then their intersection works on any filesystem
either of them works on:
$\worksc{\ordered{A\cap B}}{A}$, and, by symmetry, for $B$.
\end{mylem}

\begin{proof}
First we prove the following.
Mark all commands in $A$ that also appear in $B$.
Then $\exists A^* \in \orderset{A}$ in which the marked commands are at the beginning.

\medskip

We show $A$ can be transformed via equivalences so that this would be true
by induction on the number of non-marked commands preceding the last marked command.
If it is 0, no transformation is needed.
For the induction step, select the last marked command preceded by a non-marked command.
If the two commute, reverse them, thereby reducing the number on relevant non-marked commands.
If they do not commute, they must be a construction or destruction pair as we know
that $A$ is minimal and $A\nequiv\cbrk$.
Therefore either $q=\parent(p)$ or $p=\parent(q)$.

Let the marked command be $\cxy(p, V_Y)$ and the preceding unmarked command in $A$ be $\czw(q, V_W)$.

If $B$ has a command on $q$, then
from \cref{lemma:neighbour}
we know that there is a $B'$ in $\orderset{B}$ where it is next to $\cxy$,
and from \cref{lemma:minextset,lemma:minextorder} we know that $B'\equiv B$.
From the construction and destruction laws we also know that a command on $q$
must precede $\cxy(p, V_Y)$ just as it does so in $A$.

If $B$ has no command on $q$, then let $B'$ be $B$, but with an extra command added to it just before $\cxy$
according to the construction or destruction assertion laws, from which we know
that $B'\equiv B$.
We also know that $B'$ is still minimal.

We therefore have a minimal $B'$ which has a command on $q$ just before $\cxy(p, V_Y)$ and $B'\equiv B$.
Let this command on $q$ be $\cqr(q, V_R)$.
\begin{gather*}
A = [\cdots; \czw(q, V_W); \cxy(p, V_Y); \cdots] \\
B' = [\cdots; \cqr(q, V_R); \cxy(p, V_Y); \cdots]
\end{gather*}

As $A\coworks B\equiv B'$, 
from \cref{lemma:cowinputmatch}
we know that $Q=Z$. 

Going back to the construction and destruction laws we see that the output type of the first command
is always the same, and it is either $D$ or $\empt$. Therefore $R=W$ and $\cqr(q, V_R)=\czw(q, V_W)$
as $|\setd|=|\setb|=1$. 
If $B$ originally had a command on $q$,
this is a contradiction as $\czw$ was not marked, but we see it must also be in $B'$ and therefore in $B$.
If $B$ had no command on $q$,
this is a contradiction because the command added to $B$ is an assertion command, so $Z=Q=R=W$, 
but $A$ contained no assertion commands.

\medskip

We now know that there is an $A'\equiv A$ in which commands in $A\cap B$
are at the beginning, and therefore 
from \cref{axiom:wrextpostfix}
$A\wrext \ordered{A\cap B}$ and by symmetry $B\wrext \ordered{A\cap B}$.
\end{proof}

\medskip

\begin{mylem}
If $S\coworks T$ and $\forall s\in S, t\in T: [s;t]\equiv[t;s]$
then $[S;T]\coworks S$.
In this case we also know
$\forall \FS: S\FS\neq\fsbroken \wedge T\FS\neq\fsbroken \Rightarrow [S;T]\FS\neq\fsbroken$
(but we can't yet express this in the algebra).
\end{mylem}

\begin{mylem}
$[S;T]\coworks[S;U]\Rightarrow T\coworks U$.
TODO Is this an axiom?
\end{mylem}

Turning back to reconciliation we know
$A\equiv[\ordered{A\cap B};A_0]$
where $A_0=\ordered{A\setminus B}$.
We define $B_0$ similarly.
As $A\coworks B$ we know $A_0\coworks B_0$.

We also know commands in $A_0$ and $\recb$ commute, that is,
$\forall a\in A_0, b\in\recb: [a;b]\equiv[b;a]$.



\begin{thebibliography}{99}

\bibitem{NREC:alg} Ramsey, Norman and Elod Csirmaz: {\it An algebraic approach to
file synchronization...}

\bibitem{BZ} Bill Zissimopoulos, personal communication, ...

\end{thebibliography}

\end{document}
