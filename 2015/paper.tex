\documentclass[12pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{centernot}
\usepackage{tikz}
\usepackage{cleveref}

\newcommand{\setv}{\mathcal{V}} % Set of values
\newcommand{\setvx}[1]{\mathcal{V}_{#1}}
\newcommand{\setf}{\setvx{F}} % Set of file values
\newcommand{\setd}{\setvx{D}} % Set of directory values
\newcommand{\setb}{\setvx{\empt}} % Set of empty values
\newcommand{\setn}{\mathcal{N}} % Set of nodes / paths
\newcommand{\empt}{\bot}
\newcommand{\parent}{\mathtt{parent}}
\newcommand{\topnode}{\mathtt{None}} % return value of parent()
\newcommand{\fsbroken}{\mathtt{Broken}} % broken FS value
\newcommand{\FS}{\Phi} % a filesystem
\newcommand{\GS}{\Xi} % another filesystem
\newcommand{\pp}{p^*} % parent path

\newcommand{\cbrk}{\mathtt{break}}
\newcommand{\fscommand}[2]{{#1#2}}
\newcommand{\fsregcommandchar}[1]{\mathtt{#1}}
\newcommand{\fsregcommand}[2]{\fscommand{\fsregcommandchar{#1}}{\fsregcommandchar{#2}}}
\newcommand{\cbb}{\fsregcommand{\empt}{\empt}}
\newcommand{\cbf}{\fsregcommand{\empt}{F}}
\newcommand{\cbd}{\fsregcommand{\empt}{D}}
\newcommand{\cfb}{\fsregcommand{F}{\empt}}
\newcommand{\cff}{\fsregcommand{F}{F}}
\newcommand{\cfd}{\fsregcommand{F}{D}}
\newcommand{\cdb}{\fsregcommand{D}{\empt}}
\newcommand{\cdf}{\fsregcommand{D}{F}}
\newcommand{\cdd}{\fsregcommand{D}{D}}
\newcommand{\cxy}{\fscommand{X}{Y}}
\newcommand{\cyx}{\fscommand{Y}{X}}
\newcommand{\cyz}{\fscommand{Y}{Z}}
\newcommand{\cxz}{\fscommand{X}{Z}}
\newcommand{\cxw}{\fscommand{X}{W}}
\newcommand{\czw}{\fscommand{Z}{W}}
\newcommand{\cqr}{\fscommand{Q}{R}}
\newcommand{\cqq}{\fscommand{Q}{Q}}

\newcommand{\typeset}{\{\fsregcommandchar{D},\fsregcommandchar{F},\empt\}} % Set of types in commands
\newcommand{\cc}{\circ} % Command / sequence concatenation
\newcommand{\descendant}{\prec}
\newcommand{\ancestor}{\succ}

\newcommand{\eqext}{\sqsubseteq}
\newcommand{\eqnrw}{\sqsupseteq}
\newcommand{\nequiv}{\not\equiv}
\newcommand{\indep}{\wr\!\!\wr\,} % Independent commands, sequences
\newcommand{\unrel}{\indep} % Unrelated nodes

\newcommand{\works}[1]{{\mathbf{w}}({#1})}
\newcommand{\worksc}[2]{{\mathbf{w}}({#1}|{#2})}

\newcommand{\emptyseq}{[\,]} % TODO change

\newcommand{\extset}[1]{\wp({#1})}
\newcommand{\orderset}[1]{\vec{\wp}({#1})}
\newcommand{\ordered}[1]{#1}

\newcommand{\recchar}[3]{{#1}^{#3}_{\mathcal{R}|{#2}}}
\newcommand{\reca}{\recchar{A}{B}{}} % Reconciled from A
\newcommand{\recb}{\recchar{B}{A}{}}
\newcommand{\recaset}{\recchar{A}{B}{*}}
\newcommand{\recbset}{\recchar{B}{A}{*}}

\newcommand{\infer}[2]{\begin{array}{c}{#1}\\\hline{#2}\end{array}}
\newcommand{\inferr}[3]{\begin{array}{c}{#1}\\{#2}\\\hline{#3}\end{array}}
\newcommand{\inferrr}[4]{\begin{array}{c}{#1}\\{#2}\\{#3}\\\hline{#4}\end{array}}

\theoremstyle{definition}

\newtheorem{mydef}{Definition}
\crefname{mydef}{definition}{definitions}

\newtheorem{myax}{Axiom}
\crefname{myax}{axiom}{axioms}
% \creflabelformat{myax}{A#2#1#3}

\newtheorem{mylem}{Lemma}
\crefname{mylem}{lemma}{lemmas}
% \creflabelformat{mylem}{L#2#1#3}

\newtheorem{myth}{Theorem}
\crefname{myth}{theorem}{theorems}

\newtheorem{myrul}{Rule}
\crefname{myrul}{rule}{rules}
% \creflabelformat{myrul}{R#2#1#3}

\title{Correctness of Algebraic File Synchronization}

\author{Elod Pal Csirmaz}

\begin{document}
\maketitle
\begin{abstract}
Abstract goes here
\end{abstract}

\section{Introduction}

Synchronizing data structures, and filesystems in particular,
is a task that we encounter more and more often in our world
of multiple mobile devices, cloud solutions and distributed systems.
Applications of synchronization ranges from
solutions for end users who expect to access personal data seamlessly
on multiple devices and personal clouds to geographically distributed server networks
that need to synchronize themselves with low latency to serve the 
same content.

In this paper we
continue the work in \cite{NREC:alg} and add to the theoretical understanding
of synchronization based not on filesystem states, but filesystem changes or commands.


% Synchronization:
% Main aim: apply updates (where possible) from other replicas
% update detection -> conflict detection -> merging updates -> ordering updates -> apply updates from other replicas
% Problems: conflict detection, ordering

% Insight: (Prof. Norman Ramsey)
% - updates where two orders are not equivalent are incompatible
% - we only have a set of updates and need to create an order

% New:
% better command (instruction) set
% simpler reconciliation algorithm
% proof of correctness

\section{Definition of a Filesystem}

We model a filesystem using a function $\FS$ with a set of nodes (filesystem paths) $\setn$ as its domain,
and a set of possible contents $\setv$ as its codomain:
\[ \FS : \setp \rightarrow \setv \] 
In our model, $\setn$ contains all possible nodes, including the ones where there is no file or directory,
and $\setv$ contains a special element, $\empt$, which is the value of $\FS$ at an empty node.
We consider the contents of files, as well as any meta-information of files
and directories (e.g. permissions or flags) part of the values in $\setv$.

The nodes form a disjoint union of rooted directed trees.
\begin{mydef}
The function $\parent(n)$ returns the parent node of $n$, or
returns $\topnode$ if $n$ is the root of a tree.
\end{mydef}

Every filesystem has a so-called \textbf{tree property}, which means that
if the filesystem is not empty at a node, and the node has a parent,
then there must be a directory at the parent node.

To model this, in $\setv$ we distinguish between files ($\setf$) and directories ($\setd$), that is,
if $\setb = \{\empt\}$ then:
\[ \setv = \setb \cup \setf \cup \setd \]
The tree propety can then be defined as
\[ \forall n\in\setn : \FS(n) \neq \empt \wedge \parent(n) \neq \topnode \Rightarrow \FS(\parent(n)) \in \setd \]

This means that as we move down from the root of a tree of nodes,
the types of values we encounter in the filesystem can only change according to the following
transition diagram:

\input{type-transition}

In this paper, we write $F$ for an arbitrary element of $\setf$, and $D$ for an arbitrary element
of $\setd$. $V$ is a value from $\setv$ and $n$ and $m$ are nodes in $\setn$.






\section{Introducing commands}

Next we need to define commands on the filesystem.

% <<<<<<<< TODO Rewrite: no algebra
 about which we will reason
using our algebra.
We will aim to draw conclusions or judgements about commands and sequences of commands
based on the algebra we are aiming to construct.
For example, if we believe that two sequences of commands are equivalent as their effect
is the same, then we aim to be able to derive this from the axioms and inference rules of the
algebra.
As the algebra operates on commands only,
these judgements, by definition, need to hold regardless of the filesystem the commands are applied to.
Accordingly, we expect that the more information one encodes into the commands and the sequences,
the better predicitons we will be able to make using our algebra,
as then the commands and sequences will be more specific, and will select a smaller subset
of potential filesystems on which they can meaningfully operate.
% >>>>>>>>>> to here


Let us consider what kind of information may be encoded in the commands.
A usual set of commands, based on the most frequent tools implemented by filesystems,
might be $create(n,V)$, $edit(n,V)$ and $remove(n)$ where $n\in\setn$ and $V\in\setv$ (but $V\neq\empt$).
Regarding what we know of their output, that is, the state of the filesystem at $n$
after applying the command,
we know that after $create$ or $edit$, $\FS(n)\neq\empt$, whereas after $remove$,
$\FS(n)$ will be $\empt$. 
However, from \cite{NREC:alg} we know that a useful set of axioms
will in some cases need to distinguish between edits that result in directories ($edit(n,D)$) and
ones that result in files ($edit(n,F)$), and treat them as separate commands.
Indeed, Bill Zissimopoulos suggested (\cite{BZ}) that extending this distinction to more commands
utlimately simplifies
the definition of conflicting commands, as our model will then able to predict the behavior of commands
more precisely.
In other words, encoding the type of the output ($D$, $F$ or $\empt$) in the commands is definitely useful.
At the same time, there is never any need to encode information about the
\emph{exact} output value of a command,
as the success or failure of filesystem commands only depend on the types of values in the filesystem.

Notice, however, that the commands listed above also encode some information about 
their input, the filesystem
\emph{before} the command is applied; namely, $create(n,V)$ requires that there are no files
or directories at $n$, while $edit(n,V)$ and $remove(n)$ require the opposite.
This creates an arbitrary asymmetry where
there is now more information encoded into commands about their output than about their input.
In line with the aim to encode as much information as possible in the commands, % TODO Where is this mentioned?
and in order to resolve this asymmetry, we propose a set of commands that encode
the type of the original state of $\FS(n)$ as well.
(Some real-life filesystem commands like $rmdir$ do this already.)

We therefore propose to have a command for each pair of types.
For want of a better system, we will name our commands by concatenating
two of $\fsregcommandchar{D}$, $\fsregcommandchar{F}$ and $\fsregcommandchar{\empt}$, 
where the left sign denotes the type of value
required in the filesystem before the command is applied, and the right sign notes the type
afterwards. For example, $mkdir(n,D)$ will be $\cbd(n,D)$, and $rmdir(n)$ will be $\cdb(n)$.

A command can only succeeds if the original value at node $n$ has a type that matches
the input type of the command. If this is not the case, or if the resulting
filesystem no longer has the tree property, then we say that the command
\textbf{breaks} the filesystem. Broken filesystems are considered equal
(but not equal to any working filesystem), and we note them by $\FS=\fsbroken$.

So that we could reason about sequences of commands that break every filesystem
in the algebra, we introduce the command $\cbrk$ that simply breaks every filesystem.

We note that a command or a sequence of commands is applied to a filsystem
by prefixing the command or sequence to it, for example: $\cbrk\FS$, $\cbd(n,D)\FS$, 
or $S\FS$ if $S$ is a sequence of commands.

\begin{mydef}
Using $\FS[V/n]$ we denote a filesystem derived from $\FS$:
\[ \FS[V/n](m) :=
   \begin{cases}
   V &\mbox{if~} m=n\\
   \FS(m) &\mbox{otherwise.}
   \end{cases}
\]
\end{mydef}

The exact behavior of our commands is as follows:
\begin{itemize}
\item $\cbrk\FS = \fsbroken$
\item
All other commands have the generic form $\cxy(n,V_Y)$ where
$X$ and $Y$ are types in $\typeset$,
$n\in\setn$ and $V_Y$ is a value of the appropriate type from $\setvx{Y}$.
At times we omit $V_Y$ if there is only one suitable value.
\[ \cxy(n,V_Y)\FS = 
   \begin{cases}
   \fsbroken &\mbox{if~} \FS=\fsbroken\\
   \fsbroken &\mbox{if~} \FS(n)\not\in\setvx{X}\\
   \fsbroken &\mbox{if~} \FS[V/n] \mbox{~violates the tree property}\\
   \FS[V/n] &\mbox{otherwise.}
   \end{cases}
\]
\end{itemize}


When we describe multiple or unknown commands, we may substitute one or both
types with a variable, for example by writing $\cxy(n,V)$. In this context,
if we write that $\cxy=\czw$, we mean that their input and output types
are the same ($X=Z$ and $Y=W$).

% Simplifications
% ---------------

For reasons also listed in \cite{NREC:alg}, in this paper we will not consider
a $move$ or $rename$ command. Regarding the theoretical reasoning we aim to follow,
this turns out to be useful because these would be the only commands that affect
filesystems at two nodes at once, therefore describing 
the dependencies affecting these commands
would call for a more complicated model.
From a pragmatic perspective, this restriction does not mean that in an application
implementing conflict resolution using the algorithm described here would not be
able to handle renames by pre- and post-processing changes in the filesystem to
discover them, which (especially when a rename is combined with changes to the content)
is a non-trivial problem in itself.

Another simplification we will assume in this paper is regarding directories.
As Bill Zissimopoulos pointed out (\cite{BZ}), we often do not want to consider metadata stored in
directories during synchronization. In other words, the contents of directories are all equal,
which can be modelled by assuming that $|\setd|=1$.
% This also creates a convenient symmetry where there is only a single value
% for each type that can be repeated as we move from a path to its child ($D$ and $\empt$).




\section{Describing the behavior of commands}

% Definitions for command pairs and ordering
% ------------------------------------------

So that we could describe the effects of commands on a filesystem, let us introduce some notation
and note some observations.

The commands we aim to investigate do not occur in isolation:
for example, when comparing to filesystems to determine the commands needed to transform one into the other,
we receive a set of commands with uncertain ordering.
Applying commands to a filesystem, however, happens in time,
so for this we need a sequence of commands.
We use $\cc$ to concatenate commands to form a sequence, or concatenate sequences to form a longer sequence:
$S=\cbd(n)\cc \cbf(m,F)$, or $S'=S\cc\cbb(o)$.

The following concepts will allow us to investigate sequences independently of filesystems.
In the definitions, $A,B,S,T$ stand for arbitrary sequences of commands.
The first two relations echo the ones defined in \cite{NREC:alg}.

\begin{mydef}
% Relation in the algebra
$A\equiv B$ means that $A$ and $B$ are equivalent,
% intended interpretation:
that is, they behave in the same way on
all filesystems: $\forall \FS: A\FS=B\FS$.
It is a reflexive, commutative and transitive relation,
and clearly
% inference rule:
$ A\equiv B \Rightarrow S\cc A\cc T\equiv S\cc B\cc T $.
\end{mydef}

\begin{mydef}
% Relation in the algebra
$A\eqext B$ means that $B$ extends $A$,
% intended interpretation:
that is, they behave in the same way
on any filesystem $A$ does not break:
$\forall \FS: A\FS\neq\fsbroken\Rightarrow A\FS=B\FS$.
It is a reflexive and transitive relation,
and we can see that
% inference rules:
$ A\eqext B \Rightarrow S\cc A\cc T\eqext S\cc B\cc T$
and
$ A\equiv B \Rightarrow A\eqext B$.
\end{mydef}

Let us also define the following relations between nodes:

\begin{mydef}{$n\descendant m$.}
We write $n\descendant m$ if $n$ is the ancestor of $m$ ($n=\parent^n(m)$). % TODO (the transitive closure of the $\parent$ relation)
\end{mydef}

\begin{mydef}{$n\unrel m$.}
We write $n\unrel m$, or ``$n$ and $m$ are unrelated'' if $n\not\descendant m$ and $n\not\ancestor m$
and $n\new m$.
\end{mydef}


% Command pairs - Axioms
% ----------------------

\section{Investigating command pairs}

Our aim is to derive information about the effects of sequences
of commands independently of that actual filesystems.
In order to make this possible, we investigate the smallest building
blocks of sequences: pairs of commands that act on a filesystem directly one after the other.
This approach is useful as there are a limited number of command pairs,
because, as we arguad above, we can disregard the exact output value of commands apart from its type,
and we can also abstract the relationship between the nodes in the two commands
to a finite number of cases.

We methodically investigated of all possibilities using a computer program
to determine
which pairs of commands cause errors all the time,
which can be simplified to one or no commands, and which can be reversed
without any change in their overall effect.
% TODO: Footnote: URL
Our basis for this investigation was the model of filesystems introduced in this paper.
These properties of command pairs are crucial as they determine
how a set of commands can be re-ordered to be applied to a filesystem
during synchronization, and what commands will never be compatible.

Below we list a number of statements derived using this method.
Although they can be proven by investigating all relevant possibilities
in a filesystem, we refer to these in axioms because in a secondary algebraic model
that describes commands without reference to an underlying filesystem,
these would function as meta-rules generating statements we would accept as true.
See section (TODO) for more about such a model.

\medskip

Pairs of commands in general have the form
\[ \cxy(n,V_Y)\cc  \czw(m,V_W) \]
where $X,Y,Z,W\in\typeset$, $n,m\in\setn$, 
and values are of the appropriate type: 
$V_Y\in\setvx{Y}$ and $V_W\in\setvx{W}$.

\begin{myax}\label{ax_separate_commute}
Commands on unrelated nodes commute:
$\cxy(n,V_Y)\cc  \czw(m,V_W) \equiv \czw(m,V_W)\cc \cxy(n,V_Y)$ where $n\unrel m$.
\end{myax}

\begin{myax}\label{ax_separate_nobreaks}
Commands on unrelated nodes do not break every filesystem:
$\cxy(n,V_Y)\cc  \czw(m,V_W) \nequiv \cbrk$ where $n\unrel m$.
\end{myax}

\begin{myax}\label{ax_same_breaks}
Commands on the same node break every filesystem if their types are incompatible:
$\cxy(n,V_Y)\cc \czw(n,V_W) \equiv \cbrk$ where $Y\ne Z$.
\end{myax}

\begin{myax}\label{ax_same_emptyseq}
Commands on the same node simplify:
$\cxy(n,V_Y)\cc \czw(n,V_W) \eqext \emptyseq$ where $Y=Z$ and $X=W=\fsregcommandchar{\empt}$ or $X=W=\fsregcommandchar{D}$.
\end{myax}

\begin{myax}\label{ax_same_singlec}
Commands on the same node simplify:
$\cxy(n,V_Y)\cc  \czw(n,V_W) \equiv \cxw(n,V_W)$ where $Y=Z$ and $XW\neq\cbb$ and $XW\neq\cdd$.
\end{myax}

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\begin{myax}\label{ax_distantchild_breaks}
$\cxy(\pp,V_Y)\cc  \czw(p,V_W) \equiv \cbrk$ where $\pp\descendant p$ and $\pp\neq\parent(p)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$.
\end{myax}

\begin{myax}\label{ax_distantparent_breaks}
$\cxy(p,V_Y)\cc  \czw(\pp,V_W) \equiv \cbrk$ where $p\ancestor \pp$ and $\parent(p)\neq \pp$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$.
TODO merge into previous
\end{myax}

\begin{mydef}{Construction pair.}
A pair of commands on paths $\pp$ and $p$ is a construction pair if $\pp=\parent(p)$ and the commands are one
of the following:
   \begin{gather*}
   % bd>bf
            [\cbd(\pp, D)\cc  \cbf(p, F)] \\
   % bd>bd
            [\cbd(\pp, D_1)\cc  \cbd(p, D_2)] \\
   % fd>bf
            [\cfd(\pp, D)\cc  \cbf(p, F)] \\
   % fd>bd
            [\cfd(\pp, D_1)\cc  \cbd(p, D_2)]
   \end{gather*}
\end{mydef}

\begin{mydef}{Destruction pair.}
A pair of commands on paths $p$ and $\pp$ is a destruction pair if $\parent(p)=\pp$ and the commands are one
of the following:
   \begin{gather*}
   % fb<db ??
            [\cfb(p)\cc  \cdb(\pp)] \\
   % fb<df ??
            [\cfb(p)\cc  \cdf(\pp, F)] \\
   % db<db ??
            [\cdb(p)\cc  \cdb(\pp)] \\
   % db<df ??
            [\cdb(p)\cc  \cdf(\pp, F)]
   \end{gather*}
\end{mydef}

\begin{myax}\label{ax_directchild_breaks}
$\cxy(\pp,V_Y)\cc  \czw(p,V_W) \equiv \cbrk$ where $\pp=\parent(p)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$
and the pair is not a construction pair.
\end{myax}

\begin{myax}\label{ax_directparent_breaks}
$\cxy(p,V_Y)\cc  \czw(\pp,V_W) \equiv \cbrk$ where $\parent(p)=\pp$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$
and the pair is not a destruction pair.
\end{myax}

\begin{myax}\label{ax_child_assert}
An assertion command can be added on a child path:
$\cbb(p)\cc \cxy(\pp,V_Y) \equiv \cxy(\pp,V_Y) \equiv \cxy(\pp,V_Y)\cc \cbb(p)$ where $\pp\descendant p$ and $\cxy\neq\cdd$.
\end{myax}

\begin{myax}\label{ax_parent_assert}
An assertion command can be added on the parent path:
$\cdd(\pp)\cc \cxy(p,V_Y) \equiv \cxy(p,V_Y) \equiv \cxy(p,V_Y)\cc \cdd(\pp)$ where $\pp\descendant p$ and $\cxy\neq\cbb$.
\end{myax}










\begin{mydef}{Inverse commands and sequences.}
The inverse of command $\cxy(p,V_Y)$ is $\cxy(p,V_Y)^{-1} = \cyx(p,V_X)$
where $V_X$ is an arbitrary value from $\setvx{X}$.
The inverse of sequence $S$, $S^{-1}$, consists of the inverses of the commands in $S$
in reverse order.
\end{mydef}

\begin{mylem}\label{r_invmove}
\[ \infer{\worksc{S\cc A}{B}}{\worksc{A}{S^{-1}\cc B}} \]
To see the soundness of this rule...
Sequences are bijections on filesystems over type-equality.
TODO: $A,S,B$ need to be simple?
\end{mylem}

\begin{mydef}{Assertion command.}
A command is an assertion command if
for every filesystem it either breaks it or leaves it in the same state.
In other words, assertion commands have the same input and output type,
and there must also be only one possible value for their output.
Accordingly, in our current algebra, $\cbb(n)$ and $\cdd(n)$ are the only two assertion commands,
and we do not note their output value as it is determined.
\end{mydef}

\begin{mydef}{Minimal set or sequence.}
A sequence or set of commands is minimal if it contains at most one command on every node.
\end{mydef}

\begin{mydef}{Simple set or sequence.}
A sequence or set of commands is simple if it is minimal and it does not contain assertion commands.
\end{mydef}


\begin{mydef}{Independent commands, sequences and sets.}
For two commands $\cxy$ and $\czw$ we write $\cxy\indep\czw$ if $\cxy\cc \czw\equiv\czw\cc \cxy\nequiv\cbrk$.
% TODO use w() instead of nequiv break
For two sequences or sets of commands $A$ and $B$ we write $A\indep B$ if
$\forall a\in A \mbox{and~} \forall b\in B: a\indep b$.
\end{mydef}

\begin{myrul}\label{r_indep_combine}
\[ \inferrr{\worksc{T}{S}}{\worksc{U}{S}}{T\indep U}{\worksc{T\cc U}{S}} \]
To see the soundness of this rule...
\end{myrul}

\begin{mylem}\label{indep_prefix_combine}
\[ \inferrr{\worksc{A\cc B}{S}}{\worksc{A\cc C}{S}}{B\indep C}{\worksc{A\cc B\cc C}{S}} \]
\end{mylem}
\begin{proof}
From \cref{r_invmove,r_indep_combine}
TODO reverse of \cref{r_invmove} needed
\end{proof}








\begin{myax}\label{ax_assert}
$\cxy(p,V_Y) \eqext \emptyseq$ where $\cxy=\cbb$ or $\cxy=\cdd$.
\end{myax}

\begin{myax}\label{worksextpostfix}
$\worksc{A}{A\cc S}$ where $A$ and $S$ are arbitrary sequences of commands
\end{myax}





\section{Ordering commands}

We often encounter the case where we only have a set of commands without a specified order.
Indeed, it is actually the task of the reconciler to determine whether there is an order
in which updates from multiple replicas can be applied to a filesystem.

If $U$ is a minimal set of commands
that we know can be applied to at least one filesystem in some order without breaking it,
then we can split $U$ into a maximum number of disjunct subsets
(components) so that the paths of two commands from two different subsets are never directly related.
If we aim to order the commands in $U$, then we can allow any permutation of 
the components as the commands in them will commute freely.

Components containing a single command do not pose a problem when determining
possible orders.
(Note that $\cff$ can only appear in a component of one.)

In each component that is larger than one, the paths 
form a rooted ordered tree via the parent--child relationships,
and the pairs connected by edges will be like pairs in the
construction or destruction laws.
To order the commands in a component,
select the command with the topmost path, so that there would be no command
on its parent path (if there is one). 
If the command removes content at this path (it is of the form $\fsregcommand{X}{\empt}$), then it
needs to follow all other commands in the component, and
the component is made of destruction pairs.
Otherwise the command with the topmost component needs to precede other commands
in the component, and it is made of construction pairs.
Move the command with the topmost path in place, and
repeat the process of splitting commands into subsets on the remaining commands
in the component. Recursively, this way we can determine all allowed orders of the commands.

\begin{mydef}{$\orderset{U}$}
We use $\orderset{U}$ to denote the set of sequences that contain all commands in $U$
and represent all orders generated by this algorithm.
By $\ordered{U}$ we mean an arbitrary sequence in the set.
\end{mydef}

As a specific case, we can regard a sequence of commands $S$
as a set and determine its $\orderset{S}$.

\begin{mylem}\label{lemma:neighbour}
If $U$ contains commands on both $p$ and $\pp$, then
there is a $U'\in\orderset{U}$ where they are next to each other.
\end{mylem}

\begin{mydef}
$\extset{S} := \{S'|S\eqext S'\}$
\end{mydef}

\begin{mylem}\label{lemma:minextset}
For any minimal sequence $S$ not equivalent to $\cbrk$, $\extset{S} = \{S'|S\equiv S'\}$.
\end{mylem}
\begin{proof}
This is because as $S$ has at most one command on each path, only equivalence axioms
can be applied to it.
\end{proof}

\begin{mylem}\label{lemma:minextorder}
For any minimal sequence $S$ not equivalent to $\cbrk$,
$\orderset{S} = \extset{S}$.
\end{mylem}

% TODO Can these be derived from the algebra?

\section{Soundness}

\section{Completeness}

\begin{mylem}
\((\forall\FS: S\FS = \empt) \Rightarrow S \equiv \cbrk\)
\end{mylem}

\section{Update detection}

\section{Reconciliation}

If we start with two copies of the filesystem $\FS$,
and two different sequences are applied to the copies to yield $\FS_A:=A\FS$
and $\FS_B:=B\FS$, then our aim is to define sequences of commands $\reca$ and $\recb$
so that $\recb\FS_A$ and $\reca\FS_B$ would be as close to each other as possible.

We work based on the assumption that to achieve this, we need
to apply to $\FS_B$ the commands that have been applied to $\FS_A$, and \emph{vice versa}.
As some commands may have been applied to both filesystems, our first approximation
is $\reca = \ordered{A\setminus B}$ and $\recb = \ordered{B\setminus A}$.
This, however, will break both filesystems if there have been incompatible updates
in $A$ and $B$. 
Our aim is therefore to provide an algorithm that selects the commands 
$\reca = \ordered{\recaset}$  where $\recaset \subset A\setminus B$
and $\recb = \ordered{\recbset}$ where $\recbset \subset B\setminus A$ 
so that $\reca\FS_B\neq\fsbroken$ and $\recb\FS_A\neq\fsbroken$,
and show that these are the longest sequences with this property, that is,
adding any command left out from $\reca$ or $\recb$ will break the filesystems.

We assume that $A$ and $B$ are returned by an update detector,
and so they are simple sequences.
We also assume that $\FS_A$ and $\FS_B$ are not broken and therefore $\works{A,B}$.

Our reconciliation algorithm is as follows.

\begin{mydef}{Reconciliation}\label{def:reconciliation}
\begin{align*}
\recaset = \{c| & \\
& c\in A\setminus B \\
& \wedge \\
& \forall c'\in B\setminus A: c\indep c'\\
\} & \\
\reca = \ordered{\recaset}&
\end{align*}

In other words, the sequence $\reca$ we apply to $\FS_B$ consists of all commands from $A\setminus B$
that independent from every command in $B\setminus A$.
\end{mydef}

Now we prove that $\reca\FS_B\neq\fsbroken$, and, in general:








% Introducing 'works'
% -------------------

So that we can formalise statements (TODO) needed to prove this,
let us introduce two relations that describe under what conditions
sequences of commands work, that is, do not break a filesystem.

\begin{mydef}
% Unsure if this relation should be in the algebra.
For a set of $k$ sequences
$\works{A_1,A_2,\ldots,A_k}$ means that 
$A_1,A_2,\ldots,A_k$ work at the same time, that is,
% intended interpretation:
\[\exists \FS: A_1\FS\neq\fsbroken \wedge \cdots \wedge A_k\FS\neq\fsbroken\]
As the sequences form a set, their order is irrelevant.
% inference rules:
We also see that $\works{A} \Leftrightarrow A\nequiv \cbrk$. 
\end{mydef}

\begin{mydef}
For two sets of sequences, $\worksc{A_1,A_2,\ldots,A_k}{B_1,B_2,\ldots,B_l}$ means that 
all of $A_1,A_2,\ldots,A_k$ work where all of $B_1,B_2,\ldots,B_l$ work,
that is,
% intended interpretation:
\begin{align*}
\forall \FS:&\\ 
&B_1\FS\neq\fsbroken \wedge \cdots \wedge B_k\FS\neq\fsbroken\\
&\Rightarrow\\
&A_1\FS\neq\fsbroken \wedge \cdots \wedge A_l\FS\neq\fsbroken
\end{align*}
As above, the order of the sequences in the sets is not relevant.
% inference rules:
It is easy to see that 
% $\worksc{X}{X}$ is always true for any set of sequences $X$,
$B\eqext A \Rightarrow \worksc{A}{B}$
and that this relation can be chained:
$ \worksc{A_1,\ldots,A_k}{B_1,\ldots,B_l} \wedge \worksc{C_1,\ldots,C_j}{A_1} \Rightarrow \worksc{A_1,\ldots,A_k,C_1,\ldots,C_j}{B_1,\ldots,B_l} $
\end{mydef}

\begin{mylem}\label{worksinputmatch}
If $A$ and $B$ are minimal sequences, $\works{A,B}$,
and there are commands on node $n$ in both $A$ ($\cxy(n, V_Y)\in A$) and $B$ ($\czw(n, V_W)\in B$)
then their input types must match ($X=Z$).
\end{mylem}
\begin{proof}
This is easily shown using an indirect proof: if $X\neq Z$, then there is no filesystem that
$\cxy(n, V_Y)$ or $\czw(n, V_W)$ would not break, and consequently $A$ and $B$ could not work on the same filesystem.
\end{proof}













\begin{myth}
If $A, B$ are simple, then $\worksc{B\cc \reca}{A,B}$
\end{myth}

This is trivial unless $\works{A,B}$.

\begin{mylem}
Let $A$ and $B$ be two simple sequences so that $\works{A, B}$.
Then their intersection works on any filesystem
either of them works on:
$\worksc{\ordered{A\cap B}}{A}$, and, by symmetry, for $B$.
\end{mylem}

\begin{proof}
First we prove the following.
Mark all commands in $A$ that also appear in $B$.
Then there is an $A'$ in $\orderset{A}$ in which the marked commands are at the beginning.

\medskip

TODO: unmarked-marked can be reversed -- but induction is wrong

We show $A$ can be transformed via equivalences so that this would be true,
by induction on the number of non-marked commands preceding the last marked command.
If it is 0, no transformation is needed.
For the induction step, consider the last marked command preceded by a non-marked command,
and the non-marked command itself.
As $A$ is a simple command and $\works{A}$, from 
\cref{ax_distantchild_breaks,ax_distantparent_breaks,ax_directchild_breaks,ax_directparent_breaks}
we know that these commands can only be on unrelated paths or form a construction or destruction pair.
In the first case, swapping the commands results in a sequence equivalent to $A$,
with the number on relevant non-marked commands reduced by one.
In the last two cases,
either $q=\parent(p)$ or $p=\parent(q)$.

Let the marked command be $\cxy(p, V_Y)$ and the preceding unmarked command in $A$ be $\czw(q, V_W)$.

If $B$ has a command on $q$, then
from \cref{lemma:neighbour}
we know that there is a $B'$ in $\orderset{B}$ where it is next to $\cxy$,
and from \cref{lemma:minextset,lemma:minextorder} we know that $B'\equiv B$.
% TODO Use when describing ordering:
Considering the eight construction and destruction pairs we see that the command
on the parent path determines which group the pair belongs to.
This in turn determines whether the command on the child path must
precede or follow the other command as otherwise the sequence would break all filesystems.
This argument holds for both $A$ and $B$, and so the command on $q$ must be on
the same side of the command on $p$ in both sequences.

If $B$ has no command on $q$, then let $B'$ be $B$, but with an extra command added to it just before $\cxy$
according to \cref{ax_child_assert,ax_parent_assert}, from which we know
that $B'\equiv B$.
We also know that $B'$ is still minimal (but no longer simple).

We therefore have a minimal $B'$ which has a command on $q$ just before $\cxy(p, V_Y)$ and $B'\equiv B$.
Let this command on $q$ be $\cqr(q, V_R)$.
\begin{gather*}
A = \cdots\cc  \czw(q, V_W)\cc  \cxy(p, V_Y)\cc  \cdots \\
B' = \cdots\cc  \cqr(q, V_R)\cc  \cxy(p, V_Y)\cc  \cdots
\end{gather*}

As $\works{A,B}$ and so $\works{A,B'}$ (via \cref{r_eq_ex,r_ex_w,r_w_w}), 
from \cref{worksinputmatch}
we know that $Q=Z$. 

Going back to the construction and destruction pairs we see that the output type of the first command
is always the same, and it is either $D$ or $\empt$ depending on the relationship between $p$ and $q$.
Therefore $R=W$ and $\cqr(q, V_R)=\czw(q, V_W)$
as $|\setd|=|\setb|=1$. 
If $B$ originally had a command on $q$,
this is a contradiction as $\czw$ was not marked, but we see it must also be in $B'$ and therefore in $B$.
If $B$ had no command on $q$,
this is a contradiction because the command on $q$ in $B'$ is an assertion command, so $Z=Q=R=W$, 
but $A$ contained no assertion commands.

\medskip

We now know that there is an $A'\equiv A$ in which commands in $A\cap B$
are at the beginning, and therefore 
from \cref{worksextpostfix}
$\worksc{\ordered{A\cap B}}{A}$ and by symmetry $\worksc{\ordered{A\cap B}}{B}$.
\end{proof}

\medskip

We would like to prove that $\worksc{B\cc \reca}{A,B}$.
From above we know that this is equivalent to
$\worksc{\ordered{A\cap B}\cc \ordered{B\setminus A}\cc \reca}{A,B}$.
As we already know that $\reca\indep B\setminus A$
and that $\worksc{\ordered{A\cap B}\cc \ordered{B\setminus A}}{A,B}$
(as $\worksc{B}{A,B}$),
based on \cref{indep_prefix_combine}
we only need to prove that
$\worksc{\ordered{A\cap B}\cc \reca}{A,B}$.

\newcommand{\acbi}{\ordered{A\cap B}^{-1}}
\newcommand{\amb}{A\setminus B}
\newcommand{\bma}{B\setminus A}
Using \cref{r_invmove} we can rephrase this as
% TODO axiom doesn't specify multiple conditions
$\worksc{\reca}{\acbi\cc A,\acbi\cc B}$.

We already know the following things:
\begin{itemize}
\item $\amb$ and $\bma$ are simple as $A$ and $B$ are simple
% \item $\amb \cap \bma = \emptyset$
\item $\reca$ is the largest subset of $\amb$ for which $\reca\indep\amb$
\item $\worksc{\ordered{\amb}\cc \ordered{\bma}}{\acbi\cc A,\acbi\cc B}$ as $\worksc{A,B}{A,B}$ based on \cref{r_invmove}
\end{itemize}

Our theorem is therefore proven if we prove the following lemma:

\begin{mylem}
If
   \begin{itemize}
   \item \newcommand{\condSimple}{(1)} \condSimple $S$ and $T$ are simple sequences
   % \item \newcommand{\condDisj}{(4)} \condDisj $S\cap T=\emptyset$
   \item \newcommand{\condApr}{(2)} \condApr $S^*$ is the largest subset of $S$ where $S^*\indep T$
   \item \newcommand{\condWork}{(3)} \condWork $\worksc{S,T}{C_1,\ldots,C_n}$
   \end{itemize}
then
\[ \worksc{S^*}{C_1,\ldots,C_n} \]
\end{mylem}

\begin{proof}
% TODO Refer back to conditions!
This is trivial unless $\works{C_1,\ldots,C_n}$, so we will assume that it is true
and therefore $\works{S,T}$.
% TODO This probably needs an axiom

Similarly to above, we prove that $S$ can be transformed into $S'$ by equivalences
so that all commands in $S^*$ would be at its beginning.
If so then based on \cref{worksextpostfix}
$\worksc{S^*}{C_1,\ldots,C_n}$ as $\worksc{S'}{C_1,\ldots,C_n}$.

Also similarly to above,
we proceed by induction on the number of commands in $S$ that are not in $S^*$, but which precede
the last command in $S$ that is also in $S^*$.
If the number is 0, the lemma is true.
Otherwise let the last command in $S$ also in $S^*$ be $\cxy(p,V_Y)$
and the preceding command in $S$ be $\czw(q,V_W)$.

As $S$ is simple and $\works{S}$, from 
\cref{ax_distantchild_breaks,ax_distantparent_breaks,ax_directchild_breaks,ax_directparent_breaks}
we know that these commands can only be on unrelated paths or form a construction or destruction pair.
In the first case, swapping the commands results in a sequence equivalent to $S$,
with the number on relevant commands not in $S^*$ reduced by one.
In the last two cases,
either $q=\parent(p)$ or $p=\parent(q)$.

We also know that there must be a command $\cqr(r,V_R)$ in $T$ which is not independent of $\czw(q,V_W)$.
By definition this means that one of the following must be true:
\begin{itemize}
\item $\czw(q,V_W)\cc \cqr(r,V_R) \equiv\cbrk$
\item $\cqr(r,V_R)\cc \czw(q,V_W) \equiv\cbrk$
\item $\czw(q,V_W)\cc \cqr(r,V_R) \nequiv \cqr(r,V_R)\cc \czw(q,V_W)$
\end{itemize}
From these and \cref{ax_separate_commute,ax_separate_nobreaks} we also know that
either $q\descendant r$ or $r\descendant q$.
By definition we also know that $\cxy(p,V_Y)\indep \cqr(r,V_R)$,
and the same argument shows that therefore
$p\not\descendant r$ and $r\not\descendant p$ and $p\neq r$. TODO CHECK

We therefore have four cases considering the relationships between $p,q$ and $r$:
\begin{itemize}
\item $p=\parent(q) \wedge r\descendant q$.
   This would mean that $r\descendant p$ or $r=p$, which is a contradiction.
\item $p=\parent(q) \wedge q\descendant r$.
   This would mean that $p\descendant r$, which is a contradiction.
\item $q=\parent(p) \wedge r\descendant q$.
   This would mean that $r\descendant p$, which is a contradiction.  
\item $q=\parent(p) \wedge q\descendant r$.
   Let us continue with this case.
\end{itemize}

We know that $T$ cannot have a command on $q$ as $q=\parent(p)$ and $\cxy(p,V_Y)\indep T$.
Create $T'\equiv T$ by inserting a command on $q$ before $\cqr(r,V_R)$
into $T$ according to \cref{ax_parent_assert}.
We now have $\cxy(p,V_Y)\indep T\equiv T'$ which is a contradiction as
$T'$ has a command on $q$ and $q=\parent(p)$.

\end{proof}

% TODO $\reca$ is maximal

% TODO Talk about setting up an algebra / calculus

\begin{thebibliography}{99}

\bibitem{NREC:alg} Ramsey, Norman and Elod Csirmaz: {\it An algebraic approach to
file synchronization...}

\bibitem{BZ} Bill Zissimopoulos, personal communication, ...

\end{thebibliography}

\end{document}
