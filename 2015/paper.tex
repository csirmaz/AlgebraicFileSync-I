\documentclass[12pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{centernot}
\usepackage{tikz}
\usepackage{cleveref}

\newcommand{\setv}{\mathcal{V}} % Set of values
\newcommand{\setvx}[1]{\mathcal{V}_{#1}} % Set of values with custom index
\newcommand{\setf}{\setvx{F}} % Set of file values
\newcommand{\setd}{\setvx{D}} % Set of directory values
\newcommand{\setb}{\setvx{\empt}} % Set of empty values
\newcommand{\setn}{\mathcal{N}} % Set of nodes / paths
\newcommand{\empt}{\bot}
\newcommand{\parent}{\mathtt{parent}}
\newcommand{\topnode}{\mathtt{None}} % return value of parent()
\newcommand{\fsbroken}{\mathtt{Broken}} % broken FS value
\newcommand{\FS}{\Phi} % a filesystem
\newcommand{\GS}{\Xi} % another filesystem
\newcommand{\nn}{n^*} % parent node

\newcommand{\cbrk}{\mathtt{break}} % 'break' command
\newcommand{\ccharb}{\empt}
\newcommand{\ccharf}{\mathtt{F}}
\newcommand{\cchard}{\mathtt{D}}
\newcommand{\vald}{d} % Directory value
\newcommand{\valdi}{d_1}
\newcommand{\valdii}{d_2}
\newcommand{\valf}{f} % File value
\newcommand{\valvx}{v_X} % Value of type X
\newcommand{\valvy}{v_Y} % Value of type Y
\newcommand{\valvw}{v_W}
\newcommand{\valvr}{v_R}
\newcommand{\typeset}{\{\cchard,\ccharf,\ccharb\}} % Set of types in commands
\newcommand{\caa}[2]{\langle{#1,#2}\rangle}
\newcommand{\caaa}[3]{\langle{#1,#2,#3}\rangle}
\newcommand{\caaaa}[4]{\langle{#1,#2,#3,#4}\rangle}
\newcommand{\cbb}{\caa{\ccharb}{\ccharb}}
\newcommand{\cbba}[1]{\caaa{\ccharb}{\ccharb}{#1}}
\newcommand{\cbf}{\caa{\ccharb}{\ccharf}}
\newcommand{\cbfaa}[2]{\caaaa{\ccharb}{\ccharf}{#1}{#2}}
\newcommand{\cbd}{\caa{\ccharb}{\cchard}}
\newcommand{\cbdaa}[2]{\caaaa{\ccharb}{\cchard}{#1}{#2}}
\newcommand{\cfb}{\caa{\ccharf}{\ccharb}}
\newcommand{\cfba}[1]{\caaa{\ccharf}{\ccharb}{#1}}
\newcommand{\cff}{\caa{\ccharf}{\ccharf}}
\newcommand{\cfd}{\caa{\ccharf}{\cchard}}
\newcommand{\cfdaa}[2]{\caaaa{\ccharf}{\cchard}{#1}{#2}}
\newcommand{\cdb}{\caa{\cchard}{\ccharb}}
\newcommand{\cdba}[1]{\caaa{\cchard}{\ccharb}{#1}}
\newcommand{\cdf}{\caa{\cchard}{\ccharf}}
\newcommand{\cdfaa}[2]{\caaaa{\cchard}{\ccharf}{#1}{#2}}
\newcommand{\cdd}{\caa{\cchard}{\cchard}}
\newcommand{\cdda}[1]{\caaa{\cchard}{\cchard}{#1}}
\newcommand{\cxy}{\caa{X}{Y}}
\newcommand{\cxyaa}[2]{\caaaa{X}{Y}{#1}{#2}}
\newcommand{\cxynv}{\caaaa{X}{Y}{n}{\valvy}}
\newcommand{\cxynnv}{\caaaa{X}{Y}{\nn}{\valvy}}
\newcommand{\cxw}{\caa{X}{W}}
\newcommand{\cxwnv}{\caaaa{X}{W}{n}{\valvw}}
\newcommand{\czw}{\caa{Z}{W}}
\newcommand{\czwnv}{\caaaa{Z}{W}{n}{\valvw}}
\newcommand{\czwnnv}{\caaaa{Z}{W}{\nn}{\valvw}}
\newcommand{\czwmv}{\caaaa{Z}{W}{m}{\valvw}}
\newcommand{\cqr}{\caa{Q}{R}}
\newcommand{\cqrmv}{\caaaa{Q}{R}{m}{\valvr}}
\newcommand{\cqrov}{\caaaa{Q}{R}{o}{\valvr}}

\newcommand{\cc}{\circ} % Command / sequence concatenation
\newcommand{\descendant}{\prec}
\newcommand{\descendantEq}{\preceq}
\newcommand{\ancestor}{\succ}
\newcommand{\ancestorEq}{\succeq}

\newcommand{\eqext}{\sqsubseteq} % equivalent to
\newcommand{\eqnrw}{\sqsupseteq} % extended by
\newcommand{\nequiv}{\not\equiv}
\newcommand{\indep}{\mathrel{\wr\wr}} % Independent commands, sequences
\newcommand{\unrel}{\indep} % Unrelated nodes
\newcommand{\nindep}{\,{\centernot{\wr\wr}}\,} % not \indep
\newcommand{\nunrel}{\nindep} % not \unrel

\newcommand{\workssign}{\mathbf{w}}
\newcommand{\works}[1]{\workssign({#1})}
\newcommand{\worksc}[2]{\workssign({#1}\mathrel{|}{#2})}

\newcommand{\typeeq}{\stackrel{t}{=}}
\newcommand{\ntypeeq}{\centernot{\stackrel{t}{=}}}

\newcommand{\emptyseq}{\lambda} % empty sequence

\newcommand{\orderset}[1]{\vec{\wp}({#1})}
\newcommand{\seqset}[1]{\underline{#1}} % Set of sequences

\newcommand{\recchar}[3]{{#1}^{#3}_{\mathcal{R}|{#2}}}
\newcommand{\reca}{\recchar{A}{B}{}} % Reconciled from A
\newcommand{\recb}{\recchar{B}{A}{}} % Reconciled from B

\theoremstyle{definition}

\newtheorem{mydef}{Definition}
\crefname{mydef}{definition}{definitions}

\newtheorem{myax}{Axiom}
\crefname{myax}{axiom}{axioms}

\newtheorem{mylem}{Lemma}
\crefname{mylem}{lemma}{lemmas}

\newtheorem{myth}{Theorem}
\crefname{myth}{theorem}{theorems}

\newtheorem{mycor}{Corollary}
\crefname{mycor}{corollary}{corollaries}


\title{The Correctness of Algebraic File Synchronization}

\author{Elod Pal Csirmaz}

\begin{document}
\maketitle
\begin{abstract}
Abstract goes here
\end{abstract}

\section{Introduction}

Synchronizing data structures, and filesystems in particular,
is a task that we encounter more and more often in our world
of multiple mobile devices, cloud solutions and distributed systems.
Applications of synchronization ranges from
solutions for end users who expect to access personal data seamlessly
on multiple devices and personal clouds to geographically distributed server networks
that need to synchronize themselves with low latency to serve the 
same content.

In this paper we
continue the work in \cite{NREC:alg} and add to the theoretical understanding
of synchronization based not on filesystem states, but filesystem changes or commands.


% Synchronization:
% Main aim: apply updates (where possible) from other replicas
% update detection -> conflict detection -> merging updates -> ordering updates -> apply updates from other replicas
% Problems: conflict detection, ordering

% ORDERING - because when taking updates from different replicas we get an essentially unordered set
% Insight: (Prof. Norman Ramsey)
% - updates where two orders (AB vs BA) are not equivalent are incompatible
% - we only have a set of updates and need to create an order

% New:
% better command (instruction) set
% simpler reconciliation algorithm
% proof of correctness

\section{Definition of a Filesystem}

We model a filesystem using a function $\FS$ with a set of nodes (filesystem paths) $\setn$ as its domain,
and a set of possible contents $\setv$ as its codomain:
\[ \FS : \setn \rightarrow \setv \] 
In our model, $\setn$ contains all possible nodes, including the ones where there is no file or directory,
and $\setv$ contains a special element, $\empt$, which is the value of $\FS$ at an empty node.
We consider the contents of files, as well as any meta-information of files
and directories (e.g. permissions or flags) part of the values in $\setv$.

The nodes form a disjoint union of rooted directed trees.
\begin{mydef}
The function $\parent(n)$ returns the parent node of $n$, or
returns $\topnode$ if $n$ is the root of a tree.
\end{mydef}

Every filesystem has a so-called \textbf{tree property}, which means that
if the filesystem is not empty at a node, and the node has a parent,
then there must be a directory at the parent node.

To model this, in $\setv$ we distinguish between files ($\setf$) and directories ($\setd$), that is,
if $\setb = \{\empt\}$ then:
\[ \setv = \setb \cup \setf \cup \setd \]
The tree propety can then be defined as
\begin{align*}
\forall n\in\setn: &\FS(n) \neq \empt \\ % TODO alignment problem
&\quad\wedge \parent(n) \neq \topnode \\
&\Rightarrow \FS(\parent(n)) \in \setd 
\end{align*}
This means that as we move down from the root of a tree of nodes,
the types of values we encounter in the filesystem can only change according to the following
transition diagram:

\input{type-transition}

In this paper, we write $\valf$ for an arbitrary element of $\setf$, and $\vald$ for an arbitrary element
of $\setd$. $TODO$ is a value from $\setv$ and $n$ and $m$ are nodes in $\setn$.






\section{Introducing commands}

Next we need to define commands on the filesystem.

% <<<<<<<< TODO Rewrite: no algebra
%  about which we will reason
% using our algebra.
% We will aim to draw conclusions or judgements about commands and sequences of commands
% based on the algebra we are aiming to construct.
% For example, if we believe that two sequences of commands are equivalent as their effect
% is the same, then we aim to be able to derive this from the axioms and inference rules of the
% algebra.
% As the algebra operates on commands only,
% these judgements, by definition, need to hold regardless of the filesystem the commands are applied to.
% Accordingly, we expect that the more information one encodes into the commands and the sequences,
% the better predicitons we will be able to make using our algebra,
% as then the commands and sequences will be more specific, and will select a smaller subset
% of potential filesystems on which they can meaningfully operate.
% >>>>>>>>>> to here

...

Let us consider what kind of information may be encoded in the commands.
A usual set of commands, based on the most frequent tools implemented by filesystems,
might be $create(n,V)$, $edit(n,V)$ and $remove(n)$ where $n\in\setn$ and $V\in\setv$ (but $V\neq\empt$).
Regarding their output, that is, the state of the filesystem at $n$
after applying the command,
we know that after $create$ or $edit$, $\FS(n)\neq\empt$, whereas after $remove$,
$\FS(n)$ will be $\empt$. 
However, from \cite{NREC:alg} we know that a useful set of axioms
will in some cases need to distinguish between edits that result in directories ($edit(n,D)$) and
ones that result in files ($edit(n,F)$), and treat them as separate commands.
Indeed, Bill Zissimopoulos suggested (\cite{BZ}) that extending this distinction to more commands
utlimately simplifies
the definition of conflicting commands, as our model will then able to predict the behavior of commands
more precisely.
In other words, encoding the type of the output ($D$, $F$ or $\empt$) in the commands is definitely useful.
At the same time, there is never any need to encode information about the
\emph{exact} output value of a command,
as the success or failure of filesystem commands only depend on the types of values in the filesystem.

Notice, however, that the commands listed above also encode some information about 
their input, the filesystem
\emph{before} the command is applied; namely, $create(n,V)$ requires that there are no files
or directories at $n$, while $edit(n,V)$ and $remove(n)$ require the opposite.
This creates an arbitrary asymmetry where
there is now more information encoded into commands about their output than about their input.
In line with the aim to encode as much information as possible in the commands, % TODO Where is this mentioned?
and in order to resolve this asymmetry, we propose a set of commands that encode
the type of the original state of $\FS(n)$ as well.
(Some real-life filesystem commands like $rmdir$ do this already.)

% TODO: tuple / quadruple
We therefore propose to have a command for each pair of types.
For want of a better system, we will name our commands by concatenating
two of $\cchard$, $\ccharf$ and $\ccharb$, 
where the left sign denotes the type of value
required in the filesystem before the command is applied, and the right sign notes the type
afterwards. For example, $mkdir(n,D)$ is $\cbdaa{n}{D}$, and $rmdir(n)$ is $\cdba{n}$.

A command can only succeed if the original value at node $n$ has a type that matches
the input type of the command. If this is not the case, or if the resulting
filesystem no longer has the tree property, then we say that the command
{\em breaks} the filesystem. Broken filesystems are considered equal
(but not equal to any working filesystem), and we note them by $\FS=\fsbroken$.

So that we could reason about sequences of commands that break every filesystem
in the algebra, we introduce the command $\cbrk$ that simply breaks every filesystem.

We note that a command or a sequence of commands is applied to a filsystem
by prefixing the command or sequence to it, for example: $\cbrk\FS$, $\cbdaa{n}{\vald}\FS$, 
or $S\FS$ if $S$ is a sequence of commands.

\begin{mydef}
Using $\FS[V/n]$ we denote a filesystem derived from $\FS$:
\[ \FS[V/n](m) :=
   \begin{cases}
   V &\mbox{if~} m=n\\
   \FS(m) &\mbox{otherwise.}
   \end{cases}
\]
\end{mydef}

The exact behavior of our commands is as follows:
\begin{itemize}
\item $\cbrk\FS = \fsbroken$
\item
All other commands have the generic form $\cxynv$ where
$X$ and $Y$ are types in $\typeset$,
$n\in\setn$ and $\valvy$ is a value of the appropriate type from $\setvx{Y}$.
At times we omit $\valvy$ if there is only one suitable value.
\[ \cxynv\FS = 
   \begin{cases}
   \fsbroken &\mbox{if~} \FS=\fsbroken\\
   \fsbroken &\mbox{if~} \FS(n)\not\in\setvx{X}\\
   \fsbroken &\mbox{if~} \FS[V/n] \mbox{~violates the tree property}\\
   \FS[V/n] &\mbox{otherwise.}
   \end{cases}
\]
\end{itemize}


In general, when we describe multiple or unknown commands, we may substitute one or both
of their types with variables, as we did with $\cxynv$. In this context,
if we write that $\cxy=\czw$, we mean that the input and output types % TODO needed?
of the commands are the same ($X=Z$ and $Y=W$), while a full equiality 
($\cxynv=\czwmv$)
implies
that their output value is also the same.

% Simplifications
% ---------------

For reasons also listed in \cite{NREC:alg}, in this paper we will not consider
a $move$ or $rename$ command. Regarding the theoretical reasoning we aim to follow,
this turns out to be useful because these would be the only commands that affect
filesystems at two nodes at once, therefore describing 
the dependencies affecting these commands
would call for a more complicated model.
From a pragmatic perspective, this restriction does not mean that in an application
implementing conflict resolution using the algorithm described here would not be
able to handle renames by pre- and post-processing changes in the filesystem to
discover them, which (especially when a rename is combined with changes to the content)
is a non-trivial problem in itself.

Another simplification we will assume in this paper is regarding directories.
As Bill Zissimopoulos pointed out (\cite{BZ}), we often do not want to consider metadata stored in
directories during synchronization. In other words, the contents of directories are all equal,
which can be modelled by assuming that $|\setd|=1$.
% This also creates a convenient symmetry where there is only a single value
% for each type that can be repeated as we move from a path to its child ($D$ and $\empt$).




\section{Describing the behavior of commands}

% Definitions for command pairs and ordering
% ------------------------------------------

So that we could describe the effects of commands on a filesystem, let us introduce some notation
and note some observations.

The commands we aim to investigate do not occur in isolation:
for example, when comparing filesystems to determine the commands needed to transform one into the other,
we receive a set of commands with uncertain ordering.
Applying commands to a filesystem, however, happens in time,
so for this we need a sequence of commands.
We use $\cc$ to concatenate commands to form a sequence, or concatenate sequences to form a longer sequence:
$S=\cbdaa{n}{\vald}\cc\cbfaa{m}{\valf}$, or $S'=S\cc\cbba{o}$.
We write $\emptyseq$ for the empty sequence.

TODO: Sequences of commands, in the usual way,  form a free
semigroup

The following concepts allow us to investigate sequences independently of filesystems.
In the definitions, $A,B,S,T$ stand for arbitrary sequences of commands.
These relations echo the ones defined in \cite{NREC:alg}.

\begin{mydef}
% Relation in the algebra
$A\equiv B$ means that $A$ and $B$ are equivalent,
% intended interpretation:
that is, they behave in the same way on
all filesystems: $\forall \FS: A\FS=B\FS$.
It is a reflexive, commutative and transitive relation,
and clearly
% inference rule:
$ A\equiv B \Rightarrow S\cc A\cc T\equiv S\cc B\cc T $.
\end{mydef}

\begin{mydef}
% Relation in the algebra
$A\eqext B$ means that $B$ extends $A$,
% intended interpretation:
that is, they behave in the same way
on any filesystem $A$ does not break:
$\forall \FS: A\FS\neq\fsbroken\Rightarrow A\FS=B\FS$.
It is a reflexive and transitive relation,
and we can see that
% inference rules:
$ A\eqext B \Rightarrow S\cc A\cc T\eqext S\cc B\cc T$
and
$ A\equiv B \Rightarrow A\eqext B$.
\end{mydef}

Let us also define the following relations between nodes:

\begin{mydef}{$n\descendant m$.}
We write $n\descendant m$ if $n$ is the ancestor of $m$ ($n=\parent^n(m)$). % TODO (the transitive closure of the $\parent$ relation)
We write $n\descendantEq m$ if $n\descendant m$ or $n=m$.
\end{mydef}

\begin{mydef}{$n\unrel m$.}
We write $n\unrel m$, or ``$n$ and $m$ are unrelated'' if $n\not\descendantEq m$ and $n\not\ancestorEq m$.
\end{mydef}


% Command pairs - Axioms
% ----------------------

\section{Investigating command pairs}

Our aim is to derive information about the effects of sequences
of commands independently of that actual filesystems.
In order to make this possible, we investigate the smallest building
blocks of sequences: pairs of commands that act on a filesystem directly one after the other.
This approach is useful as there are a limited number of command pairs,
because, as we argued above, we can disregard the exact output values of commands apart from their type,
and we can also abstract the relationship between the nodes in the two commands
to a finite number of cases.

We methodically investigated of all possibilities using a computer program
to determine
which pairs of commands cause errors all the time,
which can be simplified to one or no commands, and which can be reversed
without any change in their overall effect.
% TODO: Footnote: URL
Our basis for this investigation was the model of filesystems introduced in this paper.
These properties of command pairs are crucial as they determine
how a set of commands can be re-ordered to be applied to a filesystem
during synchronization, and what commands will never be compatible.

Below we list a number of statements derived using this method.
Although they can be proven by investigating all relevant possibilities
in a filesystem, we refer to these as axioms because in a secondary algebraic model
that describes commands without reference to an underlying filesystem,
these would function as meta-rules generating statements we would accept as true.
See section (TODO) for more about such a model.

\medskip

Pairs of commands in general have the form
\[ \cxynv\cc  \czwmv \]
where $X,Y,Z,W\in\typeset$, $n,m\in\setn$, 
and values are of the appropriate type: 
$\valvy\in\setvx{Y}$ and $\valvw\in\setvx{W}$.

\begin{myax}\label{ax_separate_commute}
Commands on unrelated nodes commute:
$\cxynv\cc\czwmv \equiv \czwmv\cc\cxynv$ where $n\unrel m$.
\end{myax}

\begin{myax}\label{ax_separate_nobreaks}
Commands on unrelated nodes do not break every filesystem:
$\cxynv\cc\czwmv \nequiv \cbrk$ where $n\unrel m$.
\end{myax}

\begin{myax}\label{ax_same_breaks}
Commands on the same node break every filesystem if their types are incompatible:
$\cxynv\cc\czwnv \equiv \cbrk$ where $Y\ne Z$.
\end{myax}

\begin{myax}\label{ax_same_emptyseq}
Commands on the same node simplify:
$\cxynv\cc\czwnv \eqext \emptyseq$ where $Y=Z$ and $X=W=\ccharb$ 
or $X=W=\cchard$.
\end{myax}

\begin{myax}\label{ax_same_singlec}
Commands on the same node simplify:
$\cxynv\cc \czwnv \equiv \cxwnv$ where $Y=Z$ and $\cxw\neq\cbb$ and $\cxw\neq\cdd$.
\end{myax}

\begin{myax}\label{ax_distantrel_breaks}
Commands on distant relatives break all filesystems:
$\cxynnv\cc\czwnv \equiv \cbrk$
and $\czwnv\cc\cxynnv \equiv\cbrk$
where $\nn\descendant n$ and $\nn\neq\parent(n)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$.
\end{myax}

\begin{mydef}{Construction pair.}
A pair of commands on nodes $\nn$ and $n$ is a construction pair if $\nn=\parent(n)$ 
and the commands are one
of the following:
   \begin{gather*}
   % bd>bf
            \cbdaa{\nn}{\vald}\cc  \cbfaa{n}{\valf} \\
   % bd>bd
            \cbdaa{\nn}{\valdi}\cc  \cbdaa{n}{\valdii} \\
   % fd>bf
            \cfdaa{\nn}{\vald}\cc  \cbfaa{n}{\valf} \\
   % fd>bd
            \cfdaa{\nn}{\valdi}\cc  \cbdaa{n}{\valdii}
   \end{gather*}
\end{mydef}

\begin{myax}\label{ax_directchild_breaks}
All other commands on a child break every filesystem:
$\cxynnv\cc\czwnv \equiv \cbrk$ where $\nn=\parent(n)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$
and the pair is not a construction pair.
\end{myax}

\begin{mydef}{Destruction pair.}
A pair of commands on nodes $n$ and $\nn$ is a destruction pair if $\parent(n)=\nn$ and the commands are one
of the following:
   \begin{gather*}
   % fb<db ??
            \cfba{n}\cc  \cdba{\nn} \\
   % fb<df ??
            \cfba{n}\cc  \cdfaa{\nn}{\valf} \\
   % db<db ??
            \cdba{n}\cc  \cdba{\nn} \\
   % db<df ??
            \cdba{n}\cc  \cdfaa{\nn}{\valf}
   \end{gather*}
\end{mydef}

\begin{myax}\label{ax_directparent_breaks}
All other commands on a parent break every filsystem:
$\cxynv\cc\czwnnv \equiv \cbrk$ where $\parent(n)=\nn$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$
and the pair is not a destruction pair.
\end{myax}

\begin{mydef}{Assertion command.}
A command is an assertion command if
for every filesystem it either breaks it or leaves it in the same state.
In other words, assertion commands have the same input and output type,
and there must also be only one possible value for their output.
Accordingly, in our current algebra, $\cbba{n}$ and $\cdda{n}$ are the only two assertion commands,
and we do not note their output value as it is determined.
\end{mydef}

\begin{myax}\label{ax_child_assert}
An assertion command can be added on a descendant node:
$\cbba{n}\cc\cxynnv \equiv \cxynnv \equiv \cxynnv\cc\cbba{n}$ 
where $\nn\descendant n$ and $\cxy\neq\cdd$.
\end{myax}

\begin{myax}\label{ax_parent_assert}
An assertion command can be added on an ancestor node:
$\cdda{\nn}\cc\cxynv \equiv \cxynv \equiv \cxynv\cc\cdda{\nn}$ 
where $\nn\descendant n$ and $\cxy\neq\cbb$.
\end{myax}

\begin{myax}\label{ax_assert}
Assertion commands can be removed:
$\cxynv \eqext \emptyseq$ where $\cxy=\cbb$ or $\cxy=\cdd$.
\end{myax}


% Update detection
% ----------------

\section{Update detection}

In a command-based reconciliation solution we assume that we have two sequences of commands
$A$ and $B$ that have modified a single filesystem $\FS$ yielding two different replicas $\FS_A$ and $\FS_B$ that we
need to reconcile. While it is conceivable that the sequences would be based on a record of
all operations that modified the two filesystems, in most filesystem implementations
such records are not implemented, and therefore we must construct suitable sequences
by comparing $\FS_A$ and $\FS_B$ to their common ancestor, $\FS$. This is called update detection.

A sequence that transforms $\FS$ into $\FS_A$ must contain at least one command on each node
that changes between the two states of the filesystem. Also, it is easy to see that this is also
sufficient, as there are commands available for any input and output value. 
Specifically, if at node $n$, $\FS(n)=X'$ and $\FS_A(n)=Y'\neq X'$, then we add the command $\cxyaa{n}{Y'}$ to $A$
where $X'\in\setvx{X}$ and $Y'\in\setvx{Y}$.

To be able to describe such sequences better, let us introduce the following properties:

\begin{mydef}{Minimal set or sequence.}
A sequence or set of commands is minimal if it contains at most one command on every node.
\end{mydef}

\begin{mydef}{Simple set or sequence.}
A sequence or set of commands is simple if it is minimal and it does not contain assertion commands.
\end{mydef}

This update detector therefore yields a simple set of commands because we only add a single command
for each node, and we only add commands that are necessary, that is, there will be no 
assertion commands in the set.

The next step in generating the sequences is to order the commands collected.
As this task is at the heart of reconciliation itself independently of update detection,
we discuss it in the next section.
Then, in \cref{update_works}, we prove that the resulting sequence actually
works without breaking the filesystem.


% Ordering commands
% ----------------

\section{Ordering commands}\label{ordering}

We often encounter the case where we only have a set of commands without a specified order.
As we have seen above, this can occur after the first stage of update detection,
but, more importantly,
it is actually the task of the reconciler to determine whether there is an order,
and if yes, what order,
in which updates from multiple replicas can be applied to a filesystem.

In this section we describe an algorithm with which all possible orderings of a
simple set of commands can be generated, but before doing so, let us consider the following lemma.

\begin{mylem}\label{connected_changes}
Given a set of commands that
does not contain assertion commands,
and which can be applied to a filesystem in some order without breaking it,
and which contains commands on $n$ and $\nn$ where $\nn\descendant n$
but $\nn\neq\parent(n)$, then the set must also contain a commands
on each node between $n$ and $\nn$.
\end{mylem}
\begin{proof}
We prove that under the given conditions, the set must contain a command on $\parent(n)$.
Then, by repeating this statement, we how that the set must contain commands on every
ancestor of $n$ up to $\nn$.

Furthermore,
we prove this proposition for sequences, not sets, as if all sequences must contain a command on $\parent(n)$,
then so must sets because otherwise there would be no order in which they can be
applied to any filesystem.

Let $A$ be a sequence that satisfies the conditions;
we therefore know that it contains a command $\cxynv$ on $n$
and another command $\czwnnv$ on $\nn$.
We use an indirect proof and assume that there are no commands on $\parent(n)$ in $A$.
Next, we create a new sequence $A'\equiv A$ in which $\cxy$ and $\czw$ are next to each other.
If they are already next to each other in $A$, there is nothing to do.
Otherwise, consider the command next to $\cxynv$ in the direction where $\czwnnv$ is.
Let this command be $\cqrmv$.
If $\czw$ is to the right, then $A$ looks like the following:
\[ A = \cdots\cc\cxynv\cc\cqrmv\cc\cdots\cc\czwnnv\cc\cdots \]
If $n\unrel m$, swap $\cxynv$ and $\cqrmv$. Based on \cref{ax_separate_commute} we know that the new
sequence is equivalent to $A$.
Otherwise, we know $m\neq\parent(n)$ as there are no commands on $\parent(n)$, and so
from \cref{ax_distantrel_breaks} we get $A\equiv\cbrk$ which contradicts our assumptions.
(Note that $A$ cannot contains assertion commands.)
By repeating this step we can therefore convert $A$ into $A'$ where $\cxynv$ and $\czwnnv$ are neighboring commands.
However, then \cref{ax_distantrel_breaks} applies to the sequence and therefore $A\equiv A'\equiv\cbrk$ which
is again a contradiction.
\end{proof}

\medskip

We can now define our algorithm to generate orders of sets of commands.

Let $U$ be a simple set of commands
that we know can be applied to at least one filesystem in some order without breaking it.
Then we can split $U$ into a maximum number of disjunct subsets
(components) so that the nodes of two commands from two different subsets are unrelated.
These will simply be the components of the subset of the node forest that contains the nodes affected by the set.

From \cref{ax_separate_commute} we know that commands from different 
components can be applied in any order.
Therefore once we have ordered the commands inside a component, we generate
all permutations of the components themselves, including the ones
in which commands from separate components mix and overlap
(but where the possible orders determined for commands inside the components are respected).

Next, consider the ordering inside a component.

This is not a problem in the case of components containing a single command only.
(Note that $\cff$ can only appear in a component of one.)

In each component that is larger than one, 
we know that all nodes are related, and from \cref{connected_changes}
we also know that it must contain commands on all nodes in between.
Therefore the nodes
form a rooted ordered tree,
and the pairs of commands connected by the edges in the tree 
must be construction or destruction pairs.
(Otherwise, there would be no ordering of the component that is not equivalent to $\cbrk$
and via \cref{ax_separate_commute} there would be no ordering of the whole set, either.)

To order the commands in the component,
select the command with the topmost node, so that there would be no command
on its parent node (if there is one). 
If the command removes content at this node (it is of the form $X\empt$), 
then it must follow all other commands in the component, and
all parent--child pairs in the whole component must be destruction pairs.
Otherwise, the command with the topmost node needs to precede the other commands,
and the component must be made of construction pairs.
These follow from the patterns of construction and destruction pairs, which
at no point can mix without causing any sequence to break all filesystems.

Then move the command with the topmost node to the beginning or the end of
the sequence we are creating out of the component,
and recursively start the whole algorithm again on the commands in the component that remain,
potentially splitting them into sub-components.
The result of this process is a set of possible orders for each component,
which are then combined into a set of possible orders for the whole set of commands.

\begin{mydef}{$\orderset{U}$.}
We use $\orderset{U}$ to denote the set of sequences that contain all commands in
the simple set $U$
and represent all orders generated by this algorithm.
\end{mydef}

It follows from the algorithm that:
\begin{mycor}\label{lemma:neighbor}
If $U$ contains commands on both $n$ and $\parent(n)$, then
there is a $U'\in\orderset{U}$ where they are next to each other.
\end{mycor}

As a specific case, we can regard a sequence of commands $S$
as a set and determine its $\orderset{S}$.
An important property of simple sequences is that
all of their valid orderings are equivalent,
and all equivalent sequences are mere reorderings:

\begin{mylem}\label{simple_reorder_equiv}
For any simple sequence $S\neq\cbrk$,
$\forall T: T\equiv S \Leftrightarrow T\in\orderset{S}$.
\end{mylem}
\begin{proof}
TODO
\end{proof}

It follows from this that given a simple set,
we can simply assume that it has an order.
Accordingly, we will at times treat not only sequences as sets,
but simple sets as sequences.


\medskip

% Correctness of update detection
% -------------------------------

Based on \cref{connected_changes} we can also show that
the update detector does function as intended as:

\begin{myth}\label{update_works}
A sequence of commands returned by the update detector
when comparing $\FS^*$ to the original $\FS$
will not break $\FS$ if it is applied to it.
\end{myth}
\begin{proof}
Let $\FS\neq\fsbroken$ be the original filesystem, and $\FS^*\neq\fsbroken$
be the filesystem after the changes we intend to detect.
Let us assume that some mechanism recorded all changes that occurred
to $\FS$ until it reached the state $\FS^*$.
Our set if commands is sufficient to record any change, as
there are commands for every input and output type pair, therefore
we know that the changes can be recorded as a sequence of commands $S$
where $S\FS=\FS^*$.
Note that $S$ will not contain assertion commands, as they do not
represent an actual change in the filesystem.

Therefore, \cref{connected_changes} applies to $S$ and we know
if it contains commands on $\nn$ and $n$ where $\nn\descendant n$,
then it also contains commands on nodes in between;
which is equivalent to saying that if $\FS$ changed
at node $\nn$ and $n$, then it had to change on the nodes in between.

If so, then, similarly to what happens in the ordering algorithm,
we can separate $S$ into components of commands on related nodes,
as commands from separate components freely commute yielding an equivalent sequence.
From the arguments above, we also know that each component
must be made up of only desctruction or only construction pairs,
but not a mixture of the two.
This means that in each component, parents either strictly precede or succeed child nodes
(as otherwise $S\equiv\cbrk$ would hold),
from which it follows that once the components are separated
in a new sequence $S'\equiv S$,
commands on the same nodes are next to each other in $S'$.

Based on \cref{ax_same_emptyseq,ax_same_singlec} there is
an $S''\eqnrw S'$ in which multiple commands on the same nodes
are simplified into a single command or an empty sequence,
and therefore $S''$ is simple and $S\equiv S'\eqext S''$.
It is easy to see that $S''$ must contain the same commands
as the output of the update detector, $U$, as both are simple
but reflect all changes between $\FS$ and $\FS^*$.
If so, then based on \cref{simple_reorder_equiv}
we have $S''\in\orderset{U}$, from which
$S\equiv S'\eqext S''\equiv U$, and as $S\FS = \FS^* \neq \fsbroken$,
therefore $U\FS\neq\fsbroken$.
\end{proof}

\section{Reconciliation}

If we start with two copies of the filesystem $\FS$,
and two different sequences are applied to the copies to yield $\FS_A:=A\FS$
and $\FS_B:=B\FS$, then our aim is to define sequences of commands $\reca$ and $\recb$
so that $\recb\FS_A$ and $\reca\FS_B$ would be as close to each other as possible.

We work based on the assumption that to achieve this, we need
to apply to $\FS_B$ the commands that have been applied to $\FS_A$, and \emph{vice versa}.
As some commands may have been applied to both filesystems, our first approximation
is $\reca = A\setminus B$ and $\recb = B\setminus A$
(in some suitable order).
This, however, will break both filesystems if there have been incompatible updates
in $A$ and $B$. 
Our aim is therefore to provide an algorithm that selects the commands 
$\reca \subset A\setminus B$
and $\recb \subset B\setminus A$ 
so that $\reca\FS_B\neq\fsbroken$ and $\recb\FS_A\neq\fsbroken$,
and show that these are the longest sequences with this property, that is,
adding any command left out from $\reca$ or $\recb$ will break the filesystems.

We assume that $A$ and $B$ are returned by an update detector,
and so they are simple sequences.
(Otherwise, they can be simplified to become simple sequences.)
We also assume that $\FS_A$ and $\FS_B$ are not broken.
With these assumptions,
we can now define independent sequences and
our reconciliation algorithm.

\begin{mydef}{Independent commands, sequences and sets.}
For two commands $\cxynv$ and $\czwmv$ we write $\cxynv\indep\czwmv$ if $\cxynv\cc\czwmv \equiv \czwnv\cc\cxynv \nequiv \cbrk$.
For two sequences or sets of commands $A$ and $B$ we write $A\indep B$ if
$\forall a\in A \mbox{~and~} \forall b\in B: a\indep b$.
\end{mydef}

\begin{mydef}{Reconciliation.}\label{def:reconciliation}
\begin{align*}
\reca = \{c| & \\
& c\in A\setminus B \\
& \wedge \\
& \forall c'\in B\setminus A: c\indep c'\\
\} &
\end{align*}

In other words, the sequence $\reca$ we apply to $\FS_B$ consists of all commands from $A\setminus B$
that are independent of every command in $B\setminus A$.
The order of commands in the sequence can be determined using the algorithm described in
\cref{ordering} as any subset of $A$ is also simple.
In a similar way, $\recb$ can be obtained by reversing $A$ and $B$.
\end{mydef}

We would now like to prove that $\reca$ and $\recb$ can be applied to the replicas,
that is, without loss of generality,
\[ \reca\FS_B\neq\fsbroken. \]
So that we can formalize statements needed to prove this,
let us introduce two relations that describe under what conditions
sequences of commands work, that is, do not break a filesystem.


% Works
% -----

\begin{mydef}
% Unsure if this relation should be in the algebra.
For a set of $k$ sequences
$\works{A_1,A_2,\ldots,A_k}$ means that 
$A_1,A_2,\ldots,A_k$ work at the same time, that is,
% intended interpretation:
\[\exists \FS: A_1\FS\neq\fsbroken \wedge \cdots \wedge A_k\FS\neq\fsbroken\]
As the sequences form a set, their order is irrelevant.
% inference rules:
We also know that $\works{A} \Leftrightarrow A\nequiv \cbrk$. 
\end{mydef}

\begin{mydef}
For two sets of sequences, $\worksc{A_1,A_2,\ldots,A_k}{B_1,B_2,\ldots,B_l}$ means that 
all of $A_1,\ldots,A_k$ work where all of $B_1,\ldots,B_l$ work,
that is,
% intended interpretation:
\begin{align*}
\forall \FS:&\\ 
&B_1\FS\neq\fsbroken \wedge \cdots \wedge B_k\FS\neq\fsbroken\\
&\Rightarrow\\
&A_1\FS\neq\fsbroken \wedge \cdots \wedge A_l\FS\neq\fsbroken
\end{align*}
As above, the order of the sequences in the sets is not relevant.
\end{mydef}

\begin{mydef}{Sets of sequences.}
For brevity, we will use $\seqset{S}$ to note an arbitrary set of sequences,
and $A\cc\seqset{S}$ to note the set of sequences $\{A\cc S|S\in\seqset{S}\}$.
\end{mydef}

It is easy to see that the following corollaries are true:

% An inference rule in the algebra
% $\worksc{X}{X}$ is always true for any set of sequences $X$,

\begin{mycor}
% An inference rule in the algebra
$B\eqext A \Rightarrow \worksc{A}{B}$.
\end{mycor}

\begin{mycor}\label{worksextpostfix}
% An inference rule in the algebra
$\forall A,S: \worksc{A}{A\cc S}$, that is, if a sequence works, its prefix also works.
\end{mycor}

\begin{mycor}\label{workschained}
% An inference rule in the algebra
$\workssign$ can be chained:
if $\seqset{A'}\subset\seqset{A}$, then
$ \worksc{\seqset{C}}{\seqset{A'}} \wedge \worksc{\seqset{A}}{\seqset{B}} \Rightarrow \worksc{\seqset{A}\cup\seqset{C}}{\seqset{B}}$.
\end{mycor}

We also prove the following lemmas.

\begin{mylem}\label{unrelated_is_independent}
Two different commands that are not assertion commands are independent iff the nodes they change are unrelated:
\[ \cxynv\indep\czwmv \Leftrightarrow n\unrel m \]
if $\cxynv\neq\czwmv$ and none of $\cxy$ and $\cxw$ is $\cbb$ or $\cdd$.
\end{mylem}
\begin{proof}
We proceed in two steps; first, we prove that
\[ \cxynv\nindep\czwmv \wedge n\unrel m \] would lead to contradiction.
By definition, if the two commands are not independent, then at least one of the following holds:
\begin{itemize}
\item $\czwmv\cc \cqrov \equiv\cbrk$
\item $\cqrov\cc \czwmv \equiv\cbrk$
\item $\czwmv\cc \cqrov \nequiv \cqrov\cc \czwmv$
\end{itemize}
However, from \cref{ax_separate_commute,ax_separate_nobreaks} we also know that
if $n\unrel m$ then none of the above can be true.

Next, we prove that
\[ \cxynv\indep\czwmv \wedge n\nunrel m \] would lead to contradiction.
As $n\nunrel m$
we know that $n=m$, $n\descendant m$ or $m\descendant n$.

If $n=m$, then from \cref{ax_same_breaks} we know $Y=Z$ and $W=X$
as otherwise the commands, in one order or the other, would break all filesystems
and they could not be independent.
The commands are not assertion commands, and so from \cref{ax_same_singlec}
we know that $\cxynv\cc\czwnv\equiv\czwnv\cc\cxynv$ can only happen if $Y=W$ and $\valvy=\valvw$.
Therefore $X=Y=Z=W$ which is only possible if both commands are $\cff$ and have the same
output value. This, however, contradicts our assumption that they are different.

If $n\descendant m$ or $m\descendant n$, then
from \cref{ax_distantrel_breaks} we know that if they are not directly related,
then $\cxynv\cc\czwmv$ breaks all filesystems, and they cannot be independent.
From the construction and destruction pairs and 
\cref{ax_directchild_breaks,ax_directparent_breaks} we also see that
even if they are directly related, either
$\cxynv\cc\czwmv$ or $\czwmv\cc\cxynv$ 
breaks all filesystems, so they again cannot be independent.
\end{proof}

\begin{myax}\label{combine_independent_commands}
The combination of independent commands works wherever the original commands work:
\begin{align*}
\forall\FS: &\cxynv\indep \czwmv \\
&\quad\wedge \cxynv\FS\neq\fsbroken \\
&\quad\wedge \czwmv\FS\neq\fsbroken \\
&\Rightarrow \cxynv\cc \czwmv\FS\neq\fsbroken.
\end{align*}
\end{myax}
\begin{proof}
We name this proposition an axiom for the same reason as above,
but it is easy to provide an indirect proof based on our filesystem model.
Assume that $\cxynv\cc \czwmv\FS=\fsbroken$.
We know $\cxynv\FS\neq\fsbroken$ so it must be applying 
$\czwmv$ that breaks it.
Applying a command can only result in a broken filesystem in three cases.
First, if the filesystem was already broken, which cannot be the case here.
Second, if the input type does not match the filesystem,
but we know $\FS(m)\in\setvx{W}$ and so
$(\cxynv\FS)(m)\in\setvx{W}$ as based on \cref{unrelated_is_independent}, $n\neq m$.
Third, if the new filesystem violates the tree property.
This again cannot be the case because we also know that $n\unrel m$
and the tree property only depends on the types of the parent and children of $m$,
which therefore cannot be changed by $\cxynv$.
\end{proof}

This result can be extended to sequences:

\begin{mylem}\label{combine_independent_sequences}
The combination of independent sequences works wherever the original sequences work:
\[ S\indep T \Rightarrow \worksc{S\cc T}{S,T}. \]
\end{mylem}
\begin{proof}
Assume that there is a filesystem $\FS$ so that
$S\FS\neq\fsbroken$ and $T\FS\neq\fsbroken$, but
$(S\cc T)\FS=\fsbroken$.

From \cref{unrelated_is_independent,ax_separate_commute} we know that
the commands in $S$ and $T$ pairwise commute, and so any sequence
that contains the commands from $S$ and $T$ and preserve their original partial order
is equivalent to $S\cc T$ on all filesystems.

Let the command that breaks $\FS$ in $T$ when applying $S\cc T$ be $t$
so that $T=T_0\cc t\cc T_1$.
It is still true that $(T_0 \cc t)\FS\neq\fsbroken$,
and by definition $(S\cc T_0)\FS\neq\fsbroken$,
but $(S\cc T_0\cc t)\FS=\fsbroken$.
Also, from above we know that $S\cc T_0\equiv T_0\cc S$
and so $(T_0 \cc S)\FS\neq\fsbroken$.

If we denote the first command in $S$ with $s_1$,
this means that $(T_0 \cc s_1)\FS\neq\fsbroken$,
which we can combine with $(T_0 \cc t)\FS\neq\fsbroken$, $t\indep s_1$ and
\cref{combine_independent_commands}
(using $T_0\FS$ as the reference filesystem)
to arrive at $(T_0 \cc s_1\cc t)\FS\neq\fsbroken$.

We can repeat this step for $s_2$, the next command in $S$,
and from 
$(T_0 \cc s_1\cc t)\FS\neq\fsbroken$
and
$(T_0 \cc s_1\cc s_2)\FS\neq\fsbroken$
arrive at
$(T_0 \cc s_1\cc s_2\cc t)\FS\neq\fsbroken$.
This can be repeated until $S$ is exhausted and we get
$(T_0 \cc S\cc t)\FS\neq\fsbroken$, which is a contradiction.
\end{proof}

Separately, we prove the following:

\begin{mylem}\label{worksinputmatch}
If $A$ and $B$ are minimal sequences, $\works{A,B}$,
and there are commands on node $n$ in both $A$ ($\cxynv\in A$) and $B$ ($\czwnv\in B$)
then their input types must match ($X=Z$).
\end{mylem}
\begin{proof}
This is easily shown using an indirect proof: if $X\neq Z$, then there is no filesystem that
either $\cxynv$ or $\czwnv$ would not break, 
and consequently $A$ and $B$ cannot work on the same filesystem.
\end{proof}



\medskip

We continue by defining inverse commands and sequences
which allow us to move parts of sequences between the
condition and consequence parts of $\workssign$.

\begin{mydef}{Inverse commands and sequences.}
The inverse of command $\cxynv$ is $\cxynv^{-1} = \caaaa{Y}{X}{n}{\valvx}$
where $V_X$ is an arbitrary value from $\setvx{X}$.
We write $S^{-1}$ for the inverse of sequence $S$, which consists of the inverses of the commands in $S$
in reverse order.
\end{mydef}

\begin{mydef}{$\typeeq$.}
For two filesystems we write $\FS\typeeq\GS$
iff 
at all nodes the types of their values are the same, or they are both broken.
\end{mydef}

From the definitions we can clearly see that
\begin{mycor}\label{negneg_is_typeeq}
$\forall \FS: (S^{-1})^{-1}\FS\typeeq \FS$.
\end{mycor}

\begin{mylem}\label{r_invmove}
A common prefix of sequences can be moved to the other side of $\workssign$ by inverting it:
\begin{gather*}
\worksc{B\cc \seqset{A}}{\seqset{S}} \Rightarrow \worksc{\seqset{A}}{B^{-1}\cc \seqset{S}} \\
\worksc{\seqset{A}}{B\cc \seqset{S}} \Rightarrow \worksc{B^{-1}\cc \seqset{A}}{\seqset{S}}
\end{gather*}
\end{mylem}
\begin{proof}
This is based on the fact that in our model, unless they break a filesystem,
commands change one type of value into another, but never merge types.
That is,
sequences---as functions mapping filesystems to filesystems---are
essentially bijections over type-equality
with the only ``sink'' being $\fsbroken$:
\begin{align*}
\forall S,\FS,\GS: &S\FS\neq\fsbroken \Rightarrow \\
&(S\FS\ntypeeq S\GS \Leftrightarrow \FS\ntypeeq \GS).
\end{align*}

For the proposition
\[ \worksc{B\cc \seqset{A}}{\seqset{S}} \Rightarrow \worksc{\seqset{A}}{B^{-1}\cc \seqset{S}} \]
the rest of the proof is illustrated by the diagram below
where Dom($x$), the domain of $x$, represents the set of filesystems
the sequence $x$ does not break, or neither of the sequences in the set $x$ breaks.

\input{inverse-works} % TODO arrows too small

We see that the set of filesystems the sequences in $\seqset{A}$ do not break intersect with the range of $B$.
As $B$ is a bijection between its domain and range, we can use $B^{-1}$ to map this intersection back
onto the domain of $B$.
As $\worksc{B\cc \seqset{A}}{\seqset{S}}$ the domain of $\seqset{S}$ must be a subset of this
projected intersection.
If so, then we can use $B$ to map the domain of $\seqset{S}$, which yields the domain of $B^{-1}\cc \seqset{S}$.
As it is also a part of the domain of $A$, we get $\worksc{\seqset{A}}{B^{-1}\cc \seqset{S}}$.

The second part of the lemma can be proven in a similar way.
\end{proof}


\begin{mylem}\label{indep_prefix_combine}
The combination of sequences with a common head and independent tails continues to work under the same conditions:
\[ \worksc{A\cc B}{\seqset{S}} \wedge \worksc{A\cc C}{\seqset{S}} \wedge B\indep C \Rightarrow \worksc{A\cc B\cc C}{\seqset{S}} \]
\end{mylem}
\begin{proof}
Based on \cref{r_invmove} we know
$\worksc{B}{A^{-1}\cc \seqset{S}}$ and $\worksc{C}{A^{-1}\cc \seqset{S}}$,
and from \cref{combine_independent_sequences} we know
$\worksc{B\cc C}{B,C}$.
Combining these using \cref{workschained}
we get
$\worksc{B\cc C}{A^{-1}\cc \seqset{S}}$. 
Finally, applying the second line of \cref{r_invmove} yields
$\worksc{(A^{-1})^{-1}\cc B\cc C}{\seqset{S}}$, which proves our lemma 
as $\forall\FS: (A^{-1})^{-1}\FS\typeeq A\FS$ (\cref{negneg_is_typeeq}).
\end{proof}


\medskip

% Correctness of reconciliation
% -----------------------------

We are now ready to prove that the proposed algorithm for reconciliation is correct,
that is, applying its result is not going to break the replicas.
We reformulate the original proposition, $\reca\FS_B\neq\fsbroken$,
based on $\FS_B=B\FS$ and so we aim to prove that
$B\cc\reca$ works wherever $A$ and $B$ work:

\begin{myth}
If $A, B$ are simple, then $\worksc{B\cc \reca}{A,B}$,
where, to restate \cref{def:reconciliation},
% { % scope
% \renewcommand{\themydef}{\ref{def:reconciliation}}
% \begin{mydef}
\begin{align*}
\reca = \{c| & \\
& c\in A\setminus B \\
& \wedge \\
& \forall c'\in B\setminus A: c\indep c'\\
\}. &
\end{align*}
% \end{mydef}
% } % scope
\end{myth}

This is trivial unless $\works{A,B}$, so we assume that it is true.
Let us first investigate the part of $A$ and $B$ that is excluded from
$\reca$: their intersection.

\begin{mylem}\label{can_move_intersection}
Let $A$ and $B$ be two simple sequences so that $\works{A, B}$.
Then their intersection, in some suitable order, also works on any filesystem
either of them works on:
$\worksc{A\cap B}{A}$, and, by symmetry,
$\worksc{A\cap B}{B}$.
\end{mylem}

\begin{proof}
The difficulty is that commands in $A\cap B$ can occur anywhere in $A$.
Therefore, first we prove the following:
if all commands are marked in $A$ that also appear in $B$,
then there is an $A'$ in $\orderset{A}$ in which all marked commands are at the beginning.

We show that $A$ can be transformed via equivalences so that this would be true.
Our proposition is that if the marked commands are not at the beginning, then
the sequence contains an unmarked command followed by a marked command.
We show that these can be swapped resulting in an equivalent sequence.
Then, by repeating this process similarly to bubble sorting, we can generate 
a suitable $A'$.

\medskip

Let us consider therefore the marked command preceded by an unmarked command in $A$,
and let the marked command be $\cxynv$, 
and the preceding unmarked command be $\czwmv$.
As $A$ is simple and $\works{A}$, from 
\cref{ax_distantrel_breaks,ax_directchild_breaks,ax_directparent_breaks}
we know that these commands can only be on unrelated paths or form a construction or destruction pair.
In the first case, swapping the commands results in a sequence equivalent to $A$,
and we show that the last two cases are impossible as they would lead to contradiction.

In these cases, either $m=\parent(n)$ or $n=\parent(m)$.
If $B$ has a command on $m$, then
from \cref{lemma:neighbor}
we know that there is a $B'$ in $\orderset{B}$ where it is next to $\cxy$ (also in $B$),
and from \cref{simple_reorder_equiv} we know that $B'\equiv B$.
When describing our ordering algorithm in \cref{ordering} we saw
that the command on the parent path deremines whether a pair of commands
is a construction or destruction pair,
and that this, in turn, determines whether the command on the child path must
precede or follow the other command as otherwise the sequence would break all filesystems.
This argument holds for both $A$ and $B$, and so the command on $m$ must be on
the same side of the command on $n$ in both sequences.

If $B$ has no command on $m$, then let $B'$ be $B$, 
but with an extra command added to it just before $\cxy$
according to \cref{ax_child_assert,ax_parent_assert}, 
from which we know that $B'\equiv B$.
We also know that $B'$ is still minimal (but no longer simple).

In either case, therefore,
we have a minimal $B'$ which has a command on $m$ just before $\cxynv$ and $B'\equiv B$.
Let this command on $m$ be $\cqrmv$.
\begin{gather*}
A = \cdots\cc  \czwmv\cc  \cxynv\cc  \cdots \\
B' = \cdots\cc  \cqrmv\cc  \cxynv\cc  \cdots
\end{gather*}

As $\works{A,B}$ and so $\works{A,B'}$, 
from \cref{worksinputmatch}
we know that $Q=Z$. 

Going back to the construction and destruction pairs we see that the output type of the first command
is always the same, and it is either $D$ or $\empt$ depending on the relationship between $n$ and $m$.
Therefore $R=W$ and $\cqrmv=\czwmv$
as $|\setd|=|\setb|=1$. 
If $B$ originally had a command on $m$,
this is a contradiction as $\czw$ was not marked, but we see it must also be in $B'$ and therefore in $B$.
If $B$ had no command on $m$,
this is a contradiction because the command on $m$ in $B'$ is an assertion command, so $Z=Q=R=W$, 
but $A$ contained no assertion commands.

\medskip

We now know that there is an $A'\equiv A$ in which commands in $A\cap B$
are at the beginning, and therefore 
from \cref{worksextpostfix}
$\worksc{A\cap B}{A}$ and by symmetry $\worksc{A\cap B}{B}$.
\end{proof}

\medskip

\newcommand{\acb}{(A\cap B)}
\newcommand{\acbi}{\acb^{-1}}
\newcommand{\amb}{(A\setminus B)}
\newcommand{\bma}{(B\setminus A)}
We would like to prove that $\worksc{B\cc \reca}{A,B}$.
From the above we know that this is equivalent to
\[ \worksc{\acb\cc \bma\cc \reca}{A,B}. \]
As we already know that $\reca\indep\bma$
and that $\worksc{\acb\cc \bma}{A,B}$
(as $\worksc{B}{A,B}$),
based on \cref{indep_prefix_combine}
we only need to prove that
\[ \worksc{\acb\cc \reca}{A,B}. \]
Using \cref{r_invmove} we can rephrase this as
\[ \worksc{\reca}{\acbi\cc A,\acbi\cc B}. \]

To restate some results above, we therefore already know the following things:
\begin{itemize}
\item $\amb$ and $\bma$ are simple as $A$ and $B$ are simple
\item $\amb \cap \bma = \emptyset$
\item $\reca$ is the largest subset of $\amb$ for which $\reca\indep\amb$
\item $\worksc{\amb, \bma}{\acbi\cc A,\acbi\cc B}$ 
because of \cref{r_invmove}
as $\worksc{A,B}{A,B}$,
and $A\equiv\acb\cc\amb$, and $B\equiv\acb\cc\bma$.
\end{itemize}

Our theorem is therefore proven if we prove the following lemma:
\newcommand{\condSimple}{(c1)}
\newcommand{\condDisj}{(c2)}
\newcommand{\condApr}{(c3)}
\newcommand{\condWork}{(c4)}
\begin{mylem}
If
   \begin{itemize}
   \item[\condSimple] $S$ and $T$ are simple sequences,
   \item[\condDisj] $S\cap T=\emptyset$,
   \item[\condApr] $S^*$ is the largest subset of $S$ where $S^*\indep T$, and
   \item[\condWork] $\worksc{S,T}{\seqset{C}}$ for some set of sequences $\seqset{C}$,
   \end{itemize}
then
\[ \worksc{S^*}{\seqset{C}}. \]
\end{mylem}

\begin{proof}
This is trivial unless $\works{\seqset{C}}$, so we will assume that it is true
and therefore $\works{S,T}$.

The proof is similar to that of \cref{can_move_intersection}.
We mark all commands in $S$ that are in its subset $S^*$, and
we prove that $S$ can be transformed into $S'$ via equivalences
so that all marked commands would be at its beginning.
If so, then based on \cref{worksextpostfix}
$\worksc{S^*}{\seqset{C}}$ as $\worksc{S'}{\seqset{C}}$ and $S'=S^*\cc S_0$ 
where $S_0$ contains the remaining (conflicting) commands.

Again we know that if $S$ does not already have all marked commands at its beginning,
then there is an unmarked command followed by a marked one.
We show that these commands are independent and so they can be swapped
resulting in an equivalent sequence.
By repeating this process we can generate a suitable $S'$.

Let therefore the marked command in $S$ be $\cxynv$
and the preceding unmarked command be $\czwmv$.
As $S$ is simple and $\works{S}$, from 
\cref{ax_distantrel_breaks,ax_directchild_breaks,ax_directparent_breaks}
we know that these commands can only be on unrelated paths or form a construction or destruction pair.
In the first case, swapping the commands results in a sequence equivalent to $S$;
we only need to show that the other two cases are not possible as they would lead to a contradiction.

In the last two cases, we know that either $m=\parent(n)$ or $n=\parent(m)$.
We also know that because of {\condApr} there must be 
a command $\cqrov$ in $T$ which is not independent of $\czwmv$
as $\czwmv$ is not part of $S^*$.
\begin{gather*}
S = \cdots\cc  \czwmv\cc  \cxynv\cc  \cdots \\
T = \cdots\cc  \cqrov\cc \cdots
\end{gather*}
We know none of these commands is an assertion command, and 
from {\condDisj} that $\cqrov\neq\czwmv$.
Therefore, based on \cref{unrelated_is_independent} we know this means that
either $m\descendantEq o$ or $o\descendantEq m$.
From {\condApr} we also know that $\cxynv\indep \cqrov$,
and so because of \cref{unrelated_is_independent},
$n\unrel o$.

We therefore have four cases considering the relationships between $n,m$ and $o$:
\begin{itemize}
\item $n=\parent(m) \wedge o\descendantEq m$.
   This would mean that $o\descendantEq n$ or $n=\parent(o)$, which contradicts $n\unrel o$.
\item $n=\parent(m) \wedge m\descendantEq o$.
   This would mean that $n\descendant o$, which contradicts $n\unrel o$.
\item $m=\parent(n) \wedge o\descendantEq m$.
   This would mean that $o\descendant n$, which contradicts $n\unrel o$.
\item $m=\parent(n) \wedge m\descendantEq o$.
   Let us continue with this case.
\end{itemize}

We know that $T$ cannot have a command on $m$ as $m=\parent(n)$ and $\cxynv\indep T$,
and so $m\neq o$ and therefore $m\descendant o$.
This means we can create a new sequence $T'\equiv T$ by inserting a command on 
$m$ into $T$ before $\cqrov$
according to \cref{ax_parent_assert}.
We now have $\cxynv\indep T\equiv T'$ which is a contradiction as
$T'$ has a command on $m$ and $m=\parent(n)$.
\end{proof}


\medskip

% Reconciliation is maximal
% -------------------------
% This is where we're using |D|=1
% C.f. strict / liberal etc. reconciliation in references



% TODO
TODO: $\reca$ is maximal

% TODO
TODO: About setting up an algebra / calculus

% TODO
TODO: Are these results quite obvious as this is a well-known kind of algebra or system?

\begin{thebibliography}{99}

\bibitem{NREC:alg} Ramsey, Norman and Elod Csirmaz: {\it An algebraic approach to
file synchronization...}

\bibitem{BZ} Bill Zissimopoulos, personal communication, ...

\end{thebibliography}

\end{document}
