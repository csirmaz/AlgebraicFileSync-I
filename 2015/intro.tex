
\section{Introduction}

Synchronizing data structures, and filesystems in particular,
is a task that we encounter more and more often in our world
of multiple mobile devices, cloud solutions and distributed systems.
Applications of synchronization ranges from
solutions for end users who expect to access personal data seamlessly
on multiple devices and personal clouds to geographically distributed server networks
that need to synchronize themselves with low latency to serve the 
same content.

In this paper we
continue the work in \cite{NREC} and add to the theoretical understanding
of synchronization based not on filesystem states, but filesystem changes or commands.

% TODO operation-based vs state-based

% Synchronization:
% Main aim: apply updates (where possible) from other replicas
% update detection -> conflict detection -> merging updates -> ordering updates -> apply updates from other replicas
% Problems: conflict detection, ordering

% ORDERING - because when taking updates from different replicas we get an essentially unordered set
% Insight: (Prof. Norman Ramsey)
% - updates where two orders (AB vs BA) are not equivalent are incompatible
% - we only have a set of updates and need to create an order

% New:
% better command (instruction) set
% simpler reconciliation algorithm
% proof of correctness and completeness

% rigorous proof, non-trivial

% Update detection
% - ordering
% Reconciliation
% - conditional operation & inverse sequences
