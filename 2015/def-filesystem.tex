
\subsection{The Filesystem}

We model a filesystem using a function $\FS$ with a set of nodes (filesystem paths) $\setn$ as its domain,
and a set of possible contents or values, $\setv$, as its codomain:
\begin{mydef}[Filesystem]
\[ \FS : \setn \rightarrow \setv \] 
\end{mydef}
In our model, $\setn$ 
serves as a namespace or ``skeleton'' for the filesystem, and it
contains all possible nodes, including the ones where there is no file or directory.
To model empty nodes, $\setv$ 
contains a special element ($\empt$) which is the value of $\FS$ at these nodes.
We consider the contents of files, as well as any meta-information of files
and directories (e.g. permissions and other flags) part of the values in $\setv$.

The nodes form a disjoint union of rooted directed trees.
Tao et al. in \cite{TSR} describe a similar filesystem model, although
they also model inodes and restrict the filesystem to a just single tree.
\begin{mydef}[$\parent$]
The function $\parent(n)$ returns the parent node of $n$, or
returns $\topnode$ if $n$ is the root of a tree.
\end{mydef}

Every filesystem has a so-called \emph{tree property}, which means that
if the filesystem is not empty at a node, and the node has a parent,
then there must be a directory at the parent node.

To model this, in $\setv$ we distinguish between 
file values ($\setf$) and directory values ($\setd$), that is,
if $\setb = \{\empt\}$ then:
\[ \setv = \setb \cup \setf \cup \setd \]
The tree property can then be defined as
\begin{mydef}[Tree property]
\begin{align*}
\forall n\in\setn: &\FS(n) \neq \empt \\ % TODO alignment problem
&\quad\wedge \parent(n) \neq \topnode \\
&\Rightarrow \FS(\parent(n)) \in \setd. 
\end{align*}
\end{mydef}
This means that as we move down from the root of a tree of nodes,
the types of values we encounter in the filesystem can only change according to the
transition diagram in \cref{fig_transition}, from directories ($\cchard$) to files ($\ccharf$)
to empty nodes ($\ccharb$).

\begin{figure}[htb]
\input{fig-type-transition}
\caption{Transitions between types of values in a filesystem}\label{fig_transition}
\end{figure}

In this paper, $n$, $m$ and $o$ denote nodes in $\setn$.
We use $\valf$ for an arbitrary element in $\setf$, 
and $\vald$ for an arbitrary element in $\setd$,
and by $\valvx$ we mean a value of type $X$ in $\setvx{X}$.

% Simplification
% --------------

A simplification we will assume in this paper is regarding directories.
As Bill Zissimopoulos pointed 
out,\footnote{Bill Zissimopoulos, personal communication, August 2015.} 
we often do not want to consider metadata stored in
directories (e.g. permission settings) during synchronization,
as these are not generally understood well by users,
and, if needed, conflict resolution on these settings can be easily automated.
In other words, the contents of directories are all equal,
which can be modelled by assuming that $|\setd|=1$.
