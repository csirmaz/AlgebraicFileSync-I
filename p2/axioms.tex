

\section{Command Pairs and Sequences}\mlabel{section_axioms}

% Sequences
% ---------

So that we can describe the effects of commands independently of filesystems,
let us introduce some notation
and note some observations.
We already know that
commands usually do not occur in isolation,
and are applied to filesystems in time.
Therefore we investigate sequences of commands with a well-defined order.
\begin{mydef}[Sequences of commands: $\cc$ and $\emptyseq$]
We use ``$\cc$'' to combine commands to form a sequence, or combine sequences to form a longer sequence,
with the meaning that the sequence is executed from left to right:
\[ \alpha\cc\beta\aFS = \beta(\alpha\aFS). \]
%% monoid, but not free monoid
%% monoid: semigroup with identity element
%% Sequences of commands form a free semigroup
Sequences are also partial endofunctions on filesystems,
defined only if all commands they contain succeed in the given order.
Sequences form a monoid, and, as usual,
we write $\emptyseq$ to denote the unit element, the empty sequence,
which is defined on all filesystems and, by definition, leaves all filesystems unchanged.
\end{mydef}

\begin{mydef}[$\Dom{S}$]
For a sequence of commands $S$, $\Dom{S}$ is the domain of $S$, that is,
the set of filesystems $S$ does not break.
\end{mydef}


The following two relations 
echo the ones defined in \cite{NREC}.
In the definitions, $A,B,S$ and $T$ stand for arbitrary sequences.

\begin{mydef}[$\eqext$, $\strext$ and $\equiv$]
% Relation in the algebra
We write $A\eqext B$, or say that $B$ \emph{extends} $A$,
% intended interpretation:
to mean that they behave in the same way
on any filesystem $A$ does not break:
$\forall \FS\in\Dom{A}:\,A\aFS=B\aFS$.
% old inference rule: $ A\eqext B \Rightarrow S\cc A\cc T\eqext S\cc B\cc T$,
We can also see that $A\eqext B$ and $S\eqext T$ implies $A\cc S\eqext B\cc T$.
% symmetric:     aRb <=> bRa
% antisymmetric: aRb & bRa => a=b
% reflexive:     aRa
% transitive:    aRb & bRC => aRc
% preorder:      reflexive, transitive
% partial order: reflexive, transitive, antisymmetric
% equivalence:   reflexive, transitive, symmetric
% congruence:    https://en.wikipedia.org/wiki/Congruence_relation
% precongruence: congruence of a preorder
In other words, $\eqext$ is a preorder, and also a precongruence. % TODO

% Relation in the algebra
We write $A\equiv B$,
or say that $A$ and $B$ are \emph{equivalent,}
iff $A\eqext B$ and $B\eqext A$;
that is, $\equiv$ is the intersection of the preorder $\eqext$ with its inverse,
and so it is a congruence. % TODO
% old inference rule: $ A\equiv B \Rightarrow S\cc A\cc T\equiv S\cc B\cc T $.

Finally, we write $A\strext B$ to mean $A\eqext B$ and $A\nequiv B$.
In particular, we write $\wrks{A}$
to mean that $\Dom{A}$ is not empty, that is, if $A$ is defined on some filesystems.
\end{mydef}

It is easy to see that the equivalence $\equiv$ holds on the level of filesystems:
\begin{mylem}\mlabel{equiv_on_fs}
$A\equiv B$
iff $A$ and $B$ behave in the same way on
all filesystems, that is, $\forall \FS: A\aFS=B\aFS$.
\end{mylem}
\begin{proof}
As $A\equiv B$ means that both $A$ extends $B$ and $B$ extends $A$, it necessarily
follows that $A$ and $B$, as partial functions, are identical.
\end{proof}

% Rules
% -----

\myskip
Our aim is to derive information about the effects of sequences
of commands independently of the actual filesystems.
In order to make this possible, we investigate the smallest building
blocks of sequences: pairs of commands that act on a filesystem directly one after the other.
This approach is useful as there are a limited number of command pairs,
because, as we argued above, we can disregard the exact output values of commands apart from their type,
and we can also abstract the relationship between the nodes in the two commands
to a finite number of cases.
These properties of command pairs are crucial as they determine
how a set of commands can be re-ordered to be applied to a filesystem
during synchronization, and what command pairs will never be compatible.

\myskip
Command pairs in genral have the form
\[ \cxynv\cc  \czwmv \]
where $x,y,z,w\in\setv$ and $n,m\in\setn$. 
Extending \cref{def:command_categories}, we call certain pairs
\emph{construction} or \emph{destruction pairs}.

\begin{mydef}[Construction and destruction pairs]
A pair of commands on nodes $\nn$ and $n$ where $\nn=\parentf{n}$
is a \emph{construction pair} if the input and output types match
one of the following patterns:
   \begin{align*}
            \cbda{\nn}&\cc  \cbfa{n} \\
            \cbda{\nn}&\cc  \cbda{n} \\
            \cfda{\nn}&\cc  \caaa{\empt}{\valff}{n} \\
            \cfda{\nn}&\cc  \cbda{n}
   \end{align*}
The pair is a \emph{destruction pair} if the types match one of the following:
   \begin{align*}
            \cfba{n}&\cc  \cdba{\nn} \\
            \cfba{n}&\cc  \caaa{\vald}{\valff}{\nn} \\
            \cdba{n}&\cc  \cdba{\nn} \\
            \cdba{n}&\cc  \cdfa{\nn}
   \end{align*}
\end{mydef}

We can see that construction pairs consist of construction comands,
while destruction pairs consist of destruction commands.




\Cref{rules_lemma} summarizes the basic properties of command pairs.
The claims listed are named \emph{\namecref{ax_separate_commute}}
as they can also be interpreted as inference rules in a pure
algebraic treatment of filesystem synchronization.
TODO elaborates this approach.

\begin{mylem}\mlabel{rules_lemma}
\newcounter{rulecounter}
\begin{list}{\bf Rule~\arabic{rulecounter}.}{\usecounter{rulecounter}}

\item[] % line break after the lemma label

\item\mlabel{ax_separate_commute}
Commands on incomparable nodes commute:
$\cxynv\cc\czwmv \equiv \czwmv\cc\cxynv$ where $n\unrel m$.

\item\mlabel{ax_separate_nobreaks}
Commands on incomparable nodes also do not break all filesystems:
$\wrksx{\cxynv\cc\czwmv}$ where $n\unrel m$.

\item\mlabel{ax_same_breaks}
Commands on the same node break every filesystem if their types are incompatible:
$\cxynv\cc\czwnv \equiv \cbrk$ where $[y]\ne [z]$.

\item\mlabel{ax_same_emptyseq}
Otherwise commands on the same node are extended by an empty sequence if their outer types represent
an assertion command:
$\cxynv\cc\czwnv \eqext \emptyseq$ where $[y]=[z]$, and $\cxw=\cbb$ 
or $\cxw=\cdd$.

\item\mlabel{ax_same_singlec}
All other command pairs on the same node are equivalent to a single command:
$\cxynv\cc \czwnv \equiv \cxwnv$ where $[y]=[z]$ and $\cxw\neq\cbb$ and $\cxw\neq\cdd$.

% TODO Renumber rules in script

\item\mlabel{ax_directchild_breaks}
Commands on a parent and a child node break every filesystem
if the pair is not a construction pair
and the commands do not simply assert a directory at the parent
or an empty node at the child:
$\cxynnv\cc\czwnv \equiv \cbrk$ where $\nn=\parent(n)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$.

\item\mlabel{ax_directparent_breaks}
Commands on a child and parent node break every filesystem
if the pair is not a destruction pair
and the commands do not simply assert an empty node at the child
or a directory at the parent:
$\cxynv\cc\czwnnv \equiv \cbrk$ where $\parent(n)=\nn$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$.

\item\mlabel{ax_distantrel_breaks}
Commands on distant relatives break all filesystems
if the commands do not simply assert a directory at the ancestor
or an empty node at the descendant:
$\cxynnv\cc\czwnv \equiv \cbrk$
and $\czwnv\cc\cxynnv \equiv\cbrk$
where $\nn\descendant n$ and $\nn\neq\parent(n)$, and $\cxy\neq\cdd$ and $\czw\neq\cbb$.

\item\mlabel{ax_child_assert}
An assertion command can be freely added on a descendant node
next to a command that does not simply assert a directory:
\[ \cbba{n}\cc\cxynnv \equiv \cxynnv \equiv \cxynnv\cc\cbba{n} \] 
where $\nn\descendant n$ and $\cxy\neq\cdd$.

\item\mlabel{ax_parent_assert}
An assertion command can be freely added on an ancestor node
next to a command that does not simply assert an empty node:
\[ \cdda{\nn}\cc\cxynv \equiv \cxynv \equiv \cxynv\cc\cdda{\nn} \]
where $\nn\descendant n$ and $\cxy\neq\cbb$.

\item\mlabel{ax_assert}
All assertion commands can be removed as the empty sequence extends them:
$\cdda{n}\eqext\emptyseq$ and $\cbba{n}\eqext\emptyseq$.

\end{list}
\end{mylem}

These claims are easy but tedious to check.
To ensure that all cases were considered when verifying these claims,
a computer program was prepared that models the relevant parts of
a filesystem and checks the results of applying all different command pairs
against the above claims.\footnote{The program is accessible at \\ 
https://github.com/csirmaz/AlgebraicSyncPaper/blob/master/p2/prove.py.}

For \cref{ax_distantrel_breaks}, we also provide a simple proof.
Suppose $\cxynnv$ and $\czwnv$ satisfy the conditions in the \namecref{ax_distantrel_breaks},
and there if an $\FS$ for which $(\cxynnv\cc\czwnv)\aFS\neq\fsbroken$.
If $\czw\neq\cbb$, then either $\FS(n)\neq\empty$ or $\czwnv\aFS(n)\neq\empty$,
and therefore $\FS(\parentf{n})$ must be a directory for the filesystem to satisfy
the tree property at all times.
However, from $\cxy\neq\cdd$ we also know that either $\FS(\nn)$ 
(before applying $\cxynv$) or $\cxynv\aFS(\nn)$ (after applying $\cxynv$)
is not a directory. Depending on which is true, we have a point in the sequence
of applying the commands where the filesystem cannot satify the tree property
and therefore becomes broken as $\parentf{n}$, a descendant of $\nn$, contains
a directory and so must all its ancestors.

For \cref{ax_child_assert,ax_parent_assert}, we note that these claims
easily follow from the fact that the commands are adjacent to each other.

Finally, we have included \cref{ax_directchild_breaks,ax_directparent_breaks}
for completeness, but we will use the more generic \cref{simple_distant_pairs},
which extends these rules to non-adjacent commands, although only in the case
of command sequences without any assertion commands.




% Independent commands
% --------------------

\myskip
We also define the concept of two commands being independent.

\begin{mydef}[$A\indep B$: Independent commands, sequences and sets of commands]\mlabel{def_indep}
Two commands $\alpha$ and $\beta$ 
are independent, and we write $\alpha\indep\beta$ if 
they commute and do not break all filesystems:
\[ \alpha\cc\beta \equiv \wrksx{\beta\cc\alpha}. \]
For two sequences or unordered sets of commands $A$ and $B$ we write $A\indep B$ if
for all $\alpha$ in $A$ and all $\beta$ in $B$, $\alpha\indep\beta$.
We also write $\alpha\indep B$ for $\{\alpha\}\indep B$.
\end{mydef}

It is intentional that we use the same symbol for independent commands
and sequences as for incomparable nodes. As the next
\namecref{incomparable_is_independent},
shows, these concepts are closely related.

\begin{mylem}\mlabel{incomparable_is_independent}
Two different commands that are not assertion commands are independent 
iff the nodes they change are incomparable. In other words,
\[ \cxynv\indep\czwmv \Longleftrightarrow n\unrel m \]
if $\cxynv\neq\czwmv$ and none of $\cxy$ and $\cxw$ is $\cbb$ or $\cdd$.
\end{mylem}
\begin{proof}
The right-to-left part is a restatement of
\cref{ax_separate_commute,ax_separate_nobreaks}.

We prove the left-to-right part by contradiction.
We assume that both $\cxynv\indep\czwmv$ and $n\nunrel m$,
and show that it leads to contradiction.
As $n\nunrel m$
we know that $n=m$, $n\descendant m$ or $m\descendant n$.

If $n=m$, then from \cref{ax_same_breaks} we know $[y]=[z]$ and $[w]=[x]$
as otherwise the commands, in one order or the other, would break all filesystems
and they could not be independent.
The commands are not assertion commands, so from \cref{ax_same_singlec}
we know that $\cxynv\cc\czwnv\equiv\czwnv\cc\cxynv$ can only happen if $y=w$.
% TODO Does this depend on |[D]|=1?
Therefore $[x]=[y]=[z]=[w]$ which with $y=w$ contradicts our assumption that the commands are different.

If $n\descendant m$ or $m\descendant n$, then
from \cref{ax_distantrel_breaks} we know that if they are not directly related,
then $\cxynv\cc\czwmv$ breaks all filesystems, and they cannot be independent.
From the construction and destruction pairs and 
\cref{ax_directchild_breaks,ax_directparent_breaks} we also see that
even if they are directly related, either
$\cxynv\cc\czwmv$ or $\czwmv\cc\cxynv$ 
breaks all filesystems, so they again cannot be independent.
\end{proof}

