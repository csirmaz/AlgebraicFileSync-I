

\section{Command Pairs and Sequences}\mlabel{section_axioms}

% Sequences
% ---------

So that we can describe the effects of commands independently of filesystems,
let us introduce some notation
and note some observations.
We already know that
commands usually do not occur in isolation,
and are applied to filesystems in time.
Therefore we investigate sequences of commands with a well-defined order.
\begin{mydef}[Sequences of commands: $\cc$ and $\emptyseq$]
We use ``$\cc$'' to combine commands to form a sequence, or combine sequences to form a longer sequence,
with the meaning that the sequence is executed from left to right:
\[ \alpha\cc\beta\aFS = \beta(\alpha\aFS). \]
%% monoid, but not free monoid
%% monoid: semigroup with identity element
%% Sequences of commands form a free semigroup
Sequences are also partial endofunctions on filesystems,
defined only if all commands they contain succeed in the given order.
Sequences form a monoid, and, as usual,
we write $\emptyseq$ to denote the unit element, the empty sequence,
which is defined on all filesystems and, by definition, leaves all filesystems unchanged.
\end{mydef}

\begin{mydef}[$\Dom{S}$]
For a sequence of commands $S$, $\Dom{S}$ is the domain of $S$, that is,
the set of filesystems $S$ does not break.
\end{mydef}


The following two relations 
echo the ones defined in \cite{NREC}.
In the definitions, $A,B,S$ and $T$ stand for arbitrary sequences.

\begin{mydef}[$\eqext$, $\strext$ and $\equiv$]
% Relation in the algebra
We write $A\eqext B$, or say that $B$ \emph{extends} $A$,
% intended interpretation:
to mean that they behave in the same way
on any filesystem $A$ does not break:
$\forall \FS\in\Dom{A}:\,A\aFS=B\aFS$.
% old inference rule: $ A\eqext B \Rightarrow S\cc A\cc T\eqext S\cc B\cc T$,
We can also see that $A\eqext B$ and $S\eqext T$ implies $A\cc S\eqext B\cc T$.
% symmetric:     aRb <=> bRa
% antisymmetric: aRb & bRa => a=b
% reflexive:     aRa
% transitive:    aRb & bRC => aRc
% preorder:      reflexive, transitive
% partial order: reflexive, transitive, antisymmetric
% equivalence:   reflexive, transitive, symmetric
% congruence:    https://en.wikipedia.org/wiki/Congruence_relation
% precongruence: congruence of a preorder
In other words, $\eqext$ is a preorder, and also a precongruence. % TODO

% Relation in the algebra
We write $A\equiv B$,
or say that $A$ and $B$ are \emph{equivalent,}
iff $A\eqext B$ and $B\eqext A$;
that is, $\equiv$ is the intersection of the preorder $\eqext$ with its inverse,
and so it is a congruence. % TODO
% old inference rule: $ A\equiv B \Rightarrow S\cc A\cc T\equiv S\cc B\cc T $.

Finally, we write $A\strext B$ to mean $A\eqext B$ and $A\nequiv B$.
In particular, we write $\wrks{A}$
to mean that $\Dom{A}$ is not empty, that is, if $A$ is defined on some filesystems.
\end{mydef}

It is easy to see that the equivalence $\equiv$ holds on the level of filesystems:
\begin{mylem}\mlabel{equiv_on_fs}
$A\equiv B$
iff $A$ and $B$ behave in the same way on
all filesystems, that is, $\forall \FS: A\aFS=B\aFS$.
\end{mylem}
\begin{proof}
As $A\equiv B$ means that both $A$ extends $B$ and $B$ extends $A$, it necessarily
follows that $A$ and $B$, as partial functions, are identical.
\end{proof}

% Rules
% -----

\myskip
Our aim is to derive information about the effects of sequences
of commands independently of the actual filesystems.
In order to make this possible, we investigate the smallest building
blocks of sequences: pairs of commands that act on a filesystem directly one after the other.
This approach is useful as there are a limited number of command pairs,
because, as we argued above, we can disregard the exact output values of commands apart from their type,
and we can also abstract the relationship between the nodes in the two commands
to a finite number of cases.
These properties of command pairs are crucial as they determine
how a set of commands can be re-ordered to be applied to a filesystem
during synchronization, and what command pairs will never be compatible.

% TODO \footnote{The program is accessible on-line at \\
% https://github.com/csirmaz/AlgebraicSyncPaper/blob/master/p2/prove.py.}

% TODO Rewrite script for new notation

\myskip
Command pairs in genral have the form
\[ \cxynv\cc  \czwmv \]
where $x,y,z,w\in\setv$ and $n,m\in\setn$. 

\begin{myax}\mlabel{ax_separate_commute}
Commands on incomparable nodes commute:
$\cxynv\cc\czwmv \equiv \czwmv\cc\cxynv$ where $n\unrel m$.
\end{myax}

\begin{myax}\mlabel{ax_separate_nobreaks}
Commands on incomparable nodes do not break all filesystems:
$\wrksx{\cxynv\cc\czwmv}$ where $n\unrel m$.
\end{myax}

\begin{myax}\mlabel{ax_same_breaks}
Commands on the same node break every filesystem if their types are incompatible:
$\cxynv\cc\czwnv \equiv \cbrk$ where $[y]\ne [z]$.
\end{myax}

\begin{myax}\mlabel{ax_same_emptyseq}
Commands on the same node simplify:
$\cxynv\cc\czwnv \eqext \emptyseq$ where $[y]=[z]$, and $\cxw=\cbb$ 
or $\cxw=\cdd$.
\end{myax}

\begin{myax}\mlabel{ax_same_singlec}
Commands on the same node simplify:
$\cxynv\cc \czwnv \equiv \cxwnv$ where $[y]=[z]$ and $\cxw\neq\cbb$ and $\cxw\neq\cdd$.
\end{myax}

\begin{myax}\mlabel{ax_distantrel_breaks}
Commands on distant relatives break all filesystems:
$\cxynnv\cc\czwnv \equiv \cbrk$
and $\czwnv\cc\cxynnv \equiv\cbrk$
where $\nn\descendant n$ and $\nn\neq\parent(n)$, and $\cxy\neq\cdd$ and $\czw\neq\cbb$.
(More intuitively, if $\czw\neq\cbb$ then either before or after $\czwnv$, the filesystem at
$n$ is not empty, and therefore there must be a directory at all ancestors of $n$, including at a child of $\nn$.
Consequently $\cxynnv$ will break the filesystem as either before or after it the filesystem at $\nn$
does not have a directory.)
\end{myax}

\begin{mydef}[Construction pair]
A pair of commands on nodes $\nn$ and $n$ is a construction pair if $\nn=\parent(n)$ 
and the commands are one
of the following:
   \begin{align*}
            \cbda{\nn}&\cc  \cbfa{n} \\
            \cbda{\nn}&\cc  \cbda{n} \\
            \cfda{\nn}&\cc  \caaa{\empt}{\valff}{n} \\
            \cfda{\nn}&\cc  \cbda{n}
   \end{align*}
\end{mydef}


\begin{myax}\mlabel{ax_directchild_breaks}
All other commands on a child break every filesystem:
$\cxynnv\cc\czwnv \equiv \cbrk$ where $\nn=\parent(n)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$
and the pair is not a construction pair.
As we shall see, this can be extended to \cref{simple_distant_pairs}.
TODO TO BE DELETED -- WE ONLY WANT TO USE \cref{simple_distant_pairs}
\end{myax}

\begin{mydef}[Destruction pair]
A pair of commands on nodes $n$ and $\nn$ is a destruction pair if $\parent(n)=\nn$ and the commands are one
of the following:
   \begin{align*}
            \cfba{n}&\cc  \cdba{\nn} \\
            \cfba{n}&\cc  \caaa{\vald}{\valff}{\nn} \\
            \cdba{n}&\cc  \cdba{\nn} \\
            \cdba{n}&\cc  \cdfa{\nn}
   \end{align*}
\end{mydef}

\begin{myax}\mlabel{ax_directparent_breaks}
All other commands on a parent break every filesystem:
$\cxynv\cc\czwnnv \equiv \cbrk$ where $\parent(n)=\nn$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$
and the pair is not a destruction pair.
This can also be extended to \cref{simple_distant_pairs}.
TODO TO BE DELETED -- WE ONLY WANT TO USE \cref{simple_distant_pairs}
\end{myax}

\begin{mydef}[Assertion command]
A command is an assertion command if
it leaves every filesystem in the same state
where it is defined.
In other words, assertion commands have the same input and output type,
and there must also be only one possible value for their output.
Accordingly, $\cbba{n}$ and $\cdda{n}$ are the only two types of assertion commands.
\end{mydef}

\begin{myax}\mlabel{ax_child_assert}
An assertion command can be added on a descendant node:
\[ \cbba{n}\cc\cxynnv \equiv \cxynnv \equiv \cxynnv\cc\cbba{n} \] 
where $\nn\descendant n$ and $\cxy\neq\cdd$.
(Note that this and next rule is true because the assertion command is
adjacent to the original command.)
\end{myax}

\begin{myax}\mlabel{ax_parent_assert}
An assertion command can be added on an ancestor node:
\[ \cdda{\nn}\cc\cxynv \equiv \cxynv \equiv \cxynv\cc\cdda{\nn} \]
where $\nn\descendant n$ and $\cxy\neq\cbb$.
\end{myax}

\begin{myax}\mlabel{ax_assert}
Assertion commands can be removed:
$\cdda{n}\eqext\emptyseq$ and $\cbba{n}\eqext\emptyseq$.
% $\cxynv \eqext \emptyseq$ where $\cxy=\cbb$ or $\cxy=\cdd$.
\end{myax}



% Independent commands
% --------------------

\myskip
We also define the concept of two commands being independent:

\begin{mydef}[$A\indep B$: Independent commands, sequences and sets of commands]\mlabel{def_indep}
Two commands $\cxynv$ and $\czwmv$ 
are independent, and we write $\cxynv\indep\czwmv$ if 
they commute and do not break all filesystems:
\[ \cxynv\cc\czwmv \equiv \wrksx{\czwnv\cc\cxynv}. \]
For two sequences or unordered sets of commands $A$ and $B$ we write $A\indep B$ if
for all $\alpha$ in $A$ and all $\beta$ in $B$, $\alpha\indep\beta$.
We also write $\alpha\indep B$ iff $\{\alpha\}\indep B$.
\end{mydef}

It is intentional that we use the same symbol for independent commands
and sequences as for incomparable nodes. As we will see in the next
\namecref{incomparable_is_independent},
these two concepts are closely related.

\begin{mylem}\mlabel{incomparable_is_independent}
Two different commands that are not assertion commands are independent iff the nodes they change are incomparable. In other words,
\[ \cxynv\indep\czwmv \Longleftrightarrow n\unrel m \]
if $\cxynv\neq\czwmv$ and none of $\cxy$ and $\cxw$ is $\cbb$ or $\cdd$.
\end{mylem}
\begin{proof}
This is easy to show based on the output of the program that investigates the behavior of command pairs.
However, this proposition can also be derived from the \namecrefs{ax_separate_commute} already listed
in the following way.

For the right-to-left part, we note that
from \cref{ax_separate_commute,ax_separate_nobreaks} we know that
if $n\unrel m$, then $\cxynv$ and $\czwmv$ must necessarily be independent.

We prove the left-to-right part by contradiction.
We assume that both $\cxynv\indep\czwmv$ and $n\nunrel m$,
and show that it leads to contradiction.
As $n\nunrel m$
we know that $n=m$, $n\descendant m$ or $m\descendant n$.

If $n=m$, then from \cref{ax_same_breaks} we know $[y]=[z]$ and $[w]=[x]$
as otherwise the commands, in one order or the other, would break all filesystems
and they could not be independent.
The commands are not assertion commands, so from \cref{ax_same_singlec}
we know that $\cxynv\cc\czwnv\equiv\czwnv\cc\cxynv$ can only happen if $y=w$.
% TODO Does this depend on |[D]|=1?
Therefore $[x]=[y]=[z]=[w]$ which with $y=w$ contradicts our assumption that the commands are different.

If $n\descendant m$ or $m\descendant n$, then
from \cref{ax_distantrel_breaks} we know that if they are not directly related,
then $\cxynv\cc\czwmv$ breaks all filesystems, and they cannot be independent.
From the construction and destruction pairs and 
\cref{ax_directchild_breaks,ax_directparent_breaks} we also see that
even if they are directly related, either
$\cxynv\cc\czwmv$ or $\czwmv\cc\cxynv$ 
breaks all filesystems, so they again cannot be independent.
\end{proof}

