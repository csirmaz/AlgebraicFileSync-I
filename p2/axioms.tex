

\section{Investigating Command Pairs}\mlabel{section_axioms}

% Sequences
% ---------

So that we can describe the effects of commands independently of filesystems,
let us introduce some notation
and note some observations.
We already know that
commands usually do not occur in isolation,
and are applied to filesystems in time.
Therefore we investigate sequences of commands with a well-defined order.
\begin{mydef}[Sequences of commands: $\cc$ and $\emptyseq$]
We use ``$\cc$'' to combine commands to form a sequence, or combine sequences to form a longer sequence,
with the meaning that the command on the left is applied first:
\[ \alpha\cc\beta\aFS = \beta(\alpha\aFS). \]
%% monoid, but not free monoid
%% monoid: semigroup with identity element
%% Sequences of commands form a free semigroup
Sequences are also partial endofunctions on filesystems,
defined only if all commands they contain succeed in the given order.
The sequences of commands form a monoid, and, as usual,
we write $\emptyseq$ for the unit element, the empty sequence,
which is defined on all filesystems and by definition leaves all filesystems unchanged.
\end{mydef}

\begin{mydef}[$\Dom{S}$ and $\Img{S}$]
For a sequence of commands $S$, $\Dom{S}$ is the domain of $S$.
We write $\Img{S}$ to denote the image of the domain of the sequence $S$.
\end{mydef}


The following two relations 
echo the ones defined in \cite{NREC}.
In the definitions, $A,B,S,T$ stand for arbitrary sequences.

\begin{mydef}[$\eqext$]
% Relation in the algebra
We write $A\eqext B$, or $B$ \emph{extends} $A$,
% intended interpretation:
to mean that they behave in the same way
on any filesystem $A$ does not break:
$\forall \FS\in\Dom{A}: A\aFS=B\aFS$.
% old inference rule: $ A\eqext B \Rightarrow S\cc A\cc T\eqext S\cc B\cc T$,
We can also see that $A\eqext B$ and $S\eqext T$ implies $A\cc S\eqext B\cc T$.
% preorder: reflexive and transitive
% patial order: reflexive, transitive and antisymmetric (aRb & bRa => a=b) TODO
In other words, $\eqext$ is a preorder, and also a precongruence.
\end{mydef}

\begin{mydef}[$\equiv$]
% Relation in the algebra
$A\equiv B$,
or $A$ and $B$ are \emph{equivalent,}
iff $A\eqext B$ and $B\eqext A$;
that is, $\equiv$ is the intersection of the preorder $\eqext$ with its inverse,
and so it is a congruence.
% symmetric: aRb <=> bRa
% reflexive: aRa
% transitive: aRb & bRC => aRc
% old inference rule: $ A\equiv B \Rightarrow S\cc A\cc T\equiv S\cc B\cc T $.
\end{mydef}

It is easy to see that this equivalence holds on the level of filesystems:

\begin{mylem}\mlabel{equiv_on_fs}
$A\equiv B$
iff $A$ and $B$ behave in the same way on
all filesystems, that is, $\forall \FS: A\aFS=B\aFS$.
\end{mylem}
\begin{proof}
% TODO APPENDIX
If $\forall \FS: A\aFS=B\aFS$, then $A\eqext B$ and $B\eqext A$ and so by definition $A\equiv B$.
For the reverse statement we know $A\eqext B$ and $B\eqext A$.
$B\eqext A$ implies that it is not possible for both $B\aFS\neq\fsbroken$ and $A\aFS=\fsbroken$ to be true.
Therefore, for every filesystem $\FS$, either $A\aFS\neq\fsbroken$, in which case $A\aFS=B\aFS$ as $A\eqext B$, or $A\aFS=\fsbroken$,
in which case $B\aFS=\fsbroken$ must be true, and therefore $A\aFS=B\aFS$.
\end{proof}

\begin{mydef}[$\strext$]
We write $A\strext B$ if $A\eqext B$ and $A\nequiv B$.
In particular, we write $\wrks{A}$ if $A$ is defined on some filesystems.
\end{mydef}

% Rules
% -----

Our aim is to derive information about the effects of sequences
of commands independently of the actual filesystems.
In order to make this possible, we investigate the smallest building
blocks of sequences: pairs of commands that act on a filesystem directly one after the other.
This approach is useful as there are a limited number of command pairs,
because, as we argued above, we can disregard the exact output values of commands apart from their type,
and we can also abstract the relationship between the nodes in the two commands
to a finite number of cases.

We methodically investigate all possibilities using a computer 
program\footnote{The program is accessible on-line at \\
https://github.com/csirmaz/AlgebraicSyncPaper/blob/master/p2/prove.py.}
to determine
which pairs of commands cause errors all the time,
which can be simplified to one command or $\emptyseq$,
and which commute and can be reversed without any change in their overall effect.
Our basis for this investigation was the model of filesystems introduced in this paper.
These properties of command pairs are crucial as they determine
how a set of commands can be re-ordered to be applied to a filesystem
during synchronization, and what commands will never be compatible.
Below we list a number of statements derived using this method,
which are in fact lemmas that can be derived from our definitions of filesystems and of commands.

% TODO Rewrite script for new notation

\bigskip

\noindent
Pairs of commands in general have the form
\[ \cxynv\cc  \czwmv \]
where $x,y,z,w\in\setv$ and $n,m\in\setn$. 

\begin{myax}\mlabel{ax_separate_commute}
Commands on incomparable nodes commute:
$\cxynv\cc\czwmv \equiv \czwmv\cc\cxynv$ where $n\unrel m$.
\end{myax}

\begin{myax}\mlabel{ax_separate_nobreaks}
Commands on incomparable nodes do not break all filesystems:
$\wrksx{\cxynv\cc\czwmv}$ where $n\unrel m$.
\end{myax}

\begin{myax}\mlabel{ax_same_breaks}
Commands on the same node break every filesystem if their types are incompatible:
$\cxynv\cc\czwnv \equiv \cbrk$ where $[y]\ne [z]$.
\end{myax}

\begin{myax}\mlabel{ax_same_emptyseq}
Commands on the same node simplify:
$\cxynv\cc\czwnv \eqext \emptyseq$ where $[y]=[z]$, and $\cxw=\cbb$ 
or $\cxw=\cdd$.
\end{myax}

\begin{myax}\mlabel{ax_same_singlec}
Commands on the same node simplify:
$\cxynv\cc \czwnv \equiv \cxwnv$ where $[y]=[z]$ and $\cxw\neq\cbb$ and $\cxw\neq\cdd$.
\end{myax}

\begin{myax}\mlabel{ax_distantrel_breaks}
Commands on distant relatives break all filesystems:
$\cxynnv\cc\czwnv \equiv \cbrk$
and $\czwnv\cc\cxynnv \equiv\cbrk$
where $\nn\descendant n$ and $\nn\neq\parent(n)$, and $\cxy\neq\cdd$ and $\czw\neq\cbb$.
(More intuitively, if $\czw\neq\cbb$ then either before or after $\czwnv$, the filesystem at
$n$ is not empty, and therefore there must be a directory at all ancestors of $n$, including at a child of $\nn$.
Consequently $\cxynnv$ will break the filesystem as either before or after it the filesystem at $\nn$
does not have a directory.)
\end{myax}

\begin{mydef}[Construction pair]
A pair of commands on nodes $\nn$ and $n$ is a construction pair if $\nn=\parent(n)$ 
and the commands are one
of the following:
   \begin{gather*}
            \cbdaa{\nn}\cc  \cbfaa{n} \\
            \cbdaa{\nn}\cc  \cbdaa{n} \\
            \cfdaa{\nn}\cc  \caaa{\empt}{\valff}{n} \\
            \cfdaa{\nn}\cc  \cbdaa{n}
   \end{gather*}
\end{mydef}


\begin{myax}\mlabel{ax_directchild_breaks}
All other commands on a child break every filesystem:
$\cxynnv\cc\czwnv \equiv \cbrk$ where $\nn=\parent(n)$ and $\cxy\neq\cdd$ and $\czw\neq\cbb$
and the pair is not a construction pair.
As we shall see, this can be extended to \cref{simple_distant_pairs}.
TODO TO BE DELETED -- WE ONLY WANT TO USE \cref{simple_distant_pairs}
\end{myax}

\begin{mydef}[Destruction pair]
A pair of commands on nodes $n$ and $\nn$ is a destruction pair if $\parent(n)=\nn$ and the commands are one
of the following:
   \begin{gather*}
            \cfba{n}\cc  \cdba{\nn} \\
            \cfba{n}\cc  \caaa{\vald}{\valff}{\nn} \\
            \cdba{n}\cc  \cdba{\nn} \\
            \cdba{n}\cc  \cdfaa{\nn}
   \end{gather*}
\end{mydef}

\begin{myax}\mlabel{ax_directparent_breaks}
All other commands on a parent break every filesystem:
$\cxynv\cc\czwnnv \equiv \cbrk$ where $\parent(n)=\nn$ and $\cxy\neq\cbb$ and $\czw\neq\cdd$
and the pair is not a destruction pair.
This can also be extended to \cref{simple_distant_pairs}.
TODO TO BE DELETED -- WE ONLY WANT TO USE \cref{simple_distant_pairs}
\end{myax}

\begin{mydef}[Assertion command]
A command is an assertion command if
it leaves every filesystem in the same state
where it is defined.
In other words, assertion commands have the same input and output type,
and there must also be only one possible value for their output.
Accordingly, $\cbba{n}$ and $\cdda{n}$ are the only two types of assertion commands.
\end{mydef}

\begin{myax}\mlabel{ax_child_assert}
An assertion command can be added on a descendant node:
\[ \cbba{n}\cc\cxynnv \equiv \cxynnv \equiv \cxynnv\cc\cbba{n} \] 
where $\nn\descendant n$ and $\cxy\neq\cdd$.
(Note that this and next rule is true because the assertion command is
adjacent to the original command.)
\end{myax}

\begin{myax}\mlabel{ax_parent_assert}
An assertion command can be added on an ancestor node:
\[ \cdda{\nn}\cc\cxynv \equiv \cxynv \equiv \cxynv\cc\cdda{\nn} \]
where $\nn\descendant n$ and $\cxy\neq\cbb$.
\end{myax}

\begin{myax}\mlabel{ax_assert}
Assertion commands can be removed:
$\cdda{n}\eqext\emptyseq$ and $\cbba{n}\eqext\emptyseq$.
% $\cxynv \eqext \emptyseq$ where $\cxy=\cbb$ or $\cxy=\cdd$.
\end{myax}



\bigskip

% Independent commands
% --------------------

\noindent
We also define the concept of two commands being independent:

\begin{mydef}[$A\indep B$: Independent commands, sequences and sets of commands]\mlabel{def_indep}
Two commands $\cxynv$ and $\czwmv$ 
are independent, and we write $\cxynv\indep\czwmv$ if 
they commute and do not break all filesystems:
\[ \cxynv\cc\czwmv \equiv \wrksx{\czwnv\cc\cxynv}. \]
For two sequences or unordered sets of commands $A$ and $B$ we write $A\indep B$ if
for all $\alpha$ in $A$ and all $\beta$ in $B$, $\alpha\indep\beta$.
We also write $\alpha\indep B$ iff $\{\alpha\}\indep B$.
\end{mydef}

It is intentional that we use the same symbol for independent commands
and sequences as for incomparable nodes. As we will see in the next
\namecref{incomparable_is_independent},
these two concepts are closely related.

\begin{mylem}\mlabel{incomparable_is_independent}
Two different commands that are not assertion commands are independent iff the nodes they change are incomparable. In other words,
\[ \cxynv\indep\czwmv \Longleftrightarrow n\unrel m \]
if $\cxy\neq\czw$ and none of $\cxy$ and $\cxw$ is $\cbb$ or $\cdd$.
\end{mylem}
\begin{proof}
This is easy to show based on the output of the program that investigates the behavior of command pairs.
However, this proposition can also be derived from the \namecrefs{ax_separate_commute} already listed
in the following way.

For the right-to-left part, we note that
from \cref{ax_separate_commute,ax_separate_nobreaks} we know that
if $n\unrel m$, then $\cxynv$ and $\czwmv$ must necessarily be independent.

We prove the left-to-right part by contradiction.
We assume that both $\cxynv\indep\czwmv$ and $n\nunrel m$,
and show that it leads to contradiction.
As $n\nunrel m$
we know that $n=m$, $n\descendant m$ or $m\descendant n$.

If $n=m$, then from \cref{ax_same_breaks} we know $[y]=[z]$ and $[w]=[x]$
as otherwise the commands, in one order or the other, would break all filesystems
and they could not be independent.
The commands are not assertion commands, so from \cref{ax_same_singlec}
we know that $\cxynv\cc\czwnv\equiv\czwnv\cc\cxynv$ can only happen if $y=w$.
% TODO Does this depend on |[D]|=1?
Therefore $[x]=[y]=[z]=[w]$ which with $y=w$ contradicts our assumption that the commands are different.

If $n\descendant m$ or $m\descendant n$, then
from \cref{ax_distantrel_breaks} we know that if they are not directly related,
then $\cxynv\cc\czwmv$ breaks all filesystems, and they cannot be independent.
From the construction and destruction pairs and 
\cref{ax_directchild_breaks,ax_directparent_breaks} we also see that
even if they are directly related, either
$\cxynv\cc\czwmv$ or $\czwmv\cc\cxynv$ 
breaks all filesystems, so they again cannot be independent.
\end{proof}

