
% Works
% -----

\subsection{Domains and Inverse Sequences}

\begin{mydef}[Sets of sequences]
As we will frequently refer to sets of fequences,
we will use calligraphic letters (e.g. $\sqs{A}$, $\sqs{B}$, $\sqs{C}$ and $\sqs{S}$)
to denote such sets for brevity.

We will write $\Dom{\sqs{A}}$ for $\bigcap_{A\in\sqs{A}} \Dom{A}$,
and $\sqs{A}\cc\sqs{B}$ for $\{A\cc B\whr A\in\sqs{A}, B\in\sqs{B}\}$.
We will also use $A\cc\sqs{B}$ with the meaning $\{A\}\cc\sqs{B}$.

% This has only been defined for sequences, not sets.
Moreover, we write $\wrks{\sqs{A}}$ if $\varnothing \subset \Dom{\sqs{A}}$, that is,
if we know that there is at least one filesystem
all sequences in $\sqs{A}$ are defined on.
\end{mydef}

% works operators
% ---------------

\begin{mydef}[$\worksmeqsign$]\label{def_works}
For two sets of sequences $\sqs{A}$ and $\sqs{B}$
we write $\worksm{\sqs{A}}{\sqs{B}}$ iff $\Dom{\sqs{A}} \subseteq \Dom{\sqs{B}}$;
that is, iff all sequences in $\sqs{B}$ are defined on (do not break)
all filesystems on which sequences in $\sqs{A}$ are defined.

We also apply these relations to sequences directly;
e.g. we write
$\worksm{A}{B}$ with the meaning $\Dom{A} \subseteq \Dom{B}$.
\end{mydef}

In a sense, $A\worksmeqsign B$ is a weaker counterpart of $A\eqext B$, as the former
only requires that $B$ is defined where $A$ is defined, 
while the latter also requires
that where they are defined, their effect is the same.
It is easy to see that the following corollary is true:

\begin{mycor}\label{worksextpostfix}
% An inference rule in the algebra
$\forall A,S: \worksm{A\cc S}{A}$, that is, if a sequence is defined,
its initial segment is also defined.
\end{mycor}

We also prove the following lemmas.

\begin{myax}\label{combine_independent_commands}
The combination of independent commands is defined on all filesystems
where both of the commands are defined:
\[ \alpha\indep \beta \Rightarrow \worksm{\{\alpha, \beta\}}{\{\alpha\cc \beta\}}. \]
\end{myax}
\begin{proof}
We name this proposition a \namecref{combine_independent_commands} 
because to prove it, we must reach back to our filesystem model.
Let $\alpha=\cxynv$ and $\beta=\czwmv$.
We prove the proposition by contradiction and
assume that there is a filesystem $\FS$ for which
$\cxynv\aFS\neq\fsbroken$ and $\czwmv\aFS\neq\fsbroken$, but
$\cxynv\cc \czwmv\aFS=\fsbroken$.
We know $\cxynv\aFS\neq\fsbroken$ so it must be applying 
$\czwmv$ that breaks it.
Applying a command can only result in a broken filesystem in two cases.
First, if the input type does not match the filesystem,
but we know $[\FS(m)]=[w]$ and so
$[(\cxynv\aFS)(m)]=[w]$ as based on \cref{incomparable_is_independent}, $n\neq m$.
Second, if the new filesystem violates the tree property.
This again cannot be the case because we also know that $n\unrel m$
and the tree property only depends on the types of values at the parent and children of $m$,
which therefore cannot be changed by $\cxynv$.
\end{proof}

This result can be extended to sequences:

\begin{mylem}\label{combine_independent_sequences}
The combination of independent sequences is defined on all filesystems
where both of the sequences are defined:
\[ S\indep T \Rightarrow \worksm{\{S,T\}}{\{S\cc T\}}. \]
\end{mylem}
\begin{proof}
Assume that there is a filesystem $\FS$ so that
$S\aFS\neq\fsbroken$ and $T\aFS\neq\fsbroken$, but
$(S\cc T)\FS=\fsbroken$.

From \cref{def_indep} we know that
the commands in $S$ and $T$ pairwise commute, and so any sequence
that contains the commands from $S$ and $T$ and preserve their original partial order
is equivalent to $S\cc T$ on all filesystems.

Let the command in $T$ that breaks $\FS$ when applying $S\cc T$ be $t$
so that $T=T_0\cc t\cc T_1$.
It is still true that $(T_0 \cc t)\FS\neq\fsbroken$,
and by definition $(S\cc T_0)\FS\neq\fsbroken$,
but $(S\cc T_0\cc t)\FS=\fsbroken$.
Also, from above we know that $S\cc T_0\equiv T_0\cc S$
and so $(T_0 \cc S)\FS\neq\fsbroken$.

If we denote the first command in $S$ with $s_1$,
this means that $(T_0 \cc s_1)\FS\neq\fsbroken$,
which we can combine with $(T_0 \cc t)\FS\neq\fsbroken$, $t\indep s_1$ and
\cref{combine_independent_commands}
(using $T_0\FS$ as the reference filesystem)
to arrive at $(T_0 \cc s_1\cc t)\FS\neq\fsbroken$.

We can repeat this step for $s_2$, the next command in $S$,
and from 
$(T_0 \cc s_1\cc t)\FS\neq\fsbroken$
and
$(T_0 \cc s_1\cc s_2)\FS\neq\fsbroken$
arrive at
$(T_0 \cc s_1\cc s_2\cc t)\FS\neq\fsbroken$.
This can be repeated until $S$ is exhausted and we get
$(T_0 \cc S\cc t)\FS\neq\fsbroken$, which is a contradiction.
\end{proof}

We also prove the following:

\begin{mylem}\label{worksinputmatch}
If $S$ and $T$ are minimal sequences, $\worksmnil{\{A,B\}}$,
and there are commands on node $n$ in both $S$ ($\cxynv\in A$) and $T$ ($\czwnv\in B$),
then the input types of these commands must match ($[x]=[z]$).
\end{mylem}
\begin{proof}
This result is similar to \cref{equiv_simple_same_commands} and
is easily shown using a proof by contradiction: if $[x]\neq [z]$, then there is no filesystem that
either $\cxynv$ or $\czwnv$ would not break, 
and consequently $S$ and $T$ cannot work on the same filesystem.
\end{proof}


\bigskip

% Type equivalence classes
% ------------------------

\noindent
For the proof of the correctness of the reconciliation algorithm,
we will also need a way of moving parts of sequences between the two
sides of the $\worksmeqsign$ relation.
We can do this based on the observation that commands are bijections
if we only distinguish between types in our objects.
To formalise this, we extend type equality ($\typeeq$)
to filesystems, commands and sequences of commands.
\begin{mydef}[Equivalence by type, extended: $\typeeq$]
$ $ % otherwise first list element starts on same line
\begin{itemize}
\item For two filesystems $\FS\typeeq\GS$ iff they share the same nodes $\setn$,
and for all $n\in\setn$, $\FS(n) \typeeq \GS(n)$.
\item For two commands $\cxynv\typeeq\czwmv$ iff 
$x\typeeq z$ and $y\typeeq w$
(that is, $[x]=[z]$ and $[y]=[w]$)
and $n=m$.
\item For two sequences of commands $\emptyseq\typeeq\emptyseq$, and
if $A'=\alpha\cc A$ and $B'=\beta\cc B$, then $A'\typeeq B'$ iff $\alpha\typeeq\beta$ and $A\typeeq B$.
\end{itemize}
\end{mydef}

We select representatives of each $\typeeq$-equivalence class of values:
for $[\empt]$ and $[\vald]$ this must be $\empt$ and $\vald$; and
for $[\valf]$ we select an arbitrary file value $\fil\in[\valf]$.
We then use these representative values to
introduce the canonical mapping $\T$ that preserves the types of values,
but maps all objects into a subsystem where there is a one-to-one
correspondence between types and values.

\begin{mydef}[$\T$]\label{def_typemapping}
We use $\T$ and write $a\T$ to denote the canonical mapping of 
values, filesystems, commands and sequences to the
representatives of their $\typeeq$-equivalence class.
\begin{itemize}
\item For values, $\vald\T=\vald$, $\valf\T=\fil$ and $\empt\T=\empt$.
\item For filesystems, $\FS\T$ is defined by $\FS\T(n) = \FS(n)\T$.
\item For commands, $\cbrk\T=\cbrk$ and $\cxynv\T = \cTxynv$.
\item For sequences of commands, $\emptyseq\T=\emptyseq$, and if $S'=\alpha\cc S$, then $S'\T=\alpha\T\cc S\T$.
\item Finally we extend $\T$ to sets of sequences: $\sqs{A}\T = \{S\T \whr S\in\sqs{A}\}$.
\end{itemize}
\end{mydef}

By definiton,
for any filesystem $\FS$ and command $\alpha$, 
$\alpha\T(\FS\T) = (\alpha\aFS)\T$.


% TODO ???
Also, for all objects where it is defined, $a\T\typeeq a$.
As representatives of filesystems, commands, sequences, etc.
are subsets of their non-representative counterparts, 
all propositions proven so far apply to them as well.

% It is easy to see that 
% $A\equiv B \Rightarrow A\T\equiv B\T$ 
% and
% $A\eqext B \Rightarrow A\T\eqext B\T$,
% but the reverse is not true as 
% $A\T$ and $B\T$ will have the same effect on all filesystems
% if $A$ and $B$ differ only in some of the values in their commands,
% whereas clearly $A\nequiv B$.

As the types of values determine whether a command breaks a filesystem,
we know $\Dom{A}=\Dom{A\T}$ and therefore $\Dom{\sqs{A}}=\Dom{\sqs{A}\T}$.
From this it follows that
% TODO what's the set of all filesystems?

\begin{mycor}\label{repr_works_is_same}
\begin{gather*}
\worksmnil{\sqs{A}} \Longleftrightarrow \worksmnil{\sqs{A}\T} \\
\worksm{\sqs{A}}{\sqs{B}} \Longleftrightarrow \worksm{\sqs{A}\T}{\sqs{B}\T}.
\end{gather*}
\end{mycor}

% Inverse commands
% ----------------

We are now ready to define the inverse of representative commands $\alpha\T$
which allows us to move parts of sequences between the
two sides of $\worksmeqsign$.
This is based on the following observation.

% TODO \alpha \neq \cbrk
\begin{mylem}\label{repr_comm_inject}
Representative commands $\alpha\T$ are partial bijections over representative filesystems
($\FS\T$, $\GS\T$).
Because partial functions are trivially surjective when restricted to their images, this is
equivalent to saying that representative functions are injective except for cases
where they are not defined:
\begin{align*}
\forall\FS,\GS,\alpha:& \\
& \FS\T\neq\GS\T \wedge \alpha\T(\FS\T)\neq\fsbroken \\
& \Rightarrow \alpha\T(\FS\T) \neq \alpha\T(\GS\T).
\end{align*}
\end{mylem}
\begin{proof}
Choose values that satisfy the left side, and let $\alpha\T = \cTxynv$.
If $\FS\T$ and $\GS\T$ have different values (types) at any node apart from $n$, then this difference remains
even after applying $\cTxynv$ to $\FS\T$. 
The only remaining case therefore is where they have the same values
at all nodes except at $n$.
As $\cTxynv(\FS\T)\neq\fsbroken$, we know $[\FS(n)]=[x]$.
We also know that $\GS\T(n)\neq\FS\T(n)$, and therefore
$[\GS(n)]\neq[x]$.
This implies $\cTxynv(\GS\T)=\fsbroken$,
and again we have $\alpha\T(\FS\T) \neq \alpha\T(\GS\T)$.
\end{proof}

% See
% https://en.wikipedia.org/wiki/Inverse_semigroup#Origins
% https://en.wikipedia.org/wiki/Symmetric_inverse_semigroup
% https://en.wikipedia.org/wiki/Partial_function

\begin{mydef}[Inverse commands and sequences]
We write $\alpha\T^{-1}$ for
the inverse of the representative command (partial bijection) $\alpha\T$.

We write ${S\T}^{-1}$ for the inverse of the sequence $S\T$, which consists of the inverses of the commands in $S\T$
in reverse order.
\end{mydef}
By definition, for any representative filesystem $\FS\T$ outside the image of $\alpha\T$, the inverse $\alpha\T^{-1}$ is not defined.

% Some further observations:
% For representative commands \[ \cTxynv^{-1} = \cTyxnv. \]
% $\forall S: ({S\T}^{-1})^{-1} = S\T$.

For brevity, in the following lemma we use $B$, $B'$, $\sqs{A}$ and $\sqs{C}$ to denote
representative sequences and sets.

\newcommand{\ia}{\sqs{A}}
\newcommand{\ic}{\sqs{C}}
\newcommand{\ibi}{B^{-1}}

\begin{mylem}\label{r_invmove}
A common initial segment of a set of representative sequences can be moved 
to the other side of $\worksmeqsign$ by inverting it:
\begin{gather*}
\worksm{\ia}{B\cc\ic}
\ \Longleftrightarrow \ \worksm{\ibi\cc\ia}{\ic} 
\ \wedge \  \worksm{\ia}{\{B\}}
\end{gather*}
\end{mylem}
\begin{proof}
% This result is quite expected as we're mapping a subset statement using a bijection,
% but made more complicated a as B is not defined everywhere.

The proof is illustrated by \cref{fig_invmove}.

\begin{figure}[htb]
\input{fig-inverse-works}
\caption{Proof of \cref{r_invmove}}\label{fig_invmove}
\end{figure}

For the left-to-right part of the proposition,
from $\worksm{\ia}{B\cc\ic}$ we know $\Dom{\ia} \subseteq \Dom{B\cc\ic}$.
As the (representative) $B$ is a bijection between its domain and image,
we can use $B$ to map both sides of this statement, which yields
$\Dom{B^{-1}\cc\ia} \subseteq \Dom{\ibi\cc B\cc\ic}$,
but the latter is a subset of $\Dom{\ic}$,
and so $\Dom{\ibi\cc\ia} \subseteq \Dom{\ic}$,
which means that $\worksm{\ibi\cc\ia}{\ic}$.
It is easy to see that $\worksm{\ia}{B\cc\ic} \Rightarrow \worksm{\ia}{\{B\}}$.

For the right-to-left part,
from $\worksm{\ia}{\{B\}}$ we know $\Dom{\ia} \subseteq \Dom{B}$.
Therefore we can project the whole of $\Dom{\ia}$ using the bijective representative sequence $B$
to get $\Dom{\ibi\cc\ia}$, and as $\worksm{\ibi\cc\ia}{\ic}$
we know
$\Dom{\ibi\cc\ia} \subseteq \Dom{\ic}$.
We use $\ibi$ to project both sides of this statement to get
$\Dom{B\cc\ibi\cc\ia} \subseteq \Dom{B\cc\ic}$.
But we also know that $\Dom{B\cc\ibi\cc\ia} = \Dom{\ia}$
as $\Dom{\ia} \subseteq \Dom{B}$,
and so $\Dom{\ia} \subseteq \Dom{B\cc\ic}$ which means
$\worksm{\ia}{B\cc\ic}$.
\end{proof}

We use this result to prove the following:

\begin{mylem}\label{indep_prefix_combine}
The combination of two sequences with a common head and independent tails 
is defined wherever the two sequences are defined:
\[ B\indep C \Rightarrow \worksmbb{A\cc B, A\cc C}{A\cc B\cc C} \]
\end{mylem}
\begin{proof}
This is trivial unless $\worksmnil{A}$, so we assume that that is the case.
From $B\indep C$ and \cref{combine_independent_sequences} we know
$\worksmbb{B, C}{B\cc C}$.
Based on \cref{repr_works_is_same} this is equivalent to
$\worksmbb{B\T, C\T}{B\T\cc C\T}$.
Since $A\T^{-1}\cc A\T \equiv \emptyseq$, this can also be written as
\[\worksmxb{A\T^{-1}\cc\{A\T\cc B\T, A\T\cc C\T\}}{B\T\cc C\T}.\]
From \cref{worksextpostfix} we also know that
$\worksmbb{A\T\cc B\T, A\T\cc C\T}{A\T}$.
Combining the last two statements using \cref{r_invmove}
we get
\[ \worksmbb{A\T\cc B\T, A\T\cc C\T}{A\T\cc B\T\cc C\T}, \]
which with \cref{repr_works_is_same} proves the
\namecref{indep_prefix_combine}.
\end{proof}
