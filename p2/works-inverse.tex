
% Works
% -----

\subsection{Conditional Operation and Inverse Sequences}

\begin{mydef}[$\works{x}$]
% Unsure if this relation should be in the algebra.
For a set of $k$ sequences
$\works{A_1,A_2,\ldots,A_k}$ means that 
$A_1,A_2,\ldots,A_k$ work at the same time, that is,
% intended interpretation:
\[\exists \FS: A_1\FS\neq\fsbroken \wedge \cdots \wedge A_k\FS\neq\fsbroken.\]
As the sequences form a set, their order is irrelevant.
% inference rules:
We also know that $\works{A} \Leftrightarrow A\nequiv \cbrk$. 
\end{mydef}

\begin{mydef}[$\worksc{x}{y}$]
For two sets of sequences, $\worksc{A_1,A_2,\ldots,A_k}{B_1,B_2,\ldots,B_l}$ means that 
all of $A_1,\ldots,A_k$ work where all of $B_1,\ldots,B_l$ work,
that is,
% intended interpretation:
\begin{align*}
\forall \FS:{}& 
B_1\FS\neq\fsbroken \wedge \cdots \wedge B_k\FS\neq\fsbroken\\
&\Rightarrow\\
&A_1\FS\neq\fsbroken \wedge \cdots \wedge A_l\FS\neq\fsbroken.
\end{align*}
As above, the order of the sequences in the sets is not relevant.
\end{mydef}

\begin{mydef}[Sets of sequences]
As we will frequently refer to sets of fequences,
we will use calligraphic letters (e.g. $\seqset{A, B, C}$ and $\seqset{S}$)
to denote such sets for brevity.
We will use $A\cc\seqset{B}$ to denote the set of sequences $\{A\cc B|B\in\seqset{B}\}$.
\end{mydef}

It is easy to see that the following corollaries are true:

% An inference rule in the algebra
% $\worksc{X}{X}$ is always true for any set of sequences $X$,

% \begin{mycor}
% % An inference rule in the algebra
% $B\eqext A \Rightarrow \worksc{A}{B}$.
% \end{mycor}

\begin{mycor}\label{worksextpostfix}
% An inference rule in the algebra
$\forall A,S: \worksc{A}{A\cc S}$, that is, if a sequence works, its initial segment also works.
\end{mycor}

\begin{mycor}\label{workschained}
% An inference rule in the algebra
$\workssign$ can be chained:
if $\seqset{A'}\subset\seqset{A}$, then
$ \worksc{\seqset{C}}{\seqset{A'}} \wedge \worksc{\seqset{A}}{\seqset{B}} \Rightarrow \worksc{\seqset{A}\cup\seqset{C}}{\seqset{B}}$.
\end{mycor}

We also prove the following lemmas.

\begin{myax}\label{combine_independent_commands}
The combination of independent commands works wherever the original commands work:
\[ \cxynv\indep \czwmv \Rightarrow \worksc{\cxynv\cc \czwmv}{\cxynv, \czwmv}. \]
% \begin{align*}
% \forall\FS:{}&\cxynv\indep \czwmv \\
% &\quad\wedge \cxynv\aFS\neq\fsbroken \\
% &\quad\wedge \czwmv\aFS\neq\fsbroken \\
% &\Rightarrow \cxynv\cc \czwmv\aFS\neq\fsbroken.
% \end{align*}
\end{myax}
\begin{proof}
We name this proposition a \namecref{combine_independent_commands} 
because to prove it, we must reach back to our filesystem model.
We proceed in an indirect way and
assume that there is a filesystem $\FS$ for which
$\cxynv\aFS\neq\fsbroken$ and $\czwmv\aFS\neq\fsbroken$, but
$\cxynv\cc \czwmv\aFS=\fsbroken$.
We know $\cxynv\aFS\neq\fsbroken$ so it must be applying 
$\czwmv$ that breaks it.
Applying a command can only result in a broken filesystem in three cases.
First, if the filesystem was already broken, which cannot be the case here.
Second, if the input type does not match the filesystem,
but we know $\FS(m)\in\setvx{W}$ and so
$(\cxynv\aFS)(m)\in\setvx{W}$ as based on \cref{incomparable_is_independent}, $n\neq m$.
Third, if the new filesystem violates the tree property.
This again cannot be the case because we also know that $n\unrel m$
and the tree property only depends on the types of the parent and children of $m$,
which therefore cannot be changed by $\cxynv$.
\end{proof}

This result can be extended to sequences:

\begin{mylem}\label{combine_independent_sequences}
The combination of independent sequences works wherever the original sequences work:
\[ S\indep T \Rightarrow \worksc{S\cc T}{S,T}. \]
\end{mylem}
\begin{proof}
Assume that there is a filesystem $\FS$ so that
$S\aFS\neq\fsbroken$ and $T\aFS\neq\fsbroken$, but
$(S\cc T)\FS=\fsbroken$.

From \cref{incomparable_is_independent,ax_separate_commute} we know that
the commands in $S$ and $T$ pairwise commute, and so any sequence
that contains the commands from $S$ and $T$ and preserve their original partial order
is equivalent to $S\cc T$ on all filesystems.

Let the command that breaks $\FS$ in $T$ when applying $S\cc T$ be $t$
so that $T=T_0\cc t\cc T_1$.
It is still true that $(T_0 \cc t)\FS\neq\fsbroken$,
and by definition $(S\cc T_0)\FS\neq\fsbroken$,
but $(S\cc T_0\cc t)\FS=\fsbroken$.
Also, from above we know that $S\cc T_0\equiv T_0\cc S$
and so $(T_0 \cc S)\FS\neq\fsbroken$.

If we denote the first command in $S$ with $s_1$,
this means that $(T_0 \cc s_1)\FS\neq\fsbroken$,
which we can combine with $(T_0 \cc t)\FS\neq\fsbroken$, $t\indep s_1$ and
\cref{combine_independent_commands}
(using $T_0\FS$ as the reference filesystem)
to arrive at $(T_0 \cc s_1\cc t)\FS\neq\fsbroken$.

We can repeat this step for $s_2$, the next command in $S$,
and from 
$(T_0 \cc s_1\cc t)\FS\neq\fsbroken$
and
$(T_0 \cc s_1\cc s_2)\FS\neq\fsbroken$
arrive at
$(T_0 \cc s_1\cc s_2\cc t)\FS\neq\fsbroken$.
This can be repeated until $S$ is exhausted and we get
$(T_0 \cc S\cc t)\FS\neq\fsbroken$, which is a contradiction.
\end{proof}

We also prove the following:

\begin{mylem}\label{worksinputmatch}
If $A$ and $B$ are minimal sequences, $\works{A,B}$,
and there are commands on node $n$ in both $A$ ($\cxynv\in A$) and $B$ ($\czwnv\in B$),
then the input types of these commands must match ($X=Z$).
\end{mylem}
\begin{proof}
This result is similar to \cref{equiv_simple_same_commands} and
is easily shown using an indirect proof: if $X\neq Z$, then there is no filesystem that
either $\cxynv$ or $\czwnv$ would not break, 
and consequently $A$ and $B$ cannot work on the same filesystem.
\end{proof}


\bigskip

\noindent
We know that whether commands break a filesystem depends solely on their input and output
types and the node, but not their actual output value.
To represent this, we introduce an equivalence relation between filesystems, commands
and sequences of commands.
\begin{mydef}[Equivalence by type: $\typeeq$]
$ $ % otherwise first list element starts on same line
\begin{itemize}
\item For two filesystems we write $\FS\typeeq\GS$ iff they share the same nodes,
and at all nodes the types of their values are the same, or they are both broken.
\item For two commands we write $\alpha\typeeq\beta$ iff their input and output values,
and the node they operate on are the same.
\item For two sequences of commands we write $A\typeeq B$ iff they contain the same number of commands,
and pairwise the commands $\alpha\in A$ and $\beta\in B$ at the same indices are equivalent by type ($\alpha\typeeq\beta$).
\end{itemize}
\end{mydef}

This relation gives rise to equivalence classes of filesystems, commands, and sequences of commands,
each of which is associated with a new type of filesystem, command or sequence of commands in which
only types are noted, but not values.
(This is also equivalent to assuming $|\setf|=1$.)
We will call these constructs valueless.

\begin{mydef}[Valueless constructs]
$ $
\begin{itemize}
\item For any filesystem $\FS$, we write $\FS\T$ to denote the valueless filesystem assiociated with
the equivalenve class of $\FS$ by $\typeeq$; that is, where at each node $n$, $\FS\T$ contains the type of
$\FS(n)$. In general, a valueless filesystem is one where each node
is associated with a type, but not a value:
\begin{gather*}
\FS\T =
\begin{cases}
\setn \rightarrow \typeset \\
\fsbroken
\end{cases}
\end{gather*}

\item Similarly, for any command $\cxynv$ we write $\cxynv\T$ to denote the valueless command
$\cTxyn$, represented by a triple of the input type, output type and node.
The command $\cbrk$ has a separate valueless version, $\cbrk\T$.

\item Also, for any sequence of commands $S$ we write $S\T$ to denote the sequence of
valueless commands associated with the commands in $S$ in the same order; and for a set of sequences $\seqset{S}$
we write $\seqset{S}\T$ for $\{S\T|S\in\seqset{S}\}$.

\end{itemize}
\end{mydef}

A valueless command can be applied to a valueless filesystem with the expected outcome
that $\cTxyn$ will replace the type at $n$ with $Y$ 
if the original type was $X$ and the tree property still holds after the replacement.
This means that
the mapping $\T$ can be extended further to the 
the relations $\equiv$, $\eqext$ and $\workssign$, where
${\equiv}\T$, ${\eqext}\T$ and $\workssign\T$ hold or do not hold for sequences of valueless commands
depending on their behavior on valueless filesystems.

It is easy to see that 
$A\equiv B \Rightarrow A\T{\equiv}\T B\T$ 
and
$A\eqext B \Rightarrow A\T{\eqext}\T B\T$,
but the reverse is not true as 
$A\T$ and $B\T$ will have the same effect on all $\FS\T$
if $A$ and $B$ differ only in some of the values in their commands,
whereas clearly $A\nequiv B$.

With $\workssign$, however, the situation is different, as it only
depends on whether sequences break filesystems or not. Therefore the followings hold:
\begin{mycor}
\begin{gather*}
\works{\seqset{A}} \Leftrightarrow \worksT{\seqset{A}\T} \\
\worksc{\seqset{A}}{\seqset{B}} \Leftrightarrow \workscT{\seqset{A}\T}{\seqset{B}\T}
\end{gather*}
\end{mycor}

% ==================================================

We continue by defining inverse commands and sequences
which allow us to move parts of sequences between the
condition and consequence parts of $\workssign$.

\begin{mydef}[Inverse commands and sequences]
The inverse of command $\cxynv$ is $\cxynv^{-1} = \caaaa{Y}{X}{n}{\valvx}$
where $\valvx$ is an arbitrary value from $\setvx{X}$.
We write $S^{-1}$ for the inverse of sequence $S$, which consists of the inverses of the commands in $S$
in reverse order.
\end{mydef}


From the definitions we can clearly see that
\begin{mycor}\label{negneg_is_typeeq}
$\forall S, \FS: (S^{-1})^{-1}\aFS\typeeq S\aFS$.
\end{mycor}

\begin{mylem}\label{r_invmove}
A common initial segment of a set of sequences can be moved to the other side of $\workssign$ by inverting it:
\begin{gather*}
\worksc{B\cc \seqset{A}}{\seqset{C}} \Rightarrow \worksc{\seqset{A}}{B^{-1}\cc \seqset{C}} \\
\worksc{\seqset{A}}{B\cc \seqset{C}} \Rightarrow \worksc{B^{-1}\cc \seqset{A}}{\seqset{C}}
\end{gather*}
\end{mylem}
\begin{proof}
This is based on the fact that in our model, unless they break a filesystem,
commands leave the type of the filesystem value unchanged 
or change one type into another, but never merge types.
That is,
sequences---as functions mapping filesystems to filesystems---are
essentially bijections over type-equality ($\typeeq$)
with the only ``sink'' being $\fsbroken$:
\begin{align*}
\forall S,\FS,\GS:{}&S\aFS\neq\fsbroken \Rightarrow \\
&(S\aFS\ntypeeq S\aGS \Longleftrightarrow \FS\ntypeeq \GS).
\end{align*}

For the proposition
\[ \worksc{B\cc \seqset{A}}{\seqset{C}} \Rightarrow \worksc{\seqset{A}}{B^{-1}\cc \seqset{C}} \]
the rest of the proof is illustrated by \cref{fig_invmove}
where $\textrm{Dom}(x)$, the domain of $x$, represents the set of filesystems
the sequence $x$ does not break, or neither of the sequences in the set $x$ breaks.

\begin{figure}[htb]
\input{fig-inverse-works}
\caption{Proof of \cref{r_invmove}}\label{fig_invmove}
\end{figure}

We see that the set of filesystems the sequences in $\seqset{A}$ do not break intersect with the range of $B$.
As $B$ is a bijection between its domain and range, we can use $B^{-1}$ to map this intersection back
onto the domain of $B$.
As $\worksc{B\cc \seqset{A}}{\seqset{C}}$ the domain of $\seqset{C}$ must be a subset of this
projected intersection.
If so, then we can use $B$ to map the domain of $\seqset{C}$, which yields the domain of $B^{-1}\cc \seqset{C}$.
As it is also a part of the domain of $A$, we get $\worksc{\seqset{A}}{B^{-1}\cc \seqset{C}}$.

The second part of the lemma can be proven in a similar way.
\end{proof}


\begin{mylem}\label{indep_prefix_combine}
The combination of sequences with a common head and independent tails 
continues to work under the same conditions:
\[ \worksc{A\cc B}{\seqset{S}} \wedge \worksc{A\cc C}{\seqset{S}} \wedge B\indep C \Rightarrow \worksc{A\cc B\cc C}{\seqset{S}} \]
\end{mylem}
\begin{proof}
Based on \cref{r_invmove} we know
$\worksc{B}{A^{-1}\cc \seqset{S}}$ and $\worksc{C}{A^{-1}\cc \seqset{S}}$,
and from \cref{combine_independent_sequences} we know
$\worksc{B\cc C}{B,C}$.
Combining these using \cref{workschained}
we get
$\worksc{B\cc C}{A^{-1}\cc \seqset{S}}$. 
Finally, applying the second line of \cref{r_invmove} yields
$\worksc{(A^{-1})^{-1}\cc B\cc C}{\seqset{S}}$, which proves our lemma 
as $\forall\FS: (A^{-1})^{-1}\aFS\typeeq A\aFS$ (\cref{negneg_is_typeeq}).
\end{proof}
