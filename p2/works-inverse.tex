
% Works
% -----

\subsection{Domains of Sets}

\begin{mydef}[Sets of sequences]
As we will frequently refer to sets of fequences,
we will use calligraphic letters (e.g. $\sqs{A}$, $\sqs{B}$, $\sqs{C}$ and $\sqs{S}$)
to denote such sets for brevity.

We will write $\Dom{\sqs{A}}$ for $\bigcap_{A\in\sqs{A}} \Dom{A}$,
and $\sqs{A}\cc\sqs{B}$ for $\{A\cc B\whr A\in\sqs{A}, B\in\sqs{B}\}$.
\end{mydef}

% works operators
% ---------------

\begin{mydef}[$\worksmeqsign$]\mlabel{def_works}
For two sets of sequences $\sqs{A}$ and $\sqs{B}$
we write $\worksm{\sqs{A}}{\sqs{B}}$ iff $\Dom{\sqs{A}} \subseteq \Dom{\sqs{B}}$;
that is, iff all sequences in $\sqs{B}$ are defined on (do not break)
all filesystems on which sequences in $\sqs{A}$ are defined.
\end{mydef}

When $\sqs{A}$ or $\sqs{B}$ contains a single sequence,
we leave out the curly brackets and write,
e.g. $A\cc\sqs{B}$ to mean $\{A\}\cc\sqs{B}$,
or $\worksm{A}{B}$ to mean $\worksmbb{A}{B}$.

Also, we write $\worksmnil{\sqs{A}}$ to mean that
there are filesystems on which all sequences in $\sqs{A}$ are defined.
If $\sqs{A}$ contains a single sequence only, $A$, this is equivalent to $\wrks{A}$.

We can see that $A\eqext B$ implies $\worksm{A}{B}$, as the latter
only requires that $B$ is defined where $A$ is defined, 
while the former also requires
that where they are defined, their effect is the same.

The following claims follow from the definition:

\begin{myclm}\mlabel{worksextpostfix}
% An inference rule in the algebra
$\forall A,S: \worksm{A\cc S}{A}$, that is, if a sequence is defined,
its initial segments are also defined.
\end{myclm}

\begin{myclm}\mlabel{works_restricted}
$\forall \sqs{A},\sqs{B},S: \worksm{\sqs{A}}{\sqs{B}} \Rightarrow \worksm{S\cc \sqs{A}}{S\cc \sqs{B}}$,
that is,
the relationship between the domains of the sets $\sqs{A}$ and $\sqs{B}$ 
does not change if both are prefixed by a sequence $S$.
\end{myclm}
\begin{proof}
This is because the function $S$ is a binary relation between filesystems,
and we can treat its inverse relation as a one-to-many mapping between filesystems
that maps $\Dom{\sqs{A}}$ to $\Dom{S\cc\sqs{A}}$ and $\Dom{\sqs{B}}$ to $\Dom{S\cc\sqs{B}}$.
As such a one-to-many mapping maps a subset of a set to a subset of the image of the set,
if $\Dom{\sqs{A}}\subseteq\Dom{\sqs{B}}$, then $\Dom{S\cc\sqs{A}}\subseteq\Dom{S\cc\sqs{B}}$.
\end{proof}

We also prove the following lemmas.

\begin{myax}\mlabel{combine_independent_commands}
The combination of independent commands is defined on all filesystems
where both of the commands are defined:
\[ \alpha\indep \beta \Rightarrow \worksmbx{\alpha, \beta}{\alpha\cc \beta}. \]
\end{myax}
\begin{proof}
We name this proposition a \namecref{combine_independent_commands} 
because to prove it, we must reach back to our filesystem model.
Let $\alpha=\cxynv$ and $\beta=\czwmv$.
The proof is by contradiction;
assume that there is a filesystem $\FS$ for which
$\cxynv\aFS\neq\fsbroken$ and $\czwmv\aFS\neq\fsbroken$, but
$\cxynv\cc \czwmv\aFS=\fsbroken$.
We know $\cxynv\aFS\neq\fsbroken$ so it must be applying 
$\czwmv$ that breaks it.
Applying a command can only result in a broken filesystem in two cases.
First, if the input type does not match the filesystem,
but we know $[\FS(m)]=[w]$ and so
$[(\cxynv\aFS)(m)]=[w]$ as based on \cref{incomparable_is_independent}, $n\neq m$.
Second, if the new filesystem violates the tree property.
This again cannot be the case because we also know that $n\unrel m$
and the tree property only depends on the types of values at the parent and children of $m$,
which therefore cannot be changed by $\cxynv$.
\end{proof}

\cref{combine_independent_commands} extends to sequences as well:

\begin{mylem}\mlabel{combine_independent_sequences}
The combination of independent sequences is defined on all filesystems
where both of the sequences are defined:
\[ S\indep T \Rightarrow \worksmbx{S,T}{S\cc T}. \]
\end{mylem}
\begin{proof}
Assume that there is a filesystem $\FS$ so that
$S\aFS\neq\fsbroken$ and $T\aFS\neq\fsbroken$, but
$(S\cc T)\FS=\fsbroken$.

From \cref{def_indep} we know that
the commands in $S$ and $T$ pairwise commute, and so any sequence
that contains the commands from $S$ and $T$ and preserve their original partial order
is equivalent to $S\cc T$ on all filesystems.

Let the command in $T$ that breaks $\FS$ when applying $S\cc T$ be $t$
so that $T=T_0\cc t\cc T_1$.
It is still true that $(T_0 \cc t)\FS\neq\fsbroken$,
and by definition $(S\cc T_0)\FS\neq\fsbroken$,
but $(S\cc T_0\cc t)\FS=\fsbroken$.
Also, from above we know that $S\cc T_0\equiv T_0\cc S$
and so $(T_0 \cc S)\FS\neq\fsbroken$.

If we denote the first command in $S$ with $s_1$,
this means that $(T_0 \cc s_1)\FS\neq\fsbroken$,
which we can combine with $(T_0 \cc t)\FS\neq\fsbroken$, $t\indep s_1$ and
\cref{combine_independent_commands}
(using $T_0\FS$ as the reference filesystem)
to arrive at $(T_0 \cc s_1\cc t)\FS\neq\fsbroken$.

We can repeat this step for $s_2$, the next command in $S$,
and from 
$(T_0 \cc s_1\cc t)\FS\neq\fsbroken$
and
$(T_0 \cc s_1\cc s_2)\FS\neq\fsbroken$
arrive at
$(T_0 \cc s_1\cc s_2\cc t)\FS\neq\fsbroken$.
This can be repeated until $S$ is exhausted and we get
$(T_0 \cc S\cc t)\FS\neq\fsbroken$, which is a contradiction.
\end{proof}

We also prove the following:

\begin{mylem}\mlabel{worksinputmatch}
If $S$ and $T$ are minimal sequences, $\worksmnilb{S,T}$,
and there are commands on node $n$ in both $S$ ($\cxynv\in A$) and $T$ ($\czwnv\in B$),
then the input types of these commands must match, i.e. $[x]=[z]$.
\end{mylem}
\begin{proof}
This result is similar to \cref{equiv_simple_same_commands} and
is easily shown using a proof by contradiction: if $[x]\neq [z]$, then there is no filesystem that
either $\cxynv$ or $\czwnv$ would not break, 
and consequently $S$ and $T$ cannot work on the same filesystem.
\end{proof}

