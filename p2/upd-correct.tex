
\subsection{The Correctness of Update Detection}

With $\ordersetsign$ we can now define our update detection algorithm.
Its inputs are the original filesystem $\FS$ which has been modified to yield $\FS_1$.
\begin{mydef}[Update detection]\mlabel{def_upddetect}
\begin{enumerate}
    \item For each node $n$ where the value in $\FS$ and $\FS_1$ differ, add the command $\cxynv$ to
        a set of commands $U$.
    \item % TODO
\end{enumerate}
\end{mydef}
% TODO from journal? Simplify sequence?


TODO ENSURE UPDATE DETECTOR IS DEFINED.

% There is a sequence between any two states: destroy one completely and construct the other one. (finite FS)



\begin{myth}\mlabel{update_works}
For a sequence of commands $U$ returned by the update detector
when comparing the non-broken $\FS^*$ to the original $\FS$,
$U\aFS = \FS^*$.
\end{myth}

TODO What is not trivial here is that $U$ works at all.

TODO And that it can be ordered?

\begin{proof}
Let $\FS$ be the original filesystem, and $\FS^*$
be the filesystem after the changes we intend to detect.
Let us assume that some mechanism recorded all changes that occurred
to $\FS$ until it reached the state $\FS^*$.
Our set of commands is sufficient to record any change, as
there are commands for every input and output type pair, therefore
we know that the changes can be recorded as a sequence of commands $S$
where $S\aFS=\FS^*$.
($S$ will not contain assertion commands, as they do not
represent an actual change in the filesystem.)
Based on \cref{can_simplify}, there is a simple sequence $S^*$
that is equivalent to $S$.

Therefore we know $S^*\aFS=\FS^*$, and that
$\FS^*$ and $\FS$ differ at exactly those nodes that $S^*$ has commands on.
If $U$ is the simple sequence returned by the update detector
when comparing $\FS^*$ to $\FS$, it must also contain commands on the same set of nodes,
and it must contain the same commands,
as for the command $\cxynv$, $[x]$ must be $[\FS(n)]$, and $y$ must be $\FS^*(n)$.
From this we know that $U$ is a permutation of $S^*$ and so $\orderset{U}=\orderset{S^*}$.

As the update detector uses $\ordersetsign$ to order the commands in $U$, trivially $U\in\orderset{U}$, % TODO
and as $S^*$ is defined on $\FS$,
from \cref{order_is_only_possible} we know $S^* \in \orderset{S^*}$.
This means $U\in\orderset{S^*}$,
and so from \cref{simple_reorder_equiv} we know that $U\equiv S^*$,
from which $U\aFS=\FS^*$.
\end{proof}

An important consequence of this proof is that any sequence
of recorded updates that were applied to a filesystem can be
converted to a simple sequence using the rules listed in
\cref{section_axioms} alone.
