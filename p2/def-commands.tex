
\subsection{Commands on Filesystems}

% TODO identity command instead of the empty sequence?

Next we define commands on filesystems.
As described above, we aim to select a set of commands
that captures as much information
about the operations as possible, and is also symmetric.
We start by summarizing our reasons for doing so.

% What is encoded in a command?

Let us consider what kind of information is usually encoded in filesystem operations.
A minimal set of commands, based on the most frequent tools implemented by filesystems,
may be the following, where 
$n\in\setn$ and $\valv\in\setv$ (but $\valv\neq\empt$):
\begin{itemize}
\item $create(n,\valv)$, which creates a file or directory ($\valv$) at $n$
where the file system contains no file or directory ($\empt$);
\item $edit(n,\valv)$, which replaces the earlier file or directory at $n$ with $\valv$;
\item $remove(n)$, which removes the file or directory at $n$, and replaces it with $\empt$.
\end{itemize}
Regarding their output, that is, the state of the filesystem at $n$
after applying the command,
we know that after $create$ or $edit$, $\FS(n)\neq\empt$, whereas after $remove$,
$\FS(n)$ will be $\empt$. 
However, from \cite{NREC} and \cite{CBNR} we know that a useful set of axioms
will in some cases need to distinguish between, for example,
$edit$s that result in directories ($edit(n,\vald)$) and
ones that result in files ($edit(n,\valf)$), and treat them as separate commands,
as their behaviors are quite different when combined with other commands.
Indeed, Bill Zissimopoulos' work
demonstrated \cite{BZ}
that extending this distinction to more commands ultimately simplifies
the definition of conflicting commands, as our model will then able to predict the behavior of commands
more precisely.
In other words, encoding the output value in the commands is definitely useful.
As the success or failure of filesystem commands only depends on the types of values in the filesystem,
we expect to use the type of their output when modelling their behavior.

Notice, however, that the commands listed above also encode some information about 
their input, the state of the filesystem
before the command is applied. In particular, $create(n,\valv)$ requires that there are no files
or directories at $n$, while $edit(n,\valv)$ and $remove(n)$ require the opposite.
This creates an arbitrary asymmetry where
there is now more information available about their output than about their input.
As, based on the above, we expect that encoding more information in the commands
results in a model with greater predictive powers,
and in order to resolve this asymmetry, 
we propose a set of commands that encode
the type of the input value $\FS(n)$ as well.
(Some real-life filesystem commands like $rmdir$ do this already.)
Again, as the success of failure of commands depends on types of values,
it is not necessary to encode the actual input value.

% Definition
% Break / empty command

\begin{mydef}[Filesystem commands, $\cbrk$]
We model filesystem commands as partial endofunctions on filesystems,
that is, functions that map filesystems to filesystems, but which
are not defined everywhere:
\[ \alpha: \setfs \nrightarrow \setfs \]
A command $\alpha$ is not defined on filesystems where it returns an error.
This happens if the input type of the command does not match
what is actually in the filesystem, or if the modified filesystem no
longer has the tree property.
At times in these cases we write that the command {\em breaks} the filesystem,
or that it returns the bottom element, $\fsbroken$.

We write $\cbrk$ for the empty partial function which is not defined anywhere.

We have three pieces of information defining a non-empty command,
which we represent using a triple. These are its
input type ($[v_\textrm{in}]$), output value ($v_\textrm{out}$),
and the node to which it is applied ($n$):
\[ \alpha = \caaaa{v_\textrm{in}}{v_\textrm{out}}{n}. \]
\end{mydef}

For example, $\cbfaa{n}$ represents $create(n,\valf)$,
and $\cdba{n}$ represents $rmdir(n)$.
When describing unknown commands, we substitute one or both
of their values with variables, and write e.g. $\cxynv$.
By $\cxynv=\czwmv$ we mean that the commands are identical
($[x]=[z]$ and $y=z$ and $n=m$).
As suggested above, we will frequently only investigate
the types of the input and output values of a command
(its input and output types), and write
$\cxy=\czw$, by which we mean $[x]=[z]$ and $[y]=[w]$.

We note that a command or a sequence of commands is applied to a filesystem
by prefixing the command or sequence to it, for example: $\cbrk\aFS$, $\cbdaa{n}\aFS$, 
or $S\aFS$ if $S$ is a sequence of commands.

\begin{mydef}[Effect of commands]
We use a replacement operator of the form
$\FS_{[\valv/n]}$ to denote a filesystem derived from $\FS$ 
by replacing its value at $n$ with $\valv$:
\[ \FS_{[\valv/n]}(m) =
   \begin{cases}
   \valv &\mbox{if~} m=n\\
   \FS(m) &\mbox{otherwise.}
   \end{cases}
\]
The effect of the commands is then as follows:
\begin{align*}
&\cbrk\aFS = \fsbroken \\
&\cxynv\aFS = 
   \begin{cases}
   % \fsbroken &\mbox{if~} \FS=\fsbroken\\
   \fsbroken &\mbox{if~} [\FS(n)]\neq[x]\\
   \fsbroken &\mbox{if~} \FS_{[y/n]} \mbox{~violates the tree property}\\
   \FS_{[y/n]} &\mbox{otherwise.}
   \end{cases}
\end{align*}
\end{mydef}


% Simplification
% --------------

\bigskip

\noindent
For reasons also listed in \cite{NREC}, in this paper we will not consider
a $move$ or $rename$ command. Regarding the theoretical reasoning we aim to follow,
this turns out to be useful because this would be the only command that affects
filesystems at two nodes at once, therefore describing 
the dependencies for $move$ would call for a more complicated model.
From a pragmatic perspective, this restriction does not mean that in an application
implementing conflict resolution using the algorithm described here would not be
able to handle renames by pre- and post-processing changes in the filesystem to
discover them, which can enhance usability, but which
(especially when a rename is combined with changes to the content)
is a non-trivial problem in itself.
