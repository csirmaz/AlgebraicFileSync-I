
\section{Conclusions and Further Research}

Apart from constructing an algebra,
there are many other ways in which further work can extend the current results.
An important extension would be to
consider reconciling not only two, but more replicas in a single step and
prove the correctness and maximality of the algorithm proposed.

A related problem is to extend the system and the proofs
to allow for cases where reconciliation cannot
complete fully
or if only a subset of the replicas are reconciled 
(e.g. due to network partitioning),
both of which would result in a state where different replicas
have different common ancestors, that is,
the updates specific to the replicas start from different points
in the update history of the filesystem.
Existing research can offer pointers as to how such cases can be modelled
in our algebraic system.
Parker et al. \cite{PPRS} and Cox and Josephson \cite{CJ}
describe version vectors (update histories) kept as metadata,
while Chong and Hamadi present distributed algorithms that allow incremental synchronization \cite{CH}.
Representing individual updates to files
in their modification histories (as described in \cite{CJ})
as separate commands could also enable an algebraic synchronizer to reconcile otherwise
conflicting updates and resolve partial reconciliations.

An extension of our results could also entail relaxing
the simplifying assumptions we used.
Identifying which results depend on the assumption that $|\setd|=1$
and devising updated proofs and algorithms,
or specifying a pre-processing step that reconciles meta-information in directories
can enable the synchronizer
to identify and resolve a wider range of conflicts.
Similarly, designing pre- and post-processors that
present removing and creating a node
not as separate updates but as a single rename (move),
could contribute to the user-friendliness of the reconciler
and help avoid human error.

And finally, we hope that this work, together with \cite{NREC}, provides
a blueprint of constructing an algebra of commands for different storage protocols
(e.g. XML trees, mailbox folders, generic relational databases, etc.),
and of demonstrating the adequacy and completeness of update and conflict detection and reconciliation
algorithms defined over it.
This, in turn, can offer formal verification of the algorithms underlying
specific implementations in a variety of synchronizers.
Alternatively, by generalizing the parent--child relationships between filesystem nodes,
the demonstrated properties of minimal sequences of commands
and conditional operation of sequences ($\workssign$)
may also contribute to future research into algebraic structures
constrained by predefined sparse connections between their elements.
