
\subsection{The Filesystem}

\begin{mydef}[Filesystems]
We model a filesystem
using a function $\FS$ with a set of nodes (potential filesystem paths) $\setn$ as its domain,
and a set of possible contents or values $\setv$ as its codomain:
\[ \FS: \setn \rightarrow \setv. \]
We consider metadata to be part of the values in $\setv$.
In this model, $\setn$ 
serves as a namespace for the filesystem:
it contains all possible nodes, including the ones 
where the file system contains no file or directory.
\end{mydef}

There is an ancestor / descendant relation defined over the nodes in $\setn$
which arranges them in a disjoint union of rooted directed trees,
and which can be derived from the partial function $\parent$ yielding
the parent of a node in $\setn$ provided it exists.

Tao et al. \cite{TSR} describe a similar filesystem model, although
they also model inodes and restrict the filesystem to just a single tree.


\begin{mydef}[Ordering on $\setn$: $\parent$, $\descendant$, $\descendantEq$, $\unrel$]
The partial function $\parent:\setn\nrightarrow\setn$
returns the parent node of $n$,
and is undefined if $n$ is the root of a tree.

The \emph{ancestor} / \emph{descendant} relation $\descendant$ is the
strict partial ordering determined by the $\parent$ function.
We write $n\descendant m$ if $n$ is the ancestor of $m$,
that is, $n=\parent^i(m)$ for some integer $i\ge 1$.
% or the path name of $n$ is an initial segment of that of $m$. 
We write $n\descendantEq m$ if $n\descendant m$ or $n=m$.

We write $n\unrel m$, or $n$ and $m$ are \emph{incomparable},
iff $n\not\descendantEq m$ and $n\not\ancestorEq m$;
that is, incomparable nodes are on different branches or on different trees.
% none of the path names describing their location is an initial segment of the other.
\end{mydef}

We assume that the $\parent$ function does not induce loops, and so
$\descendant$ is indeed a strict partial ordering.

The set of nodes $\setn$, combined with $\parent$ form a \emph{skeleton}
which the filesytems populates with values from $\setv$.
As we require the filesystem functions to be total,
we use a special value, $\empt\in\setv$, to indicates that the filesystem
has no file or directory at a particular node.

\begin{mydef}[Filesystem values: $\vald$, $\valf$, $\empt$, $\typeeq$, $[v]$]
The set of values $\setv$ is partitioned into files, directories, and the empty value $\empt$.
For $v_1,v_2\in\FV$ we write $v_1\typeeq v_2$ iff
$v_1$ and $v_2$ are both files, are both directories, or are both $\empt$.
As usual, we write $[v]$ for the the equivalence class of $v\in\FV$ which represents its type.
Files and directories are also denoted by $\valf$ and $\vald$, respectively,
with or without indices.
\end{mydef}


Every filesystem has a so-called \emph{tree property}, which means that
if the filesystem is not empty at a node, and the node has a parent,
then there must be a directory at the parent node.
To model this, we differentiate between files, directories, and the
empty value in $\setv$, and introduce the equivalence relation
$\typeeq$.


As usual, we write $[v]$ for the equivalence class of $v$, which represents its type.
The formal definition of the tree property is therefore
\begin{mydef}[Tree property]
% TODO \setf no longer defined
\begin{align*}
\forall n\in\setn, \FS\in\setfs:& \\
& \FS(n) \neq \empt \Rightarrow \FS(\parent(n)) \typeeq \vald,
\end{align*}
where $\parent(n)$ is defined, and where $\vald\in\setv$ is a directory value.
\end{mydef}

To avoid the proliferation of edge cases, we will furthermore suppose that
$|\setd|=1$, that is, apart from their location, all directories are equal;
and use $\vald$ to denote the single value of the directory type.
In appendix TODO we describe why it can be a sensible choice
for actual synchronizers, and we also present an encoding that makes it possible
to extend our results to the $|\setd|>1$ case.

%% TODO
% % To model this, in $\setv$ we select another special value
% % to represent directories, as we assume that apart from their location
% % in the filesystem, all directories are equal.
% % We do this because, as Bill Zissimopoulos pointed 
% % out \cite{BZ},
% % we often do not want to consider metadata stored in
% % directories (e.g. permission settings) during synchronization,
% % as these are not generally understood well by users,
% % and, if needed, conflict resolution on these settings can be easily automated.
% % We will also see that this assumption makes it possible
% % to define a maximal reconciliation algorithm.

In this paper, $\FS$ and $\GS$ denote filesystems,
and $n$, $m$ and $o$ are nodes in $\setn$.
We write $\valf$ for a file value. % element in $\setf$.

