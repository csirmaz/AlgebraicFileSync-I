
\subsection{Filesystems}

\begin{mydef}[Filesystems, $\FS$]
We model a filesystem
using a function $\FS$ with a set of nodes (potential filesystem paths) $\setn$ as its domain,
and a set of possible contents or values $\setv$ as its codomain:
\[ \FS: \setn \rightarrow \setv. \]
We consider metadata to be part of the values in $\setv$.
In this model, $\setn$ 
serves as a namespace for the filesystem:
it contains all possible nodes, including the ones 
where the file system contains no file or directory.
\end{mydef}

% Ordering nodes

There is an ancestor / descendant relation defined over the nodes in $\setn$
which arranges them in a disjoint union of rooted directed trees,
and which can be derived from the partial function $\parent$ yielding
the parent of a node in $\setn$ provided it exists.
Tao et al. \cite{TSR} describe a similar filesystem model, although
they also model inodes and restrict the filesystem to just a single tree.

\begin{mydef}[Ordering on $\setn$: $\parent$, $\descendant$, $\descendantEq$, $\unrel$]
The partial function $\parent:\setn\nrightarrow\setn$
returns the parent node of $n$,
and is undefined if $n$ is the root of a tree.

The \emph{ancestor} / \emph{descendant} relation $\descendant$ is the
strict partial ordering determined by the $\parent$ function.
We write $n\descendant m$, or $n$ is the ancestor of $m$,
iff $n=\parent^i(m)$ for some integer $i\ge 1$.
% or the path name of $n$ is an initial segment of that of $m$. 
We write $n\descendantEq m$ iff $n\descendant m$ or $n=m$.

We write $n\unrel m$, or $n$ and $m$ are \emph{incomparable},
iff $n\not\descendantEq m$ and $n\not\ancestorEq m$;
that is, incomparable nodes are on different branches or on different trees.
% none of the path names describing their location is an initial segment of the other.
\end{mydef}

We assume that the $\parent$ function does not induce loops, and so
$\descendant$ is indeed a strict partial ordering.

% Values

The combination of the set of nodes and the parent function,
$\langle \setn, \parent \rangle$, forms a \emph{skeleton}
which the filesytems populate with values from $\setv$.
As we require filesystem functions to be total,
we use a special value, $\empt\in\setv$, to indicate that the filesystem
is empty at a particular node, that is, there are no files or directories there.
We also assume that a filesystem has finitely many non-empty nodes.

\begin{mydef}[Filesystem values: $\vald$, $\valfx$, $\empt$, $\typeeq$, $\eqclass{v}$]
The set of values $\setv$ is partitioned into files, directories, and the empty value $\empt$.
% TODO May be able to delete \typeeq
For $v_1,v_2\in\setv$ we write $v_1\typeeq v_2$ iff
$v_1$ and $v_2$ are both files, are both directories, or are both $\empt$.
As usual, we write $[v]$ for the the equivalence class of $v\in\setv$, which represents its type.
File and directory values are also denoted by $\valfx$ and $\vald$, respectively,
with or without indices.
\end{mydef}

% Tree property

Every filesystem has a so-called \emph{tree property}, which means that
if the filesystem is not empty at a node, and the node has a parent,
then there must be a directory at the parent node.
Using the notation introduced above, we can formally express this as follows.
\begin{mydef}[Tree property]
A filesystem $\FS:\setn \rightarrow \setv$ has the tree property iff
\[ \forall n\in\setn
\FS(n) \neq \empt \Rightarrow \FS(\parent(n)) \typeeq \vald \]
wherever $\parent(n)$ is defined, that is, $n$ has a parent.
\end{mydef}

% SINGLEDIR

To avoid the proliferation of edge cases, we will furthermore suppose that
$|\setd|=1$, that is, there is only one directory value $\vald\in\setv$, and so
apart from their location, all directories are equal.
In appendix TODO we describe why it can be a sensible choice
for actual synchronizers, and we also present an encoding that makes it possible
to extend our results to the $|\setd|>1$ case.

% % We do this because, as Bill Zissimopoulos pointed 
% % out \cite{BZ},
% % we often do not want to consider metadata stored in
% % directories (e.g. permission settings) during synchronization,
% % as these are not generally understood well by users,
% % and, if needed, conflict resolution on these settings can be easily automated.
% % We will also see that this assumption makes it possible
% % to define a maximal reconciliation algorithm.

% Notation

\bigskip
In the rest of this paper,
we fix the skeleton $\langle\setn,\parent\rangle$,
and the set of values $\setv$.
$\FS$ (with or without indices) denotes a filesystem,
and $n$, $m$ and $o$ are nodes in $\setn$,
and we write $\nn$ for the parent of $n$, assuming it exists.
