
\subsection{Ordering commands}\label{ordering}

We often encounter the case where we only have a set of commands without a specified order.
As we have seen above, this can occur after the first stage of update detection,
but, more importantly,
it is actually the task of the reconciler to determine whether there is an order,
and if yes, what order,
in which updates from different replicas can be applied to a filesystem.

Let us therefore define $\ordersetsign$ which gives all
permutations of a set of commands that do not break all filesystems.

\begin{mydef}[$\ordersetsign$]\label{def_orderset}
For a simple set or sequence of commands $U$,
we use $\orderset{U}$ to denote the set of sequences
that are all permutations of the commands in $U$
for which the following holds:
for all subsequences $\cxynv\cc\czwmv$,
\begin{itemize}
\item if $n=\parent(m)$, then $y=\vald$
\item if $\parent(n)=m$, then $y=\empt$.
\end{itemize}
\end{mydef}

As usual, by subsequence we mean a subset of the commands in $S$ in the same order as they are found in $S$.

The principal ideas behind these conditions are 
\cref{ax_separate_commute}, from which we know that commands on incomparable
nodes can be applied in any order, so we only need to focus on the order of commands
with comparable nodes;
\cref{connected_changes}, from which we know that if $U$ contains commands on two comparable
nodes, then it contains commands on all nodes in between, so it is enough to specify
the order of commands on directly related nodes;
and finally, \cref{ax_directchild_breaks,ax_directparent_breaks}, from which we know
that commands on parent--child pairs must be construction or destruction pairs.
Investigating these pairs we see that they are identified by the output value of the first command ($y$),
which in turn determines whether the command on the parent or the child must precede the other.

In \cref{simple_reorder_equiv} we offer a formal proof that 
$\orderset{U}$ contains all possible permutations.
It is an important property of simple sequences: namely, that
all of their valid reorderings are equivalent,
and all equivalent sequences are mere reorderings.
To prove this, we will need the following results.

\begin{mycor}\label{subseq_in_orderset}
For simple sequences $S$ and $T$,
if $T\in\orderset{S}$, then for any subsequence of $S$, $S_0$, which contains
only part of the commands in $S$ but in the same order as in $S$,
and for the corresponding subsequence of $T$, $T_0$, which
contains the same commands but in the order they are found in $T$,
$T_0\in\orderset{S_0}$ must hold.
\end{mycor}
\begin{proof}
This is because
if there are no command pairs in $T$ not conforming to \cref{def_orderset},
then there cannot be any in $T_0$.
\end{proof}

\begin{mylem}\label{simple_distant_pairs}
For any simple sequence $S\nequiv\cbrk$
if $\cxynv\cc\czwmv$ is a subsequence of $S$ and $n=\parent(m)$ or $\parent(n)=m$,
then $\cxynv\cc\czwmv\nequiv\cbrk$.
\end{mylem}
\begin{proof}
Informally speaking, the proposition means that
the two commands must form a construction or destruction pair even
if they are not next to each other.
This is true because in simple sequences
there cannot be another command on $n$ or $m$,
so if the commands are incompatible, no command between them can change that.
In fact, this \namecref{simple_distant_pairs} is the general case
of \cref{ax_directchild_breaks,ax_directparent_breaks}.

% BACK_TO_THE_FS TODO
% TODO Review any proof depending on "nothing changes FS at n until...".
% TODO Move to rules
% TODO APPENDIX
Formally, we prove our proposition by contradiction,
and in this version of the proof we reach back to our filesystem model.
We assume $S\nequiv\cbrk$ and therefore there is a $\FS$ for which $S\aFS\neq\fsbroken$,
but $S$ contains commands on a node and its parent that do not form a construction or destruction pair.
Select two such commands, $\cxynv$ and $\czwmv$,
and split $S$ around them into three parts:
\[ S = S_0 \cc \cxynv \cc S_1 \cc \czwmv \cc S_2. \]
As $S$ is simple, there cannot be any commands on $n$ or $m$ in $S_1$,
and therefore $(S_0\cc\cxynv\cc S_1)\FS(n) = y$,
and $[(S_0\cc\cxynv\cc S_1)\FS(m)] = [S_0\FS(m)]$.
If $[z]\neq[S_0\FS(m)]$, then $S\aFS=\fsbroken$, which is a contradiction.

If $n=\parent(m)$, then 
we know $(S_0\cc\cxynv\cc S_1)\FS(n) = y$, and as $[z]\neq[w]$, either
$[(S_0\cc\cxynv\cc S_1)\FS(m)]=[z]\neq[\empt]$,
or $[(S_0\cc\cxynv\cc S_1\cc\czwmv)\FS(m)]=[w]\neq[\empt]$.
Therefore $y$ must be $\vald$, as otherwise the tree property would be violated
when applying $\czwmv$,
and $[x]\neq[\vald]$ as $\cxynv$ is not an assertion command.
As $[S_0\FS(n)]=[x]\neq[\vald]$, we know
$S_0\FS(m)=\empt$ as otherwise the tree property would be violated.
Therefore $[S_0\FS(m)]=[z]=[\empt]$, which, combined with $y=\vald$
means that $\cxynv\cc\czwmv\nequiv\cbrk$ is a construction pair, which is a contradiction.

If $\parent(n)=m$, then 
as $(S_0\cc\cxynv\cc S_1)\FS(n) = y$, and either
$[(S_0\cc\cxynv\cc S_1)\FS(m)]=[z]\neq[\vald]$
or $[(S_0\cc\cxynv\cc S_1\cc\czwmv)\FS(m)]=[w]\neq[\vald]$,
$y$ must be $\empt$, and $[x]\neq[\empt]$.
As $[S_0\FS(n)]=[x]\neq[\empt]$, we know $S_0\FS(m)=\vald$.
Therefore $[S_0\FS(m)]=[z]=[\vald]$, which, combined with $y=\empt$
means that $\cxynv\cc\czwmv\nequiv\cbrk$ is a destruction pair, which is a contradiction.
\end{proof}


\begin{mycor}\label{order_is_only_possible}
For any simple sequence $S$ and its permutation $S'$, 
\[ S'\not\in\orderset{S} \Longrightarrow S'\equiv\cbrk. \]
\end{mycor}
\begin{proof}
This follows directly from \cref{simple_distant_pairs}.
If $S'\not\in\orderset{S}$ then by \cref{def_orderset}
it contains two commands on a node $n$ and its parent
that placed next to each other do not form
a construction or destruction pair.
Let them be $\cxynv$ and $\czwmv$.
By \cref{ax_directchild_breaks,ax_directparent_breaks}
we know
$\cxynv\cc\czwmv\equiv\cbrk$, which is a subsequence of $S'$,
and therefore by \cref{simple_distant_pairs} $S'\equiv\cbrk$.
\end{proof}



\begin{mylem}\label{connected_changes}
Given a set of commands that
does not contain assertion commands,
and which can be applied to a filesystem in some order without breaking it,
and which contains commands on $n$ and $\nn$ where $\nn\descendant n$,
then the set must also contain a command
on each node between $n$ and $\nn$.
\end{mylem}
\begin{proof}
Without loss of generality, we can assume that $\nn\neq\parent(n)$.
We prove that under the given conditions, the set must contain a command on $\parent(n)$.
Then, by reapplying this result, we know that the set must contain commands on every
ancestor of $n$ up to $\nn$.

Furthermore,
we prove this proposition for sequences, not sets, as if all sequences must contain a command on $\parent(n)$,
then so must all sets because otherwise there would be no order in which the commands they contain could be
applied to a filesystem.

Let $A$ be a sequence that satisfies the conditions;
we therefore know that it contains a command $\cxynv$ on $n$
and another command $\czwnnv$ on $\nn$.
We use a proof by contradiction and assume that there are no commands on $\parent(n)$ in $A$.
Next, we create a new sequence $A'\equiv A$ in which $\cxynv$ and $\czwnnv$ are next to each other.
If they are already next to each other in $A$, there is nothing to do.
Otherwise, consider the command next to $\cxynv$ in the direction where $\czwnnv$ is.
Let this command be $\cqrmv$.
If $\czwnnv$ is to the right, then $A$ looks like the following:
\[ A = \cdots\cc\cxynv\cc\cqrmv\cc\cdots\cc\czwnnv\cc\cdots \]
If $n\unrel m$, then swap $\cxynv$ and $\cqrmv$. Based on \cref{ax_separate_commute} we know that the new
sequence is equivalent to $A$.
Otherwise, we know $m\neq\parent(n)$ as there are no commands on $\parent(n)$, and so
from \cref{ax_distantrel_breaks} we get $A\equiv\cbrk$ which contradicts our assumptions.
(Note that $A$ cannot contain assertion commands.)
By repeating this step we can therefore convert $A$ into $A'$ where $\cxynv$ and $\czwnnv$ are neighboring commands.
However, then \cref{ax_distantrel_breaks} applies to the sequence and therefore $A\equiv A'\equiv\cbrk$ which
is again a contradiction.
\end{proof}



\begin{mylem}\label{equiv_simple_same_commands}
If two simple sequences $A$ and $B$ are equivalent
and do not break all filesystems ($A\equiv B\nequiv\cbrk$),
then they must contain the same commands.
\end{mylem}
\begin{proof}
% BACK_TO_THE_FS
We use a proof by contradiction. Let $A$ and $B$ be simple sequences
such that $A\equiv B\nequiv\cbrk$,
and $\FS$ be a filesystem that they do not break.

We also assume that they do not contain the same commands.
Without loss of generality, we can assume
that $A$
contains $\cxynv$, and $B$ either contains a different command
$\czwnv$ on $n$, or no command on $n$ at all.
As $A$ is simple, we know that $\cxynv$ is not an assertion command,
and therefore $[x]\neq [y]$ and $\FS(n)\neq y$ as $[\FS(n)]=[x]$.
If so, then if $B$ has no command on $n$, then $B\aFS(n)=\FS(n)$ and
$A$ and $B$ cannot be equivalent.
Otherwise we know that $[z]=[x]$ as $B$ does not break $\FS$ either,
and that $w=y$ as $B\aFS(n)$ must
be $y$ and $B$ only has one command on $n$.
However, then $\czwnv=\cxynv$, which is a contradiction.
\end{proof}


% TODO delete unused results

\begin{mylem}\label{simple_reorder_equiv}
For a simple sequence $S\nequiv\cbrk$,
$\orderset{S}$ is the set of all simple sequences equivalent to $S$, that is,
\[ \orderset{S} = [S]_\equiv \cap \setssmp. \]
\end{mylem}

For the proof we define construction and descruction commands as follows:
\begin{mydef}[Construction command]
A command $\cxynv$ is a construction command if it can appear in a construction pair,
that is, if $[x]=[\empt]$ and $[y]\neq[\empt]$,
or if $[x]=[\valf]$ and $[y]=[\vald]$.
\end{mydef}
\begin{mydef}[Destruction command]
A command $\cxynv$ is a destruction command if it can appear in a destruction pair,
that is, 
if $[x]=[\valf]$ and $[y]=[\empt]$,
or if $[x]=[\vald]$ and $[y]\neq[\vald]$.
Note that a command cannot be both a construction and a destruction command.
\end{mydef}


% TODO APPENDIX
\begin{proof}
First, we prove, by contradiction, that if a simple sequence $T\equiv S$, then $T\in\orderset{S}$.
We assume $T\equiv S$ and $T\not\in\orderset{S}$.
Then, from \cref{equiv_simple_same_commands} we know $T$ is a permutation of $S$,
and from \cref{order_is_only_possible} we know $T\equiv\cbrk$ which
is a contradiction as $T\equiv S\nequiv\cbrk$.

Next, we prove that if $T\in\orderset{S}$, then $T\equiv S$.
We proceed by induction on the length of $S$.
Our base cases are $\emptyseq$, where $\orderset{\emptyseq}=\{\emptyseq\}$,
and one-long sequences, where this is trivially true.
In our induction step we assume that $T^*\in\orderset{S^*}\Rightarrow T^*\equiv S^*$ holds
for all sequences of length $i$ or less, where $i\geq 1$.

Let us consider $T\in\orderset{S}$ where $T$ and $S$ are of length $i+1$.
Let the first command in $S$ be $\cxynv$, that is, $S=\cxynv\cc S_0$.
We proceed by a nested induction on the number of commands before $\cxynv$ in $T$.
Our base case is when it is the first command, which means $T=\cxynv\cc T_0$.
Then from \cref{subseq_in_orderset} we know $T_0\in\orderset{S_0}$
and from the induction hypothesis $T_0\equiv S_0$ from which we get $T\equiv S$.

In our nested induction step we assume $T'\equiv S$ for all $T'\in\orderset{S}$
where there are at most $j$ commands in $T'$ to the left of $\cxynv$.
Let us then consider $T$ where there are $j+1$ such commands.
We aim to transform $T$ into $T''\equiv T$ by swapping $\cxynv$ with the preceding
command. Then from the induction hypothesis we will know $T\equiv T''\equiv S$,
which proves our lemma.

Let the command to the left of $\cxynv$ in $T$ be $\czwmv$.
As $S$ is simple, we know $n\neq m$.
If $n\unrel m$, then from \cref{ax_separate_commute} we know we can swap the two commands
and get an equivalent sequence.

\newcommand{\indx}{\varphi}
Otherwise, either $n\descendant m$, or $m\descendant n$, and so from
\cref{connected_changes} we know that $S$ contains a command on all nodes
between $n$ and $m$, and therefore so does $T$.
Let these nodes be $n_0, n_1, \ldots, n_k$ where $n_0=n$ and $n_k=m$,
and where 
either $n_\indx=\parentf{n_{\indx+1}}$ for all $\indx$ between $1$ and $k-1$,
or $n_{\indx+1}=\parentf{n_\indx}$ for all $\indx$.
We assume that $n_\indx=\parentf{n_{\indx+1}}$ is true.

Also, let $I^S_\indx$ be the index of the command on $n_\indx$ in $S$.
For all $\indx$, both the commands on $n_\indx$ and $n_{\indx+1}$ must be either
construction commands, or destruction commands, depending on
whether $I^S_\indx<I^S_{\indx+1}$ or $I^S_{\indx+1}<I^S_\indx$.
This is because otherwise, \cref{simple_distant_pairs} would not hold for $S$.

As a command cannot be both a construction and a desrtruction command,
this means that the indices $I^S$ are either monotone increasing, or monotone
decreasing, but cannot change direction.
And as $S$ begins with $\cxynv$ and so $I^S_0=1$, we know they are monotone increasing,
and the commands on $n_\indx$ are construction commands.
If we denote the command on $n_\indx$ with $\caaa{x_\indx}{y_\indx}{n_\indx}$,
by definition this means that $[y_\indx]\neq[\empt]$ for all $\indx$.

Let us turn to the location of these commands in $T$,
and denote their indices in $T$ with $I^T_\indx$.
We know $I^T_k=I^T_0-1$ as $\czwmv$ precedes $\cxynv$.
This means there must exist a $\indx$ for which $I^T_{\indx+1}<I^T_\indx$.
We therefore know that
$\caaa{x_{\indx+1}}{y_{\indx+1}}{n_{\indx+1}} \cc \caaa{x_\indx}{y_\indx}{n_\indx}$
is a subsequence of $T$, and by assumption $\parentf{n_{\indx+1}}=n_\indx$.
By definition of $\ordersetsign$, therefore $y_{\indx+1}=\empt$ must be true,
which is a constradiction.

It can be shown in the same way
that the case when the $n_\indx$ nodes ascend the tree,
that is, $n_{\indx+1}=\parentf{n_\indx}$ is true, also leads to a contradiction,
by using destruction commands instead of construction ones.
\end{proof}





%% TODO Define set operations on sequences?
% \noindent As a specific case, we can regard a simple sequence $S$
% as a set, and use the above algorithm to generate all possible orderings
% of the commands it contains.

TODO:
It follows from the algorithm that:
\begin{mycor}\label{lemma:neighbor}
If $U$ contains commands on both $n$ and $\parent(n)$, then
there is a simple $U'\equiv U$ in which they are next to each other.
\end{mycor}


TODO:
It follows from this that given a simple set,
we can simply assume that it has an order.
Accordingly, we will at times treat not only sequences as sets,
but simple sets as sequences.

