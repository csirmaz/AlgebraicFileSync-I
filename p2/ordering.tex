
\subsection{Ordering commands}\label{ordering}

We often encounter the case where we only have a set of commands without a specified order.
As we have seen above, this can occur after the first stage of update detection,
but, more importantly,
it is actually the task of the reconciler to determine whether there is an order,
and if yes, what order,
in which updates from different replicas can be applied to a filesystem.

Let us therefore define $\ordersetsign$ which gives us all
possible orders in which a set of commands can be applied
to filesystems without breaking it
provided that the commands can be applied to a fileystem in some order.

\begin{mydef}[$\ordersetsign$]\label{def_orderset}
For a simple set or sequence $U$,
we use $\orderset{U}$ to denote the set of sequences
that are all permutations of the commands in $U$
for which the following holds:
for any two commands $\cxynv$ and $\czwmv$ in a sequence in $\orderset{U}$
where $\cxynv$ comes earlier in the sequence than $\czwmv$,
\begin{itemize}
\item if $n=\parent(m)$, then $y=\vald$
\item if $\parent(n)=m$, then $y=\empt$.
\end{itemize}
\end{mydef}

The principal ideas behind this algorithm are 
\cref{ax_separate_commute}, from which we know that commands on incomparable
nodes can be applied in any order, so we only need to focus on the order of commands
with comparable nodes;
\cref{connected_changes}, from which we know that if $U$ contains commands on two comparable
nodes, then it contains commands on all nodes in between, so it is enough to specify
the order of commands on parent and child nodes;
and finally, \cref{ax_directchild_breaks,ax_directparent_breaks}, from which we know
that commands on parent--child pairs must be construction or destruction pairs.
Investigating the pairs we see that they are identified by the output value of the first command ($y$),
and that they determine whether the command on the parent or the child must precede the other.

In \cref{simple_reorder_equiv} we offer a formal proof that $\orderset{U}$ meets our expectations.
It is an important property of simple sequences: namely, that
all of their valid reorderings are equivalent,
and all equivalent sequences are mere reorderings.
To prove this, we will need the following results.

\begin{mycor}\label{subseq_in_orderset}
For simple sequences $S$ and $T$,
if $T\in\orderset{S}$, then for any subsequence of $S$, $S_0$, which contains
only part of the commands in $S$ but in the same order as in $S$,
and for the corresponding subsequence of $T$, $T_0$, which
contains the same commands but in the order they are found in $T$,
$T_0\in\orderset{S_0}$ must hold.
\end{mycor}
\begin{proof}
This is because
if there are no command pairs in $T$ not conforming to \cref{def_orderset},
then there cannot be any in $T_0$.
\end{proof}

\begin{mylem}\label{simple_distant_pairs}
For any simple sequence $S\nequiv\cbrk$
if $\cxynv\cc\czwmv$ is a subsequence of $S$ and $n=\parent(m)$ or $\parent(n)=m$,
then $\cxynv\cc\czwmv\nequiv\cbrk$.
\end{mylem}
\begin{proof}
As usual, by subsequence we mean a subset of the commands in $S$ in the same order as they are found in $S$.

Informally speaking, the proposition means that
the two commands must form a construction or destruction pair even
if they are not next to each other.
This is true because in simple sequences
there cannot be another command on $n$ or $m$,
so if the commands are incompatible, no command between them can change that.
In fact, this \namecref{simple_distant_pairs} is the general case
of \cref{ax_directchild_breaks,ax_directparent_breaks}.

% BACK_TO_THE_FS TODO
% TODO Review any proof depending on "nothing changes FS at n until...".
Formally, we prove our proposition by contradiction,
and in this version of the proof we reach back to our filesystem model.
We assume $S\nequiv\cbrk$ and therefore there is a $\FS$ for which $S\aFS\neq\fsbroken$,
but it contains commands that do not form a construction or destruction pair.
Select two such commands, $\cxynv$ and $\czwmv$,
and split $S$ around them into three parts:
\[ S = S_0 \cc \cxynv \cc S_1 \cc \czwmv \cc S_2 \]
As $S$ is simple, there cannot be any commands on $n$ or $m$ in $S_1$,
and therefore $(S_0\cc\cxynv\cc S_1)\FS(n) = y$,
and $[(S_0\cc\cxynv\cc S_1)\FS(m)] = [S_0\FS(m)]$.
If $[z]\neq[S_0\FS(m)]$, then $S\aFS=\fsbroken$, which is a contradiction.

If $n=\parent(m)$, then 
we know $(S_0\cc\cxynv\cc S_1)\FS(n) = y$, and as $[z]\neq[w]$, either
$[(S_0\cc\cxynv\cc S_1)\FS(m)]=[z]\neq[\empt]$,
or $[(S_0\cc\cxynv\cc S_1\cc\czwmv)\FS(m)]=[w]\neq[\empt]$.
Therefore $y$ must be $\vald$, as otherwise the tree property would be violated
when applying $\czwmv$,
and $[x]\neq[\vald]$ as $\cxynv$ is not an assertion command.
As $[S_0\FS(n)]=[x]\neq[\vald]$, we know
$S_0\FS(m)=\empt$ as otherwise the tree property would be violated.
Therefore $[S_0\FS(m)]=[z]=[\empt]$, which, combined with $y=\vald$
means that $\cxynv\cc\czwmv\nequiv\cbrk$ is a construction pair, which is a contradiction.

If $\parent(n)=m$, then 
as $(S_0\cc\cxynv\cc S_1)\FS(n) = y$, and either
$[(S_0\cc\cxynv\cc S_1)\FS(m)]=[z]\neq[\vald]$
or $[(S_0\cc\cxynv\cc S_1\cc\czwmv)\FS(m)]=[w]\neq[\vald]$,
$y$ must be $\empt$, and $[x]\neq[\empt]$.
As $[S_0\FS(n)]=[x]\neq[\empt]$, we know $S_0\FS(m)=\vald$.
Therefore $[S_0\FS(m)]=[z]=[\vald]$, which, combined with $y=\empt$
means that $\cxynv\cc\czwmv\nequiv\cbrk$ is a destruction pair, which is a contradiction.
\end{proof}


\begin{mycor}\label{order_is_only_possible}
For any simple sequence $S$ and its permutation $S'$, 
\[ S'\not\in\orderset{S} \Longrightarrow S'\equiv\cbrk. \]
\end{mycor}
\begin{proof}
This follows directly from \cref{simple_distant_pairs}.
If $S'\not\in\orderset{S}$ then by \cref{def_orderset}
it contains two commands on a node $n$ and its parent
that placed next to each other do not form
a construction or destruction pair.
Let them be $\cxynv$ and $\czwmv$.
By \cref{ax_directchild_breaks,ax_directparent_breaks}
we know the subsequence of $S'$,
$\cxynv\cc\czwmv\equiv\cbrk$ and therefore by \cref{simple_distant_pairs}
$S'\equiv\cbrk$.
\end{proof}



\begin{mylem}\label{connected_changes}
Given a set of commands that
does not contain assertion commands,
and which can be applied to a filesystem in some order without breaking it,
and which contains commands on $n$ and $\nn$ where $\nn\descendant n$,
then the set must also contain a command
on each node between $n$ and $\nn$.
\end{mylem}
\begin{proof}
Without loss of generality, we can assume that $\nn\neq\parent(n)$.
We prove that under the given conditions, the set must contain a command on $\parent(n)$.
Then, by reapplying this result, we know that the set must contain commands on every
ancestor of $n$ up to $\nn$.

Furthermore,
we prove this proposition for sequences, not sets, as if all sequences must contain a command on $\parent(n)$,
then so must all sets because otherwise there would be no order in which the commands they contain could be
applied to any filesystem.

Let $A$ be a sequence that satisfies the conditions;
we therefore know that it contains a command $\cxynv$ on $n$
and another command $\czwnnv$ on $\nn$.
We use a proof by contradiction and assume that there are no commands on $\parent(n)$ in $A$.
Next, we create a new sequence $A'\equiv A$ in which $\cxynv$ and $\czwnnv$ are next to each other.
If they are already next to each other in $A$, there is nothing to do.
Otherwise, consider the command next to $\cxynv$ in the direction where $\czwnnv$ is.
Let this command be $\cqrmv$.
If $\czwnnv$ is to the right, then $A$ looks like the following:
\[ A = \cdots\cc\cxynv\cc\cqrmv\cc\cdots\cc\czwnnv\cc\cdots \]
If $n\unrel m$, then swap $\cxynv$ and $\cqrmv$. Based on \cref{ax_separate_commute} we know that the new
sequence is equivalent to $A$.
Otherwise, we know $m\neq\parent(n)$ as there are no commands on $\parent(n)$, and so
from \cref{ax_distantrel_breaks} we get $A\equiv\cbrk$ which contradicts our assumptions.
(Note that $A$ cannot contain assertion commands.)
By repeating this step we can therefore convert $A$ into $A'$ where $\cxynv$ and $\czwnnv$ are neighboring commands.
However, then \cref{ax_distantrel_breaks} applies to the sequence and therefore $A\equiv A'\equiv\cbrk$ which
is again a contradiction.
\end{proof}



\begin{mylem}\label{equiv_simple_same_commands}
If two simple sequences $A$ and $B$ are equivalent
and do not break all filesystems ($A\equiv B\nequiv\cbrk$),
then they must contain the same commands.
\end{mylem}
\begin{proof}
% BACK_TO_THE_FS
We use a proof by contradiction. Let $A$ and $B$ be simple sequences
such that $A\equiv B\nequiv\cbrk$,
and $\FS$ be a filesystem that they do not break.

We also assume that they do not contain the same commands.
Without loss of generality, we can assume
that $A$
contains $\cxynv$, and $B$ either contains a different command
$\czwnv$ on $n$, or no command on $n$ at all.
As $A$ is simple, we know that $\cxynv$ is not an assertion command,
and therefore $[x]\neq [y]$ and $\FS(n)\neq y$ as $[\FS(n)]=[x]$.
If so, then if $B$ has no command on $n$, then $B\aFS(n)=\FS(n)$ and
$A$ and $B$ cannot be equivalent.
Otherwise we know that $[z]=[x]$ as $B$ does not break $\FS$ either,
and that $w=y$ as $B\aFS(n)$ must
be $y$ and $B$ only has one command on $n$.
However, then $\czwnv=\cxynv$, which is a contradiction.
\end{proof}



\begin{mylem}\label{simple_reorder_equiv}
For a simple sequence $S\nequiv\cbrk$,
\[ \orderset{S} = [S]_\equiv \cap \setssmp, \]
where $[S]_\equiv \cap \setssmp$ is the set of simple sequences equivalent to $S$.
\end{mylem}
\begin{proof}
First, we prove, by contradiction, that if a simple sequence $T\equiv S$, then $T\in\orderset{S}$.
We assume $T\equiv S$ and $T\not\in\orderset{S}$.
Then, from \cref{equiv_simple_same_commands} we know $T$ is a permutation of $S$,
and from \cref{order_is_only_possible} we know $T\equiv\cbrk$ which
is a contradiction as $T\equiv S\nequiv\cbrk$.

Next, we prove that if $T\in\orderset{S}$, then $T\equiv S$.
We proceed by induction.
Our base cases are $\emptyseq$, where $\orderset{\emptyseq}=\{\emptyseq\}$,
and one-long sequences, where this is trivially true.
In our induction step we assume that $T^*\in\orderset{S^*}\Rightarrow T^*\equiv S^*$ holds
for all sequences of length $i\geq 1$ or less.

Let us consider $T\in\orderset{S}$ where $T$ and $S$ are of length $i+1$.
We know that due to \cref{ax_separate_commute,incomparable_is_independent}
$T$ can be rearranged into $T'\equiv T$ where
$T'=T_1\cc T_2\cc \cdots \cc T_k$ and the segments $T_j$ are pairwise independent,
and where we have the maximum number of segments possible.
$S$ can be converted similarly into $S'$, and
as because of \cref{equiv_simple_same_commands} $S$ and $T$ contain the same commands,
the segments of $S'$ will contain the same commands as those of $T$.
Let us therefore rearrange the segments of $S'$ so that the first segment
$S_1$ would correspond to (i.e. contain the same commands as) $T_1$, the second segment $S_2$ to $T_2$,
and so on.

The segments contain commands in the same order as the full sequences.
Therefore, from \cref{subseq_in_orderset}
we know for all $1\leq j\leq k$, $T_j\in\orderset{S_j}$,
and if $T'$ has at least two segments and so 
they are shorter than $i+1$,
from the induction hypothesis
we also know $T_j\equiv S_j$, from which we get $T'\equiv S'$ and $T\equiv S$.

The remaining case is when $T'$ has at least two commands,
but only one segment, which means
that all nodes that the commands in $T'$ apply to
are related via $\descendant$.
$T'$ contains the same commands as $S$, and
from \cref{connected_changes} we see that the nodes the commands apply to therefore form a tree in $\setn$.
We can therefore select the command on the topmost node (let it be $\cxynv$),
and we know $T'$ contains commands on some of its child nodes.
Let one of these be $\czwmv$.
Now mark the command $\czwmv$ and all commands in $T'$ that are applied to nodes that are descendants of $m$.
From \cref{ax_separate_commute} we know that all remaining commands in $T'$ (except $\cxynv$)
commute with the marked commands; therefore we can swap them to get $T''\equiv T'$
where marked commands are next to $\cxynv$:
\[ T'' = T_\mathrm{unmarked\ left} \cc T_\mathrm{marked\ left} \cc \cxynv \cc T_\mathrm{marked\ right} \cc T_\mathrm{unmarked\ right}. \]


TODO




First, as $S$ only has at most one command on each node,
any sequence in $\orderset{S}$ either breaks a filesystem,
or it leaves it in the same state as $S$.
\end{proof}





%% TODO Define set operations on sequences?
% \noindent As a specific case, we can regard a simple sequence $S$
% as a set, and use the above algorithm to generate all possible orderings
% of the commands it contains.

TODO:
It follows from the algorithm that:
\begin{mycor}\label{lemma:neighbor}
If $U$ contains commands on both $n$ and $\parent(n)$, then
there is a simple $U'\equiv U$ in which they are next to each other.
\end{mycor}


TODO:
It follows from this that given a simple set,
we can simply assume that it has an order.
Accordingly, we will at times treat not only sequences as sets,
but simple sets as sequences.

