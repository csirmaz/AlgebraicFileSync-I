
\subsection{Ordering commands}\label{ordering}

We often encounter the case where we only have a set of commands without a specified order.
As we have seen above, this can occur after the first stage of update detection,
but, more importantly,
it is actually the task of the reconciler to determine whether there is an order,
and if yes, what order,
in which updates from different replicas can be applied to a filesystem.

In this section we describe a method with which all possible orderings of a
simple set of commands can be generated, but before doing so, let us consider the following lemma.

\begin{mylem}\label{connected_changes}
Given a set of commands that
does not contain assertion commands,
and which can be applied to a filesystem in some order without breaking it,
and which contains commands on $n$ and $\nn$ where $\nn\descendant n$,
then the set must also contain a command
on each node between $n$ and $\nn$.
\end{mylem}
\begin{proof}
Without loss of generality, we can assume that $\nn\neq\parent(n)$.
We prove that under the given conditions, the set must contain a command on $\parent(n)$.
Then, by reapplying this result, we know that the set must contain commands on every
ancestor of $n$ up to $\nn$.

Furthermore,
we prove this proposition for sequences, not sets, as if all sequences must contain a command on $\parent(n)$,
then so must all sets because otherwise there would be no order in which the commands they contain could be
applied to any filesystem.

Let $A$ be a sequence that satisfies the conditions;
we therefore know that it contains a command $\cxynv$ on $n$
and another command $\czwnnv$ on $\nn$.
We use a proof by contradiction and assume that there are no commands on $\parent(n)$ in $A$.
Next, we create a new sequence $A'\equiv A$ in which $\cxynv$ and $\czwnnv$ are next to each other.
If they are already next to each other in $A$, there is nothing to do.
Otherwise, consider the command next to $\cxynv$ in the direction where $\czwnnv$ is.
Let this command be $\cqrmv$.
If $\czwnnv$ is to the right, then $A$ looks like the following:
\[ A = \cdots\cc\cxynv\cc\cqrmv\cc\cdots\cc\czwnnv\cc\cdots \]
If $n\unrel m$, then swap $\cxynv$ and $\cqrmv$. Based on \cref{ax_separate_commute} we know that the new
sequence is equivalent to $A$.
Otherwise, we know $m\neq\parent(n)$ as there are no commands on $\parent(n)$, and so
from \cref{ax_distantrel_breaks} we get $A\equiv\cbrk$ which contradicts our assumptions.
(Note that $A$ cannot contain assertion commands.)
By repeating this step we can therefore convert $A$ into $A'$ where $\cxynv$ and $\czwnnv$ are neighboring commands.
However, then \cref{ax_distantrel_breaks} applies to the sequence and therefore $A\equiv A'\equiv\cbrk$ which
is again a contradiction.
\end{proof}

\bigskip

\noindent
We can now define the method to generate possible orders of sets of commands.
What we expect is that if the commands can be applied to a filesystem
in some order without breaking it, then the method will yield all possible orders
in which they can be applied.

\begin{mydef}[$\ordersetsign$]
For a simple set or sequence $U\nequiv\cbrk$,
we use $\orderset{U}$ to denote the set of sequences
that are all permutations of the commands in $U$
for which the following holds:
for any two commands $\cxynv$ and $\czwmv$ in a sequence in $\orderset{U}$
where $\cxynv$ comes earlier in the sequence than $\czwmv$,
\begin{itemize}
\item if $n=\parent(m)$, then $y=\vald$
\item if $\parent(n)=m$, then $y=\empt$.
\end{itemize}
\end{mydef}

The principal ideas behind this algorithm are 
\cref{ax_separate_commute}, from which we know that commands on incomparable
nodes can be applied in any order, so we only need to focus on the order of commands
with comparable nodes;
\cref{connected_changes}, from which we know that if $U$ contains commands on two comparable
nodes, then it contains commands on all nodes in between, so it is enough to specify
the order of commands on parent and child nodes;
and finally, \cref{ax_directchild_breaks,ax_directparent_breaks}, from which we know
that commands on parent--child pairs must be construction or destruction pairs.
Investigating the pairs we see that they are identified by the output value of the first command ($y$),
and that they determine whether the command on the parent or the child must precede the other.

In \cref{simple_reorder_equiv} we offer a formal proof that $\orderset{U}$ meets our expectations.
It is
an important property of simple sequences: namely, that
all of their valid reorderings are equivalent,
and all equivalent sequences are mere reorderings.
To prove this, first we prove the following:


%% TODO Define set operations on sequences?
% \noindent As a specific case, we can regard a simple sequence $S$
% as a set, and use the above algorithm to generate all possible orderings
% of the commands it contains.

\begin{mylem}\label{equiv_simple_same_commands}
If two simple sequences $A$ and $B$ are equivalent
and do not break all filesystems ($A\equiv B\nequiv\cbrk$),
then they must contain the same commands.
\end{mylem}
\begin{proof}
We use a proof by contradiction. Let $A$ and $B$ be simple sequences
such that $A\equiv B\nequiv\cbrk$,
and $\FS$ be a filesystem that they do not break.

We also assume that they do not contain the same commands.
Without loss of generality, we can assume
that $A$
contains $\cxynv$, and $B$ either contains a different command
$\czwnv$ on $n$, or no command on $n$ at all.
As $A$ is simple, we know that $\cxynv$ is not an assertion command,
and therefore $[x]\neq [y]$ and $\FS(n)\neq y$ as $[\FS(n)]=[x]$.
If so, then if $B$ has no command on $n$, then $B\aFS(n)=\FS(n)$ and
$A$ and $B$ cannot be equivalent.
Otherwise we know that $[z]=[x]$ as $B$ does not break $\FS$ either,
and that $w=y$ as $B\aFS(n)$ must
be $y$ and $B$ only has one command on $n$.
However, then $\czwnv=\cxynv$, which is a contradiction.
\end{proof}



\begin{mylem}\label{simple_reorder_equiv}
For a simple sequence $S\nequiv\cbrk$,
\[ \orderset{S} = [S]_\equiv \cap \setssmp, \]
where $[S]_\equiv \cap \setssmp$ is the set of simple sequences equivalent to $S$.
\end{mylem}
\begin{proof}
First, as $S$ only has at most one command on each node,
any sequence in $\orderset{S}$ either breaks a filesystem,
or it leaves it in the same state as $S$.

TODO:
Second, based on the algorithm we also know that $\orderset{S}$ contains
all possible orderings of $S$ as the only ordering between commands
it prescribes are when the commands in the reverse order would break every filesystem.

If, for example, in a component or sub-component
made up of construction pairs,
the command on the topmost node, $\cxynv$, was not before all other commands
in the component as prescribed by the algorithm,
then any resulting sequence would necessarily contain
a $\czwmv$ where $n\descendant m$, potentially followed by commands
on incomparable nodes, and then followed by $\cxynv$.
From \cref{ax_separate_commute} we know we can convert this sequence
to an equivalent sequence by swapping the commands on incomparable nodes with
$\czwmv$, which sequence would therefore have the commands on
$m$ and $n$ next to each other. Then from \cref{ax_distantrel_breaks,ax_directparent_breaks}
we know the sequence would break all filesystems
as a reversed construction pair is never a valid destruction pair.

We can prove that an order not generated by the algorithm
in the case of a component made of destruction pairs breaks all filesystems
in a similar way.

Also, from \cref{ax_separate_commute} we know
that the order between any other command pairs is not fixed in the sense
that if one order works, so will the other.

From these we know that all sequences in $\orderset{S}$
are equivalent, and that any sequence of the same commands outside it
necessarily breaks all filesystems.
We also know $S\in\orderset{S}$ as $S\nequiv\cbrk$
and therefore $T\in\orderset{S} \Rightarrow T\equiv S$.

From \cref{equiv_simple_same_commands} we know that 
if $T\equiv S$, then $T$ contains the same commands as $S$,
from which we see
that $T\equiv S\Rightarrow T\in\orderset{S}$.
\end{proof}






%% TODO https://en.wikipedia.org/wiki/Equivalence_class


It follows from the algorithm that:
\begin{mycor}\label{lemma:neighbor}
If $U$ contains commands on both $n$ and $\parent(n)$, then
there is a simple $U'\equiv U$ in which they are next to each other.
\end{mycor}



It follows from this that given a simple set,
we can simply assume that it has an order.
Accordingly, we will at times treat not only sequences as sets,
but simple sets as sequences.

