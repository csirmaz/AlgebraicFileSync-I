
% TODO Commuting commands important as we need to establish order

\subsection{Ordering commands}\mlabel{ordering}

We often encounter the case where we only have a set of commands without a specified order.
As we have seen above, this can occur after the first stage of update detection,
but, more importantly,
it is actually the task of the reconciler to determine whether there is an order,
and if yes, what order,
in which updates from different replicas can be applied to a filesystem.

As we recognize that mulitple orders may be possible,
let us describe our ordering algorithm by
defining a subset of the permutations, $\ordersetsign$.
The simplicity of the definition means that enumerating
all sequences in $\ordersetsign$ can be implemented by a straightforward
algorithm.

As we will see, $\ordersetsign$ contains all possible
sequences of commands that do not break all filesystems.
In \cref{simple_reorder_equiv}, we offer a formal proof of this.
The facts that all valid reorderings of simple sequences are equivalent,
and all equivalent sequences are reorderings are important 
properties of simple sequences.

\begin{mydef}[$\ordersetsign$]\mlabel{def_orderset}
For a simple set or sequence of commands $S$,
we use $\orderset{S}$ to denote the set of 
permutations of the commands in $S$
for which the following holds:
for any subsequence $\cxynv\cc\czwmv$,
\begin{itemize}
\item if $n=\parentf{m}$, then $[y]=[\vald]$
\item if $\parentf{n}=m$, then $y=\empt$.
\end{itemize}
\end{mydef}

As usual, by subsequence we mean a subset of the commands in $S$ in the same order as they are found in $S$.

The principal ideas behind these conditions are 
\cref{ax_separate_commute}, from which we know that commands on incomparable
nodes can be applied in any order, so we only need to focus on the order of commands
with comparable nodes;
\cref{connected_changes}, from which we know that if a simple sequence contains commands on two comparable
nodes, then it contains commands on all nodes in between, so it is enough to specify
the order of commands on directly related nodes;
and finally, \cref{simple_distant_pairs}, from which we know
that commands on parent--child pairs must be construction or destruction pairs.
Investigating these pairs we see that they are identified by the output value of the first command ($y$),
which in turn determines whether the command on the parent or the child must precede the other.

To prove \cref{simple_reorder_equiv}, we need the following simple results.

\begin{myclm}\mlabel{subseq_in_orderset}
For simple sequences $S$ and $T$,
if $T\in\orderset{S}$, then for any subsequence of $S$, $S_0$,
and for the corresponding subsequence of $T$, $T_0$, which
contains the same commands but in the order they are found in $T$,
$T_0\in\orderset{S_0}$ must hold.
\end{myclm}
\begin{proof}
This is because
if there are no command pairs in $T$ not conforming to \cref{def_orderset},
then there cannot be any in $T_0$.
\end{proof}



\begin{mylem}\mlabel{simple_distant_pairs}
For any simple sequence $\wrksx{S}$,
if $\cxynv\cc\czwmv$ is a subsequence of $S$ and $n=\parent(m)$ or $\parent(n)=m$,
then $\cxynv\cc\czwmv$ is either a construction or a destruction pair.
\end{mylem}

Informally speaking, the proposition means that
the two commands must form a construction or destruction pair even
if they are not next to each other.
This is true because in simple sequences
there cannot be another command on $n$ or $m$,
so if the commands are incompatible, no command between them can change that.
In fact, this \namecref{simple_distant_pairs} is the general case
of \cref{ax_directchild_breaks,ax_directparent_breaks} when there are no assertion commands.

\begin{proof}
% BACK_TO_THE_FS TODO
Formally, we prove our proposition by contradiction,
and in this version of the proof we reach back to our filesystem model.
We assume $\wrks{S}$ and therefore there is a $\FS$ for which $S\aFS\neq\fsbroken$,
but $S$ contains commands on a node and its parent that do not form a construction or destruction pair.
Select two such commands, $\cxynv$ and $\czwmv$,
and split $S$ around them into three parts:
\[ S = S_0 \cc \cxynv \cc S_1 \cc \czwmv \cc S_2. \]
As $S$ is simple, there cannot be any commands on $n$ or $m$ in $S_1$,
and therefore $(S_0\cc\cxynv\cc S_1)\FS(n) = y$,
and $[(S_0\cc\cxynv\cc S_1)\FS(m)] = [S_0\FS(m)]$.
If $[z]\neq[S_0\FS(m)]$, then $S\aFS=\fsbroken$, which is a contradiction.

If $n=\parent(m)$, then 
we know $(S_0\cc\cxynv\cc S_1)\FS(n) = y$, and as $[z]\neq[w]$, either
$[(S_0\cc\cxynv\cc S_1)\FS(m)]=[z]\neq[\empt]$,
or $[(S_0\cc\cxynv\cc S_1\cc\czwmv)\FS(m)]=[w]\neq[\empt]$.
Therefore $y$ must be $\vald$, as otherwise the tree property would be violated
when applying $\czwmv$,
and $[x]\neq[\vald]$ as $\cxynv$ is not an assertion command.
As $[S_0\FS(n)]=[x]\neq[\vald]$, we know
$S_0\FS(m)=\empt$ as otherwise the tree property would be violated.
Therefore $[S_0\FS(m)]=[z]=[\empt]$, which, combined with $y=\vald$
means that $\cxynv\cc\czwmv$ is a construction pair, which is a contradiction.

If $\parent(n)=m$, then 
as $(S_0\cc\cxynv\cc S_1)\FS(n) = y$, and either
$[(S_0\cc\cxynv\cc S_1)\FS(m)]=[z]\neq[\vald]$
or $[(S_0\cc\cxynv\cc S_1\cc\czwmv)\FS(m)]=[w]\neq[\vald]$,
$y$ must be $\empt$, and $[x]\neq[\empt]$.
As $[S_0\FS(n)]=[x]\neq[\empt]$, we know $S_0\FS(m)=\vald$.
Therefore $[S_0\FS(m)]=[z]=[\vald]$, which, combined with $y=\empt$
means that $\cxynv\cc\czwmv$ is a destruction pair, which is a contradiction.
\end{proof}


\begin{mycor}\mlabel{order_is_only_possible}
For any simple sequence $S$ and its permutation $S'$, 
\[ S'\not\in\orderset{S} \Longrightarrow S'\equiv\cbrk. \]
\end{mycor}
\begin{proof}
This follows directly from \cref{simple_distant_pairs}.
We use an inverse proof and assume $\wrksx{S'}$.
If $S'\not\in\orderset{S}$ then by \cref{def_orderset}
it contains two commands on a node $n$ and its parent
that, as a subsequence,
do not form a construction or destruction pair.
However, this contradicts \cref{simple_distant_pairs}
which means that no such subsequence exists.
\end{proof}



\begin{mylem}\mlabel{connected_changes}
Given a set of commands that
does not contain assertion commands,
and which can be applied to a filesystem in some order without breaking it,
and which contains commands on $n$ and $\nn$ where $\nn\descendant n$,
then the set must also contain a command
on each node between $n$ and $\nn$.
\end{mylem}
\begin{proof}
TODO: If something changes, everything changes up to the leaves.

Without loss of generality, we can assume that $\nn\neq\parent(n)$.
We prove that under the given conditions, the set must contain a command on $\parent(n)$.
Then, by reapplying this result, we know that the set must contain commands on every
ancestor of $n$ up to $\nn$.

Furthermore,
we prove this proposition for sequences, not sets, as if all sequences must contain a command on $\parent(n)$,
then so must all sets because otherwise there would be no order in which the commands they contain could be
applied to a filesystem.

Let $A$ be a sequence that satisfies the conditions;
we therefore know that it contains a command $\cxynv$ on $n$
and another command $\czwnnv$ on $\nn$.
We use a proof by contradiction and assume that there are no commands on $\parent(n)$ in $A$.
Next, we create a new sequence $A'\equiv A$ in which $\cxynv$ and $\czwnnv$ are next to each other.
If they are already next to each other in $A$, there is nothing to do.
Otherwise, consider the command next to $\cxynv$ in the direction where $\czwnnv$ is.
Let this command be $\cqrmv$.
If $\czwnnv$ is to the right, then $A$ looks like the following:
\[ A = \cdots\cc\cxynv\cc\cqrmv\cc\cdots\cc\czwnnv\cc\cdots \]
If $n\unrel m$, then swap $\cxynv$ and $\cqrmv$. Based on \cref{ax_separate_commute} we know that the new
sequence is equivalent to $A$.
Otherwise, we know $m\neq\parent(n)$ as there are no commands on $\parent(n)$, and so
from \cref{ax_distantrel_breaks} we get $A\equiv\cbrk$ which contradicts our assumptions.
(Note that $A$ cannot contain assertion commands.)
By repeating this step we can therefore convert $A$ into $A'$ where $\cxynv$ and $\czwnnv$ are neighboring commands.
However, then \cref{ax_distantrel_breaks} applies to the sequence and therefore $A\equiv A'\equiv\cbrk$ which
is again a contradiction.
\end{proof}


\begin{mylem}\mlabel{equiv_simple_same_commands}
If two simple sequences $A$ and $B$ are equivalent
and do not break all filesystems ($A\equiv \wrksx{B}$),
then they must contain the same commands.
\end{mylem}
\begin{proof}
% BACK_TO_THE_FS
% TODO Rule?
Let $A$ and $B$ be simple sequences
such that $A\equiv \wrksx{B}$,
and $\FS$ be a filesystem that they are defined on.
We use a proof by contradiction, and assume that they do not contain the same commands.
Without loss of generality, we can assume
that $A$
contains $\cxynv$, and $B$ either contains a different command
$\czwnv$ on $n$, or no command on $n$ at all.
As $A$ is simple, we know that $\cxynv$ is not an assertion command,
and therefore either $[x]\neq [y]$, or it is a replacement command.

If $[x]\neq [y]$, then $\FS(n)\neq y$ as $[\FS(n)]=[x]$.
Therefore, if $B$ has no command on $n$, then $B\aFS(n)=\FS(n)\neq y=A\aFS(n)$ and
$A$ and $B$ cannot be equivalent.
If $B$ includes $\czwnv$, then we know that $[z]=[x]$ as $B$ does not break $\FS$ either,
and that $w=y$ as $B\aFS(n)$ must
be $y$ and $B$ only has one command on $n$.
This means that $\czwnv=\cxynv$, which is a contradiction.

If $\cxynv$ is a replacement command, then we know $[x]=[y]=[\valfx]$, and
$[\FS(n)]=[\valfx]$. If $\FS(n)=y$, then instead of this filesystem,
consider $\fsreplacement{\FS}{n}{\valf}$ where $\valf$ is any file value
other than $y$.
(We assume that there are more than one file values; if this is not so,
$\cffa{n}$ becomes an assertion command.)
From here the proof concludes in the same way as above.
\end{proof}

% TODO delete unused results

\begin{mylem}\mlabel{simple_reorder_equiv}
For a simple sequence $\wrksx{S}$,
$\orderset{S}$ is the set of all simple sequences equivalent to $S$.
% that is, \[ \orderset{S} = \{T \whr T\equiv S \:\wedge\: T \mbox{~is simple} \}. \]
\end{mylem}

\begin{proof}
First, we prove, by contradiction, that if $T$ is a simple sequence and $T\equiv S$, then $T\in\orderset{S}$.
We use an inverse proof and assume $T\equiv S$ and $T\not\in\orderset{S}$.
Then, from \cref{equiv_simple_same_commands} we know $T$ is a permutation of $S$,
and from \cref{order_is_only_possible} we know $T\equiv\cbrk$ which
is a contradiction as $T\equiv \wrksx{S}$.

Next, we prove that if $T\in\orderset{S}$, then $T\equiv S$.
We proceed by induction on the length of $S$.
Our base cases are $\emptyseq$, where $\orderset{\emptyseq}=\{\emptyseq\}$,
and one-long sequences, where this is trivially true.
In our induction step we assume that $T^*\in\orderset{S^*}\Rightarrow T^*\equiv S^*$ holds
for all sequences of length $i$ or less, where $i\geq 1$.

Let us consider $T\in\orderset{S}$ where $T$ and $S$ are of length $i+1$.
Let the first command in $S$ be $\cxynv$, that is, $S=\cxynv\cc S_0$.
We proceed by a nested induction on the number of commands before $\cxynv$ in $T$.
Our base case is when it is the first command, which means $T=\cxynv\cc T_0$.
Then from \cref{subseq_in_orderset} we know $T_0\in\orderset{S_0}$
and from the induction hypothesis $T_0\equiv S_0$ from which we get $T\equiv S$.

In our nested induction step we assume $T'\equiv S$ for all $T'\in\orderset{S}$
where there are at most $j$ commands in $T'$ to the left of $\cxynv$.
Let us then consider $T$ where there are $j+1$ such commands.
We aim to transform $T$ into $T''\equiv T$ by swapping $\cxynv$ with the preceding
command. Then from the induction hypothesis we know $T\equiv T''\equiv S$,
which proves our lemma.

Let the command to the left of $\cxynv$ in $T$ be $\czwmv$.
As $S$ is simple, we know $n\neq m$.
If $n\unrel m$, then from \cref{ax_separate_commute} we know we can swap the two commands
and get an equivalent sequence.
We finish the proof by showing that $n\unrel m$ must hold, as
all other cases lead to contradiction.

\newcommand{\indx}{\varphi}
If $n\nunrel m$, then either $n\descendant m$, or $m\descendant n$, and so from
\cref{connected_changes} we know that $S$ contains a command on all nodes
between $n$ and $m$, and therefore so does $T$.
Let these nodes be $n_0, n_1, \ldots, n_k$ where $n_0=n$ and $n_k=m$,
and where 
either $n_\indx=\parentf{n_{\indx+1}}$ for all $\indx$ between $1$ and $k-1$,
or $n_{\indx+1}=\parentf{n_\indx}$ for all $\indx$.
We assume that $n_\indx=\parentf{n_{\indx+1}}$ is true.

Also, let $I^S_\indx$ be the index of the command on $n_\indx$ in $S$.
For all $\indx$, both the commands on $n_\indx$ and $n_{\indx+1}$ must be either
construction commands, or destruction commands, depending on
whether $I^S_\indx<I^S_{\indx+1}$ or $I^S_{\indx+1}<I^S_\indx$.
This is because otherwise, \cref{simple_distant_pairs} would not hold for $S$.

As a command cannot be both a construction and a destruction command,
this means that the indices $I^S$ are either monotone increasing, or monotone
decreasing, but cannot change direction.
And as $S$ begins with $\cxynv$ and so $I^S_0=1$, we know they are monotone increasing,
and the commands on $n_\indx$ are construction commands.
If we denote the command on $n_\indx$ with $\caaa{x_\indx}{y_\indx}{n_\indx}$,
by definition this means that $[y_\indx]\neq[\empt]$ for all $\indx$.

Let us turn to the location of these commands in $T$,
and denote their indices in $T$ with $I^T_\indx$.
We know $I^T_k=I^T_0-1$ as $\czwmv$ precedes $\cxynv$.
This means there must exist a $\indx$ for which $I^T_{\indx+1}<I^T_\indx$.
We therefore know that
$\caaa{x_{\indx+1}}{y_{\indx+1}}{n_{\indx+1}} \cc \caaa{x_\indx}{y_\indx}{n_\indx}$
is a subsequence of $T$, and by assumption $\parentf{n_{\indx+1}}=n_\indx$.
By definition of $\ordersetsign$, therefore $y_{\indx+1}=\empt$ must be true,
which is a contradiction.

It can be shown in the same way
that the case when the $n_\indx$ nodes ascend the tree,
that is, $n_{\indx+1}=\parentf{n_\indx}$ is true, also leads to a contradiction.
In this case we find that all commands are destruction commands,
and so $[y_\indx]\neq[\vald]$, while in a subsequence of $T$ for a given $\indx$,
$[y_\indx]=[\vald]$ must be true by definition of $\ordersetsign$.
\end{proof}


It follows from \cref{simple_reorder_equiv} that given a simple set of commands $S$,
which can be applied to a filesystem in some order without breaking it,
this order will be in $\orderset{S}$,
and all sequences in $\orderset{S}$
represent the same partial endofunction on filesystems.
This allows us to treat such a set as a sequence for any purpose
where the internal order of the commands is irrelevant.
\begin{mydef}[$\ordp{S}$]
For a simple set or sequence of commands $S$,
$\ordp{S}$ is the unique partial endofunction on filesystems
defined by any order in $\orderset{S}$.
We leave $\ordp{S}$ undefined if such an order does not exist.
\end{mydef}
